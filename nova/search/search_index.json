{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"addon/","title":"Getting Started","text":"<p>This guide is not beginner-friendly! Creating Nova addons requires advanced knowledge of Kotlin, the Paper API, and Gradle.</p>"},{"location":"addon/#setting-up-your-project","title":"Setting up your project","text":"<p>You can create a new repo using our addon template here. After creating the repo and cloning it, make sure to edit the following files:</p>"},{"location":"addon/#srcmainkotlin","title":"src/main/kotlin","text":"<p>Change the package name to your own.</p>"},{"location":"addon/#settingsgradlekts","title":"settings.gradle.kts","text":"<p>Change <code>rootProject.name</code> to your addon id.</p>"},{"location":"addon/#buildgradlekts","title":"build.gradle.kts","text":"<p>Change <code>group</code> to your group. Change <code>version</code> to your version.</p> <p>In the <code>addon</code> task, set <code>main</code> to your addon main class.</p>"},{"location":"addon/#adding-dependencies","title":"Adding dependencies","text":"<p>If your addon requires dependencies that need to be present at runtime, add them under the <code>libraryLoader</code> configuration:</p> build.gradle.kts dependencies { }<pre><code>libraryLoader(\"commons-net:commons-net:3.8.0\")\n</code></pre> <p>The requested library will be downloaded at startup. Note that using this mechanism exposes all urls of the maven repositories you use in your build configuration.</p>"},{"location":"addon/#building","title":"Building","text":"<p>To build, run Build with Gradle<pre><code>gradlew addonJar -PoutDir=\"&lt;Path to your addons directory here&gt;\"\n</code></pre></p>"},{"location":"addon/#enabling-dev-mode","title":"Enabling dev mode","text":"<p>To enable dev mode, add the <code>NovaDev</code> argument using <code>-DNovaDev</code>. This allows you to bypass some restrictions like using addons that require a different version of Nova and enables general-purpose debugging functionality.</p> <p>Additionally, you can use <code>-DNovaForceRegenerateResourcePack</code> to force the resource pack to be regenerated on startup.</p>"},{"location":"addon/#kdoc","title":"KDoc","text":"<p>The generated KDoc for Nova can be found on here.</p>"},{"location":"addon/abilities/","title":"Abilities","text":""},{"location":"addon/abilities/#what-are-abilities","title":"What are Abilities?","text":"<p>In Nova, abilities are ticking objects that can be assigned to players. They work similar to attachments, except that they have no logic by default.</p>"},{"location":"addon/abilities/#creating-your-own-ability","title":"Creating your own Ability","text":"<p>To create your own ability, inherit from <code>Ability</code> and add your custom <code>handleRemoved</code> and <code>handleTick</code> logic.</p> <pre><code>class ExampleAbility(player: Player) : Ability(player) {\n\n    override fun handleRemove() {\n        // TODO\n    }\n\n    override fun handleTick() {\n        // TODO\n    }\n\n}\n</code></pre> <p>Then, register a new ability type for that ability: <pre><code>@Init(stage = InitStage.PRE_PACK)\nobject Abilities {\n\n    val EXAMPLE_ABILITY = ExampleAddon.registerAbilityType(\"example_ability\", ::MyAbility)\n\n}\n</code></pre></p> <p>Then, give the ability to a player:</p> <pre><code>AbilityManager.giveAbility(player, Abilities.EXAMPLE_ABILITY)\n</code></pre> <p>And this is how you remove an ability:</p> <pre><code>AbilityManager.takeAbility(player, Abilities.EXAMPLE_ABILITY)\n</code></pre>"},{"location":"addon/addon-configuration/","title":"Configure Addon","text":"<p>Now that you've created your project, you need to set several values in the <code>addon</code> task.  If you're using the addon template, most of these values are already set for you.</p> <p>Options marked with a * are required.</p>"},{"location":"addon/addon-configuration/#name","title":"name*","text":"<p>This is the name of your addon. Names may only contain alphanumeric characters, periods, underscores, and hyphens (<code>[A-Za-z0-9._-]+</code>). The lowercase version of this name is used as your addon's id. Your items and blocks are linked to this id, so you cannot change it later, without breaking existing worlds.</p> <p>Example:</p> build.gradle.kts addon { }<pre><code>name.set(\"example\")\n</code></pre> <p>In most cases, you can just use your project name:</p> build.gradle.kts addon { }<pre><code>name.set(project.name)\n</code></pre>"},{"location":"addon/addon-configuration/#version","title":"version*","text":"<p>The version of the addon.</p> <p>Example:</p> build.gradle.kts addon { }<pre><code>version.set(\"1.0\")\n</code></pre> <p>Or to automatically get the version from your project:</p> build.gradle.kts addon { }<pre><code>version.set(project.version.toString())\n</code></pre>"},{"location":"addon/addon-configuration/#main","title":"main*","text":"<p>Full path to your addon main class (without the .class extension).</p> <p>Example:</p> build.gradle.kts addon { }<pre><code>main.set(\"com.example.ExampleAddon\")\n</code></pre>"},{"location":"addon/addon-configuration/#dependency","title":"dependency","text":"<p>You can declare dependencies on other plugins / addons using <code>dependency</code>:</p> <p>Example:</p> <p>The following creates a dependency in both <code>BOOTSTRAP</code> and <code>SERVER</code> phase on the given plugin: (If you're depending on a Nova addon, do this) build.gradle.kts addon { }<pre><code>dependency(\"machines\")\n</code></pre></p> <p>For plugins that don't have a bootstrapper, you can instead specify the phase: build.gradle.kts addon { }<pre><code>dependency(\"some-plugin\", PluginDependency.Stage.SERVER)\n</code></pre></p>"},{"location":"addon/addon-configuration/#pluginmain","title":"pluginMain","text":"<p>Full path to your plugin main class (without the .class extension). If you don't define this property, Nova will generate a plugin main class for you. You will be able to access your plugin instance via your addon object.</p> <p>Example:</p> build.gradle.kts addon { }<pre><code>pluginMain.set(\"com.example.ExamplePlugin\")\n</code></pre>"},{"location":"addon/addon-configuration/#loader","title":"loader","text":"<p>A custom plugin loader. Defining a custom plugin loader will disable Nova's library loading mechanism that can be accessed via the <code>libraryLoader</code> dependency configuration.</p> <p>Example:</p> build.gradle.kts addon { }<pre><code>loader.set(\"com.example.ExampleLoader\")\n</code></pre>"},{"location":"addon/addon-configuration/#bootstrapper","title":"bootstrapper","text":"<p>A custom bootstrapper.</p> <p>Example:</p> build.gradle.kts addon { }<pre><code>bootstrapper.set(\"com.example.ExampleBootstrapper\")\n</code></pre>"},{"location":"addon/addon-configuration/#description","title":"description","text":"<p>A description of your addon.</p> <p>Example:</p> build.gradle.kts addon { }<pre><code>description.set(\"This is an example addon.\")\n</code></pre>"},{"location":"addon/addon-configuration/#authors","title":"authors","text":"<p>A list of author(s) of your addon.</p> <p>Example:</p> build.gradle.kts addon { }<pre><code>authors.add(\"ExampleAuthor\")\n</code></pre>"},{"location":"addon/addon-configuration/#contributors","title":"contributors","text":"<p>A list of contributors to your addon.</p> <p>Example:</p> build.gradle.kts addon { }<pre><code>contributors.add(\"ExampleContributor\")\n</code></pre> <p>Or for multiple authors:</p> build.gradle.kts addon { }<pre><code>authors.set(listOf(\"ExampleAuthor\", \"Another Author\"))\n</code></pre>"},{"location":"addon/addon-configuration/#website","title":"website","text":"<p>A website for your addon.</p> <p>Example:</p> build.gradle.kts addon { }<pre><code>website.set(\"https://example.com\")\n</code></pre>"},{"location":"addon/addon-configuration/#prefix","title":"prefix","text":"<p>The prefix used in log messages.</p> <p>Example:</p> build.gradle.kts addon { }<pre><code>prefix.set(\"example\")\n</code></pre>"},{"location":"addon/addon-configuration/#example-configuration","title":"Example configuration","text":"build.gradle.kts<pre><code>addon {\n    name.set(\"ExampleAddon\")\n    version.set(\"0.1\")\n    main.set(\"com.example.ExampleAddon\")\n    authors.set(listOf(\"Example Author\", \"Another Author\"))\n    dependency(\"machines\")\n}\n</code></pre>"},{"location":"addon/attachments/","title":"Attachments","text":""},{"location":"addon/attachments/#what-is-an-attachment","title":"What is an Attachment?","text":"<p>In Nova, an <code>Attachment</code> is a (fake) entity riding a player, but you'll mostly likely use the <code>ItemAttachment</code> implementation which is a clientside armor stand riding a player while wearing a custom item as a helmet. The attachment system makes assigning models to players easy, as it handles all the riding logic. Once a player is given an attachment, it will stay on that player until it is removed again.</p>"},{"location":"addon/attachments/#creating-an-attachmenttype","title":"Creating an AttachmentType","text":"<p>Register an attachment type:</p> <pre><code>@Init(stage = InitStage.PRE_PACK)\nobject Attachments {\n\n    val EXAMPLE_ATTACHMENT = ExampleAddon.registerAttachmentType(\"example_attachment\") { ItemAttachment(it, Items.ATTACHMENT_ITEM) }\n\n}\n</code></pre> <p>Then, add the attachment to a player:</p> <pre><code>AttachmentManager.addAttachment(player, Attachments.EXAMPLE_ATTACHMENT)\n</code></pre> <p>And this is how you would remove it again:</p> <pre><code>AttachmentManager.removeAttachment(player, Attachments.EXAMPLE_ATTACHMENT)\n</code></pre>"},{"location":"addon/attachments/#modifying-attachment-logic","title":"Modifying Attachment Logic","text":"<p>You can also change the attachment logic by either directly implementing the <code>Attachment</code> interface or by extending the <code>ItemAttachment</code> class. Then, just call the constructor of your 'Attachment' subclass when registering the attachment type.</p> <p>If you need an attachment which gets hidden when a player looks down, check out the <code>HideOnDownItemAttachment</code>.</p>"},{"location":"addon/configs/","title":"Configs","text":""},{"location":"addon/configs/#configuration-library","title":"Configuration Library","text":"<p>Nova uses SpongePowered/Configurate, but most of the time you'll be dealing with Nova's <code>Provider&lt;ConfigurationNode&gt;</code>, which helps you with config reloading.</p>"},{"location":"addon/configs/#provider","title":"Provider","text":"<p>To help with config reloading, Nova offers the <code>Provider</code> class. Config providers are automatically reloaded when the config is reloaded. You can also chain value modification calls on a <code>Provider</code>. Those modification steps will then be run lazily every time the config is reloaded.</p> <p>Some of those modification functions are:</p> <ul> <li><code>map</code> - Maps the value to a new value.</li> <li><code>orElse</code> - Falls back to a default value if the value is null.</li> </ul> <p>Every time such a modification function is called, a new <code>Provider</code> is created and returned. This allows you to create several modified versions from the same <code>Provider</code>.</p> <p>You might also be interested in these <code>Provider</code>-related top-level functions:</p> <ul> <li><code>provider(value: T)</code> - Creates a constant <code>Provider</code> from a given value.</li> <li><code>provider(lazyValue: () -&gt; T)</code> - Creates a <code>Provider</code> that loads it value lazily.</li> <li><code>combinedProvider()</code> - Creates a <code>Provider&lt;List&lt;T&gt;&gt;</code> from a list of <code>Provider&lt;T&gt;</code>s.</li> </ul>"},{"location":"addon/configs/#config-extraction","title":"Config extraction","text":"<p>Nova will automatically extract all configs from <code>resources/configs/</code> on startup. New or changed keys will automatically be added / updated on the server as well, unless they have been modified on the server.</p>"},{"location":"addon/configs/#accessing-configs","title":"Accessing configs","text":"<p>To access the configs, retrieve them from <code>Configs</code>. You can either use their names: <pre><code>Configs[\"example:ruby\"] // namespace:name (drop the .yml)\n</code></pre></p> <p>Or retrieve the config of a <code>NovaItem</code> or <code>NovaBlock</code> using <code>NovaItem.config</code> and <code>NovaBlock.config</code>.</p> <p>All of the above ways will result in you obtaining a config provider, which is a <code>Provider&lt;CommentedConfigurationNode&gt;</code>. (Note that Configurate does not have support for yaml comments yet,  but this should not be an issue unless you need to write to the config file.) Now, you can either retrieve the raw config node using <code>provider.get()</code>, or get a reloadable entry provider using <code>provider.entry&lt;Type&gt;(\"path\")</code> and <code>provider.optionalEntry&lt;Type&gt;(\"path\")</code>.</p> <pre><code>val exampleValue1: Int by Items.EXAMPLE_ITEM.config.entry&lt;Int&gt;(\"example_value\") // (1)!\nval exampleValue2: Int? by Items.EXAMPLE_ITEM.config.optionalEntry&lt;Int&gt;(\"optional_value\") // (2)!\n</code></pre> <ol> <li>Delegating to the <code>Provider&lt;Int&gt;</code> will cause this field automatically change every time the config is reloaded.</li> <li>Using <code>Provider&lt;ConfigurationNode&gt;#optionalEntry</code>, you can get a <code>Provider&lt;Int?&gt;</code>, where the value is null if the key    is not present in the config.</li> </ol>"},{"location":"addon/contexts/","title":"Contexts","text":"<p>Usage of Contexts in Nova</p> <p>Contexts are currently only used for block-related events, but it is planned to expand them to other aspects in the future.</p> <p>A <code>Context</code>, at its core, is a simple key-value storage for <code>(ContextParamType&lt;T&gt;, T)</code> pairs and a <code>ContextIntention</code>, which defines the allowed parameters.</p> <p>You can find a list of default context intentions here. You can find a list of default context param types here. The documentation also notes which types are parameter types are required for which <code>ContextIntention</code> and which are optional.</p> <p>The context system can also infer parameters from other parameters, for example, you don't need to provide a <code>BLOCK_WORLD</code> parameter if you provide a <code>BLOCK_POS</code> parameter, and you can still read <code>BLOCK_WORLD</code> from the context. Which parameters are inferred from other parameters is also noted in the context param type documentation.</p>"},{"location":"addon/contexts/#creating-and-using-a-context","title":"Creating and using a Context","text":"<p>And this is how you create and use a <code>Context</code>:</p> <pre><code>// create a context to place EXAMPLE_BLOCK at pos\nval context = Context.intention(DefaultContextIntentions.BlockPlace)\n    .param(DefaultContextParamTypes.BLOCK_POS, pos)\n    .param(DefaultContextParamTypes.BLOCK_TYPE_NOVA, Blocks.EXAMPLE_BLOCK)\n    .build()\n\n// read BLOCK_WORLD from context, which is inferred from BLOCK_POS\nval world: World = context.getOrThrow(DefaultContextParamTypes.BLOCK_WORLD)\n\n// place block\nBlockUtils.placeBlock(context)\n</code></pre>"},{"location":"addon/contexts/#custom-contextparamtype","title":"Custom ContextParamType","text":"<p>In the example below I've created a custom <code>ContextParamType</code> that can be used in the <code>BlockPlace</code>, <code>BlockBreak</code>, <code>BlockInteract</code> default intentions. It represents the name of the target block  and is autofilled through either the <code>BLOCK_TYPE_NOVA</code> or <code>BLOCK_TYPE_VANILLA</code> parameter.</p> <pre><code>val BLOCK_NAME: ContextParamType&lt;Component&gt; =\n    ContextParamType.builder&lt;Component&gt;(Machines, \"block_name\")\n        .optionalIn(BlockPlace, BlockBreak, BlockInteract)\n        .autofilledBy(DefaultContextParamTypes::BLOCK_TYPE_NOVA) { type: NovaBlock -&gt; type.name }\n        .autofilledBy(DefaultContextParamTypes::BLOCK_TYPE_VANILLA) { type: Material -&gt; Component.translatable(type.blockTranslationKey!!) }\n        .build()\n</code></pre>"},{"location":"addon/entity-variants/","title":"Entity Variants","text":""},{"location":"addon/entity-variants/#what-is-an-entity-variant","title":"What is an Entity Variant?","text":"<p>Entity variants are a vanilla Minecraft feature and allow you to add retextured variants of existing entities to the game.  (Minecraft Wiki)</p>"},{"location":"addon/entity-variants/#registering-a-custom-entity-variant","title":"Registering a custom entity variant","text":"<p>You can register a custom entity variant like this:</p> <pre><code>@Init(stage = InitStage.PRE_PACK) // (1)!\nobject EntityVariants  {\n\n    val BLUE_COW by ExampleAddon.cowVariant(\"blue\") {\n        spawnConditions { \n            // (2)!\n        }\n\n        texture(CowModelType.WARM /*(3)!*/) {\n            texture(\"entity/cow/blue\")\n        }\n    }\n\n}\n</code></pre> <ol> <li>Nova will load this class during addon initialization, causing your variants to be registered.</li> <li>The conditions for your custom variant to be selected when spawning. See Minecraft Wiki - Spawn Conditions  for more information.</li> <li>Some entities offer multiple model types. For example, the warm cow has horns. You can select the model type here.</li> </ol>"},{"location":"addon/hitboxes/","title":"Hitboxes","text":""},{"location":"addon/hitboxes/#hitbox-implementations","title":"Hitbox Implementations","text":"<p>Nova provides you with two built-in ways to handle left- and right-click detection in game.</p>"},{"location":"addon/hitboxes/#physicalhitbox","title":"PhysicalHitbox","text":"<p>A <code>PhysicalHitbox</code> uses an Interaction Entity. This means that the hitbox can be shown by pressing <code>F3+B</code> and functions similar to a normal entity, with it not allowing to interact with anything behind it. <code>PhysicalHitboxes</code> are also restricted to a square base area, as they only have a <code>width</code> and a <code>height</code>.</p> <pre><code>// create the hitbox\nval hitbox = PhysicalHitbox(center, width, height)\n// add click handlers\nhitbox.addLeftClickHandler { /* ... */ }\nhitbox.addRightClickHandler { /* ... */ }\n// spawn the hitbox\nhitbox.register()\n// despawn the hitbox\nhitbox.unregister()\n</code></pre>"},{"location":"addon/hitboxes/#virtualhitbox","title":"VirtualHitbox","text":"<p><code>VirtualHitboxes</code> use server-side ray casts, which allows for more complex and flexible hitboxes. For one, their size is completely customizable, and they're not limited to a square base area. Additionally, you can also specify a <code>qualifier</code> function, which allows you to filter out certain cases where the hitbox should not be triggered and the player should be able to interact with the block behind it.</p> <p>You can show all virtual hitboxes using the command <code>/nova debug showHitboxes</code>.</p> <pre><code>// create the hitbox\nval hitbox = VirtualHitbox(from, to)\n// set the qualifier function\nhitbox.setQualifier { /* ... */ }\n// add click handlers\nhitbox.addLeftClickHandler { /* ... */ }\nhitbox.addRightClickHandler { /* ... */ }\n// spawn the hitbox\nhitbox.register()\n// despawn the hitbox\nhitbox.unregister()\n</code></pre>"},{"location":"addon/hitboxes/#hit-location","title":"Hit Location","text":"<p>When a player clicks a hitbox, you might be supplied with a <code>Vector3f location</code> parameter. This location is relative to the center of the base area of the hitbox. To determine the block face that was clicked, you can use the  <code>Hitbox.determineBlockFace(location: Vector3f)</code> function.</p> <p>Info</p> <p>Whether or not you're supplied with a <code>location</code> parameter depends on the click type and hitbox implementation. For physical hitboxes, only right-clicks will supply you with a location, while for virtual hitboxes, both left- and right-clicks will supply you with a location.</p>"},{"location":"addon/initialization/","title":"Initialization","text":"<p>Simply annotate any singleton object with <code>@Init</code> and Nova will load the class during the specified initialization stage.</p> Example initializable class<pre><code>@Init(stage = InitStage.PRE_PACK)\nobject Example\n</code></pre>"},{"location":"addon/initialization/#dispatcher","title":"Dispatcher","text":"<p>You can also define an initialization dispatcher: <code>SYNC</code> (default) to perform the initialization synchronously with all  other initializables, or <code>ASYNC</code> to perform the initialization asynchronously, in parallel with other async initializables.</p> <pre><code>@Init(\n    stage = InitStage.POST_WORLD,\n    dispatcher = Dispatcher.ASYNC\n)\nobject Example {\n\n    @InitFun\n    private fun init() {\n        // ...  \n    }\n\n}\n</code></pre>"},{"location":"addon/initialization/#initialization-dependencies","title":"Initialization Dependencies","text":"<p>If the pre-defined initialization stages are not enough for you, you can also configure which classes that should be initialized before (<code>runAfter</code>) or after (<code>runBefore</code>) your class:</p> Example initializable class with dependencies<pre><code>@Init(\n    stage = InitStage.PRE_PACK,\n    runAfter = [ClassA::class], // This class will be initialized after ClassA\n    runBefore = [ClassB::class] // This class will be initialized before ClassB\n)\nobject Example\n</code></pre>"},{"location":"addon/initialization/#functions","title":"Functions","text":"<p>If your class is annotated with <code>@Init</code>, you can also annotate your functions with <code>@InitFun</code> and <code>@DisableFun</code>. There, you can also configure initialization dependencies and a dispatcher. For <code>@InitFun</code>.</p> <ul> <li><code>@InitFun</code>: Specify one or more functions that should be called during initialization.</li> <li><code>@DisableFun</code> Specify one or more functions that should be called when your addon is disabled.</li> </ul> Example initializable class with functions<pre><code>@Init(stage = InitStage.PRE_PACK)\nobject Example {\n\n    @InitFun\n    private fun init() {\n        //Run during PRE_PACK init stage\n    }\n\n    @DisableFun\n    private fun disable() {\n        // Run when the addon is disabled\n    }\n\n}\n</code></pre>"},{"location":"addon/blocks/block-behaviors/","title":"Block Behaviors","text":"<p>Similar to ItemBehaviors, you can implement block logic via <code>BlockBehavior</code>.</p> <pre><code>@Init(stage = InitStage.PRE_PACK)\nobject Blocks {\n\n   val EXAMPLE_BLOCK = ExampleAddon.block(\"example_block\") {\n       behaviors(/*...*/)\n   }\n\n}\n</code></pre>"},{"location":"addon/blocks/block-behaviors/#default-block-behaviors","title":"Default block behaviors","text":"<p>For a list of all available default block behaviors, refer to the KDocs</p>"},{"location":"addon/blocks/block-behaviors/#custom-block-behavior","title":"Custom Block Behavior","text":"<p>To create a custom block behavior, you just need to implement the <code>BlockBehavior</code> interface and override the desired event methods.</p>"},{"location":"addon/blocks/block-behaviors/#random-ticks","title":"Random ticks","text":"<p>To receive random ticks in your block behavior, make sure to also override <code>BlockBehavior.ticksRandomly</code> which is used to define what block states can receive random ticks.</p> <p>Every tick, every chunk section (16x16x16 blocks) will have <code>random-tick-speed</code> blocks chosen randomly to receive a random tick.</p>"},{"location":"addon/blocks/creating-blocks/","title":"Creating Blocks","text":""},{"location":"addon/blocks/creating-blocks/#block-states","title":"Block States","text":"<p>Block states in Nova are quite similar to those in vanilla Minecraft. Every block type has at least one block state, and additional block states can be added using block state properties. For example, a directional block may have four block states for each cardinal direction, but they're all the same block type.</p>"},{"location":"addon/blocks/creating-blocks/#block-state-properties","title":"Block State Properties","text":"<p>In Nova, block state properties a separated into <code>BlockStateProperty</code> and <code>ScopedBlockStateProperty</code>. <code>BlockStateProperty</code> is just used to assign an id to a type, such as <code>nova:facing</code> to the <code>BlockFace</code> enum:</p> DefaultBlockStateProperties.kt<pre><code>val FACING: EnumProperty&lt;BlockFace&gt; = EnumProperty(ResourceLocation.fromNamespaceAndPath(\"nova\", \"facing\"))\n</code></pre> <p><code>ScopedBlockStateProperty</code> on the other hand defines which values are valid and how the default values are inferred from a block place context:</p> DefaultScopedBlockStateProperties.kt<pre><code> /**\n  * A scope for [DefaultBlockStateProperties.FACING], limited to the four horizontal directions\n  * [BlockFace.NORTH], [BlockFace.EAST], [BlockFace.SOUTH] and [BlockFace.WEST].\n  */\n val FACING_HORIZONTAL: ScopedBlockStateProperty&lt;BlockFace&gt; =\n     DefaultBlockStateProperties.FACING.scope(BlockFace.NORTH, BlockFace.EAST, BlockFace.SOUTH, BlockFace.WEST) { ctx -&gt;\n         ctx[DefaultContextParamTypes.SOURCE_DIRECTION]\n             ?.calculateYaw()\n             ?.let { BlockFaceUtils.toCartesianFace(it) }\n             ?.oppositeFace\n             ?: BlockFace.NORTH\n     }\n\n /**\n  * A scope for [DefaultBlockStateProperties.FACING], limited to the two vertical directions [BlockFace.UP] and [BlockFace.DOWN].\n  */\n val FACING_VERTICAL: ScopedBlockStateProperty&lt;BlockFace&gt; =\n     DefaultBlockStateProperties.FACING.scope(BlockFace.UP, BlockFace.DOWN) { ctx -&gt;\n         ctx[DefaultContextParamTypes.SOURCE_DIRECTION]?.calculateYawPitch()\n             ?.let { (_, pitch) -&gt; if (pitch &lt; 0) BlockFace.UP else BlockFace.DOWN }\n             ?: BlockFace.UP\n     }\n</code></pre> <p>The <code>ScopedBlockStateProperty</code> is only used for registering a block. <code>BlockStateProperty</code> is used to retrieve a values from a <code>NovaBlockState</code>. This separation is useful, as it allows us to generalize all scopes for <code>nova:facing</code> into a single property, so we don't need to check for each individual scope, but can just use <code>DefaultBlockStateProperties.FACING</code></p>"},{"location":"addon/blocks/creating-blocks/#creating-a-block-registry","title":"Creating a Block Registry","text":"<p>Create a singleton object and annotate it with <code>@Init</code> to have it loaded during addon initialization.</p> <pre><code>@Init(stage = InitStage.PRE_PACK) // (1)!\nobject Blocks {\n\n    // (2)!\n\n}\n</code></pre> <ol> <li>Nova will load this class during addon initialization, causing your blocks to be registered.</li> <li>Register your blocks here</li> </ol>"},{"location":"addon/blocks/creating-blocks/#creating-a-block","title":"Creating a block","text":"<p>You can create a very simple block like this:</p> <pre><code>@Init(stage = InitStage.PRE_PACK)\nobject Blocks {\n\n   val EXAMPLE_BLOCK = ExampleAddon.block(\"example_block\") {}\n\n}\n</code></pre> <p>This block will have no functionality and its model will default to the model defined under <code>models/block/example_block.json</code> or alternatively a cube model with the texture <code>textures/block/example_block.png</code>.</p>"},{"location":"addon/blocks/creating-blocks/#defining-the-block-model-layout","title":"Defining the block model layout","text":"<p>To define the block model layout, use the <code>models</code> scope in the builder.</p>"},{"location":"addon/blocks/creating-blocks/#model-backing","title":"Model backing","text":"<p>First you'll need to choose how to back the block model. In Nova, you can either use existing vanilla block states (<code>stateBacked(/*...*/)</code>), item display entities (<code>entityBacked(/*...*/</code>), or item display entities with a custom item model definition (<code>entityItemBacked(/*...*/)</code>) for custom blocks. All options have their own advantages and disadvantages, which are explained in more detail in the KDocs (here, here).</p> <p>In the following code snippet, I chose to back the custom block via mushroom blocks:</p> <pre><code>@Init(stage = InitStage.PRE_PACK)\nobject Blocks {\n\n    val EXAMPLE_BLOCK = ExampleAddon.block(\"example_block\") {\n       stateBacked(BackingStateCategory.MUSHROOM_BLOCK)\n    }\n}\n</code></pre>"},{"location":"addon/blocks/creating-blocks/#custom-model","title":"Custom Model","text":"<p>To override which model is used for your block, use the <code>selectModel</code> scope to select a model for each block state:</p> <pre><code>@Init(stage = InitStage.PRE_PACK)\nobject Blocks {\n\n    val EXAMPLE_BLOCK = ExampleAddon.block(\"example_block\") {\n        stateProperties(DefaultScopedBlockStateProperties.FACING_HORIZONTAL) // (1)!\n\n        stateBacked(BackingStateCategory.MUSHROOM_BLOCK) { // (2)!\n            val facing = getPropertyValueOrThrow(DefaultBlockStateProperties.FACING) // (3)!\n            getModel(/* path */) // (4)!\n        }\n    }\n\n}\n</code></pre> <ol> <li>The block will have block states for all horizontal directions.</li> <li>This will be run for every block state.</li> <li>You can retrieve the value of a <code>BlockStateProperty</code> and select the model accordingly.</li> <li>Loads and returns the model under the given path.</li> </ol> <p>Of course, you won't need to manually create rotated models for your blocks. Instead, you can use the <code>ModelBuilder</code> obtained by <code>getModel(/*...*/)</code> (or <code>defaultModel</code>) in the <code>selectModel</code> scope and use that to rotate the model:</p> <pre><code>@Init(stage = InitStage.PRE_PACK)\nobject Blocks {\n\n    val EXAMPLE_BLOCK = ExampleAddon.block(\"example_block\") {\n        stateProperties(DefaultScopedBlockStateProperties.FACING_HORIZONTAL)\n\n        models {\n            stateBacked(BackingStateCategory.MUSHROOM_BLOCK)\n            selectModel { defaultModel.rotated() } // (1)!\n        }\n    }\n\n}\n</code></pre> <ol> <li>Automatically rotates your model based on <code>DefaultBlockStateProperties.FACING</code> or <code>DefaultBlockStateProperties.AXIS</code>.    You can also rotate manually, or do other transformations such as scaling, translating or combining models using    the <code>ModelBuilder</code>.</li> </ol> <p>Refer to the KDocs for a full list of available functions and properties.</p>"},{"location":"addon/blocks/creating-blocks/#creating-an-item-for-the-block","title":"Creating an Item for the Block","text":"<p>To create an item for your block, simply reference your block while registering the item:</p> <pre><code>@Init(stage = InitStage.PRE_PACK)\nobject Items {\n\n    val EXAMPLE_BLOCK = ExampleAddon.item(Blocks.EXAMPLE_BLOCK) {}\n\n}\n</code></pre>"},{"location":"addon/blocks/creating-blocks/#placing-destroying-nova-blocks","title":"Placing / Destroying Nova Blocks","text":"<p>To place or break custom blocks, you'll need a Context. Then, use <code>BlockUtils.placeBlock</code>, <code>BlockUtils.breakBlock</code> or <code>BlockUtils.updateBlockState</code>.</p> <p>There are extension properties available on <code>org.bukkit.Block</code> to get the <code>novaBlockState</code> or <code>novaBlock</code>.</p> <p>Direct world access via WorldDataManager</p> <p>You can also directly read / write to Nova's world data storage via <code>WorldDataManager</code>. However, note that setting a    block state via <code>WorldDataManager</code> will not perform any other logic such as tile-entity creation, calling   block behaviors, placing the backing state, or spawning the associated display entity.</p>"},{"location":"addon/fonts/actionbar/","title":"Action Bar Overlay","text":"<p>Overlays follow the same concept of using fonts to render images as GUI Textures, but are a bit more difficult to implement for addon developers, as you need to create the font file yourself.</p> <p>Font files are stored under <code>assets/fonts/</code> and have this format. You might also want to take a look at our font for the jetpack energy bar overlay.</p>"},{"location":"addon/fonts/actionbar/#actionbaroverlay","title":"ActionBarOverlay","text":"<p>After creating your font, implement the <code>ActionbarOverlay</code> interface. There you'll need to provide the component to be displayed in the action bar. To improve performance, you can also override the <code>getWidth</code> function which should return the width of the overlay in pixels. Otherwise, this width will be calculated at runtime.</p> Example: JetpackOverlay <pre><code>class JetpackOverlay : ActionbarOverlay {\n\noverride var component: Component = getCurrentComponent()\n    private set\n\nvar percentage: Double = 0.0\n    set(value) {\n        require(value in 0.0..1.0)\n        if (field == value)\n            return\n\n        field = value\n        component = getCurrentComponent()\n    }\n\nprivate fun getCurrentComponent(): Component {\n    val stage = (percentage * 38).toInt()\n\n    return Component.text()\n        .move(95) // moves the cursor position to the right by 95 pixels\n        .append(Component.text(('\\uF000'.code + stage).toChar().toString()).font(\"jetpacks:energy_bar\"))\n        .build()\n}\n</code></pre> <p>The overlay can now be displayed through the <code>ActionbarOverlayManager</code>:</p> <pre><code>ActionbarOverlayManager.registerOverlay(player, overlay)\n</code></pre> <p>Info</p> <p>Nova intercepts action bar packets and appends the action bar overlay to it. This means that normal action bar text can still be displayed, even if one or more action bar overlays are active.</p>"},{"location":"addon/fonts/bossbar/","title":"Boss Bar Overlay","text":"<p>Boss bar overlays are generally similar to action bar overlays, with the difference that they're rendered at boss bar position, can be moved vertically, and have a built-in way to dynamically position themselves above/below other overlays.</p>"},{"location":"addon/fonts/bossbar/#vertically-moved-fonts","title":"Vertically Moved Fonts","text":"<p>Boss bars in Minecraft generally have a fixed spacing of 19px. However, we need to be able to move overlays at 1px increments, which is why Nova gets rid of all vanilla boss bars and re-renders them using custom characters that have a boss bar texture. Additionally, we also create what we call \"vertically moved fonts\", which are variations of a font that are moved on the vertical axis.</p> <p>When creating a custom font for a boss bar overlay, you will also need to create those vertically moved font variations.</p> <p>Vertically moved fonts for <code>minecraft:default</code> will be automatically generated if the boss bar overlay is enabled in main config.</p> <p>After you've created your vertically moved fonts, you can start implementing the boss bar overlay in code. For that, you'll need to create a <code>BossBarOverlayCompound</code> consisting of at least one <code>BossBarOverlay</code>.</p>"},{"location":"addon/fonts/bossbar/#bossbaroverlay","title":"BossBarOverlay","text":"<p>Each <code>BossBarOverlay</code> defines a <code>Component</code> to be rendered at one specific vertical position.</p> property description offset The vertical offset of this <code>BossBarOverlay</code> inside the <code>BossBarOverlayCompound</code>. centerX The x coordinate at which the component should be centered at, with 0 being the middle of the screen. Can be null if no centering logic should be applied. component The component to display. <p>Similar to action bar overlays, you can override the <code>getWidth</code> and also the <code>getVerticalRange</code> methods to improve performance.</p>"},{"location":"addon/fonts/bossbar/#bossbaroverlaycompound","title":"BossBarOverlayCompound","text":"<p>A <code>BossBarOverlayCompound</code> is a collection of <code>BossBarOverlays</code>. The overlays in this compound will never be separated.</p> property description overlays The list of <code>BossBarOverlays</code> that are part of the <code>BossBarOverlayCompound</code>. positioning The <code>BarPositioning</code> that specifies at which position the <code>BossBarOverlayCompound</code> should be rendered. hasChanged Whether any component of the included overlays have been changed and should be re-rendered. If you set this boolean to true, the <code>BossBarOverlayManager</code> will update your overlay and set the boolean to false again. <p>The <code>BossBarOverlayCompound</code> can then be registered: <pre><code>BossBarOverlayManager.registerOverlay(player, compound)\nBossBarOverlayManager.unregisterOverlay(player, compound)\n</code></pre></p>"},{"location":"addon/fonts/bossbar/#barpositioning","title":"BarPositioning","text":"<p>The <code>BarPositioning</code> determines where your overlay should be rendered. You can choose between <code>BarPositioning.Fixed</code> and <code>BarPositioning.Dynamic</code>, where the latter will automatically move your overlay to prevent it from overlapping with other overlays or vanilla boss bars. Both types of positioning also allow you to define <code>BarMatchers</code>, which are used to determine whether your overlay should be placed above or below another overlay. <code>BarMatchers</code> can be both hard-coded or deserialized from a yaml configuration using <code>ConfigurationSection.getDeserialized&lt;BarMatcher&gt;(path)</code>. See Configuration - WAILA Positioning for a more detailed explanation.</p>"},{"location":"addon/fonts/fonts/","title":"Fonts","text":""},{"location":"addon/fonts/fonts/#importance-of-custom-fonts","title":"Importance of custom fonts","text":"<p>Custom fonts play an important role in server-side modding, because they allow you to display your textures basically anywhere on the screen. They allow you to create custom hud elements, gui textures, and much more.</p>"},{"location":"addon/fonts/fonts/#font-format","title":"Font format","text":"<p>To properly use features based on custom fonts, it's important to understand fonts in Minecraft work.  </p> <p>In vanilla Minecraft, you can create custom fonts with resource packs. Those fonts are json files located under <code>assets/&lt;namespace&gt;/font/</code> with the following structure:</p> assets/namespace/font/my_font.json<pre><code>{\n  \"providers\": [ // (1)!\n    {\n      \"type\": \"\" // (2)!\n      ... // (3)!\n    },\n    ... // (4)!\n  ]\n}\n</code></pre> <ol> <li>An array of providers. The amount of font providers a font can have is unlimited.    A provider itself can provide as many characters as you want it to.</li> <li>The type of the font provider. Possible options: <code>bitmap</code>, <code>unihex</code>, <code>ttf</code>, <code>space</code> (see below)</li> <li>Additional keys to configure the font provider</li> <li>Additional providers</li> </ol> Provider type Description Importance Usage (in Nova and addons) <code>bitmap</code> Characters are read from a <code>png</code> file. High Allows you to create custom hud elements and gui textures like described above. <code>space</code> Defines space widths. High Allows negative spaces<sup>1</sup> and sub-gui-scale movements<sup>2</sup> of characters. <code>unihex</code> Characters are stored in a text-based format, where each line is a hexadecimal string representing a binary black and white texture. Low Unimportant for addon developers <code>ttf</code> Reads characters from a <code>ttf</code> or <code>otf</code> file. Unsupported<sup>3</sup> None <p>More information about the font file format can be found on the Minecraft wiki.</p>"},{"location":"addon/fonts/fonts/#custom-fonts-in-nova","title":"Custom fonts in Nova","text":""},{"location":"addon/fonts/fonts/#creating-custom-fonts","title":"Creating custom fonts","text":"<p>In Nova, you can either:</p> <ul> <li>Add font files to your asset pack under <code>fonts/</code> using the vanilla font format.</li> <li>Generate font files during resource pack generation using FontContent.</li> </ul>"},{"location":"addon/fonts/fonts/#using-custom-fonts","title":"Using custom fonts","text":"<p>Using adventure components, you can easily change the font of any text:</p> <pre><code>Component.text(\"A\").font(\"my_font\")\n</code></pre>"},{"location":"addon/fonts/fonts/#horizontal-movement","title":"Horizontal movement","text":"<p>Nova also has built-in (negative) spaces in a custom font, so you will not have to implement those yourself. To generate a movement string, you can use <code>MoveCharacters.getMovingString(distance)</code> or directly get a  component using <code>MoveCharacters.getMovingComponent(distance)</code>.</p> <p>To calculate the width of a component, use <code>CharSizes.calculateComponentWidth(component, lang)</code> or get even more information using <code>CharSizes.calculateComponentSize(component, lang)</code>.</p> <p>Nova also provides some useful extension functions to make all of this easier:</p> Extension function Description <code>ComponentBuilder.move(distance)</code> Appends move characters of the given distance. <code>ComponentBuilder.moveToStart(lang)</code> Appends move characters that match the negative width of the current text, essentially moving the \"cursor\" back to where it started. <code>ComponentBuilder.moveToCenter(lang)</code> Appends move characters that match half of the negative width of the current text, essentially moving the \"cursor\" to the middle of the text. <code>ComponentBuilder.moveTo(afterStart, lang)</code> Appends move characters that match the negative width of the current text plus the <code>afterStart</code> value, essentially moving the \"cursor\" by the given distance after the point where it originally started."},{"location":"addon/fonts/fonts/#vertical-movement","title":"Vertical movement","text":"<p>Moving text along the vertical axis is a bit more difficult to achieve. Currently, the only way to do this in Nova is to generate vertically moved variations of a font. To do that, request those variations during the resource pack build process using MovedFontContent.</p> <pre><code>builder.getHolder&lt;MovedFontContent&gt;().requestMovedFonts(ResourcePath(\"namespace\", \"name\"), 0..19)\n</code></pre> <p>During runtime, you can then create a vertically moved component using <code>MovedFonts.moveVertically(component, distance)</code>.</p> <p>How are vertically moved fonts generated?</p> <p>The <code>bitmap</code> provider has an <code>ascent</code> property. The generated variations will add to this property, so a font that is moved down by 1px will add -1 to the existing ascent value. The new fonts are named <code>&lt;original_namespace&gt;/&lt;original_name&gt;/&lt;offset&gt;</code>, so for example <code>minecraft:default/1</code> or <code>example_addon:my_font/2</code>. Unihex providers do not have such a property, so they're converted to bitmap providers first.</p> <ol> <li> <p>Negative spaces are required to move the \"cursor\" to the left before/after drawing a custom character. They allow you to draw over previous characters, which makes it possible to have, for example, a background behind text or generally more complex hud elements. They're also often required to move the texture you're trying to draw to its correct position.\u00a0\u21a9</p> </li> <li> <p>Minecraft fonts are pixel-based. On gui-scale 1, one pixel in your character corresponds to one pixel rendered on the screen. On higher gui scales, the characters are scaled accordingly. (gui-scale 2: 2x2, gui-scale 3: 3x3, etc.) Obviously, spaces need to scale accordingly. However, this creates the issue that one could only move textures at 2px intervals on gui-scale 2, or 3px intervals on gui-scale 3, etc. But with the <code>space</code> provider, it is possible to define spaces as floats like <code>0.5</code> or <code>0.25</code>, which allows a more precise positioning of your custom textures.\u00a0\u21a9</p> </li> <li> <p>This provider is not used by Mojang and is not supported by any of Nova's features such as char size calculation, bitmap font generation, or in-code generated fonts.\u00a0\u21a9</p> </li> </ol>"},{"location":"addon/fonts/guitextures/","title":"GUI Textures","text":""},{"location":"addon/fonts/guitextures/#creating-a-guitexture","title":"Creating a GuiTexture","text":"<p>Register your gui texture using initialization:</p> <pre><code>@Init(stage = InitStage.PRE_PACK) // (1)!\nobject GuiTextures {\n\n    val EXAMPLE = ExampleAddon.guiTexture(\"example\") {\n         alignment(/*...*/) // (2)!\n         path(\"gui/example\")\n    }\n\n}\n</code></pre> <ol> <li>Nova will load this class during addon initialization, causing your gui textures to be registered.</li> <li>The alignment of the texture. Depending on the inventory that your gui texture is intended for, and    how the texture is intended to be displayed (left-aligned, centered, etc.) you can set the alignment accordingly.</li> </ol>"},{"location":"addon/fonts/guitextures/#using-guitextures","title":"Using GuiTextures","text":"<p>In order to use a gui texture, call the <code>getTitle</code> method on it, and use the resulting title for a Gui. If you're making a tile-entity menu, the <code>GuiTexture</code> can be set directly in its constructor.</p>"},{"location":"addon/items/creating-items/","title":"Creating Items","text":""},{"location":"addon/items/creating-items/#creating-an-item-registry","title":"Creating an Item Registry","text":"<p>First, create an empty singleton object and annotate it like this: <pre><code>@Init(stage = InitStage.PRE_PACK) // (1)! \nobject Items {\n\n    // (2)!\n\n}\n</code></pre></p> <ol> <li>Nova will load this class during addon initialization, causing your items to be registered.</li> <li>Register your items here</li> </ol>"},{"location":"addon/items/creating-items/#creating-items","title":"Creating Items","text":"<p>You can register a really simple item like this:</p> <pre><code>@Init(stage = InitStage.PRE_PACK)\nobject Items {\n\n   val EXAMPLE_ITEM = ExampleAddon.registerItem(\"example_item\", /* Item Behaviors */)\n\n}\n</code></pre> <p>This item will default to the model under <code>models/item/example_item.json</code> or, if no such model exists, create a basic item model with the texture under <code>textures/item/example_item.png</code>.</p>"},{"location":"addon/items/creating-items/#item-model-definitions","title":"Item Model Definitions","text":"<p>Item Model Definitions - Minecraft Wiki</p> <p>Item Model Defintions are a 1.21.4 feature. You may be interested in the Minecraft wiki page on this topic.</p> <p>Item model definitions allow defining rules that are then used by the client to select a model for an item at runtime. These rules are constantly evaluated by the client, so the item model can change very dynamically based on the player's actions, such as holding a keybind, or the state of the item, such as its use duration.</p> <p>Nova offers a DSL builder for creating item model definitions:</p> <pre><code>@Init(stage = InitStage.PRE_PACK)\nobject Items {\n\n   val EXAMPLE_ITEM = ExampleAddon.item(\"example_item\") {\n      modelDefinition {\n          model = /* ... */\n      }\n   }\n\n}\n</code></pre> <p>In this scope, you'll need to set the \"root\" model of the item. Your options here are:</p> <ul> <li><code>model</code>: A normal model, allows defining tints. You may want to use the shortcut function <code>buildModel</code> instead.</li> <li><code>composite</code>: A composite model, which allows rendering multiple models in the same space.</li> <li><code>condition</code>: A model is selected based on a condition that is either <code>true</code> or <code>false</code>.</li> <li><code>select</code>: A model is selected based on a value, such as an enum or a string.</li> <li><code>rangeDispatch</code>: A model is selected based on a number. If there is no exact match, the closest lower value is used.</li> <li><code>empty</code>: An empty model</li> <li>Various \"special\" models, that use hardcoded rendering logic.</li> </ul> <p>There are also some shortcut functions available for generating <code>rangeDispatch</code> models: <code>numberedModels</code>, <code>rangedModels</code></p> <p>Models are nested, so you can have, for example, a <code>select</code> model that chooses another <code>select</code> model.</p> <p>Refer to the KDocs for a full list of available functions and properties.</p>"},{"location":"addon/items/creating-items/#model","title":"Model","text":"<p>This is the most basic model type. You will need this type as a leaf of all your models, as it is the only type that directly links to a model file. Additionally, this type also allows you to define tints.</p> modelDefinition { }<pre><code>model = model {\n    tintSource[0] = TintSource.CustomModelData(Color.WHITE, 0) // (1)!\n    model = { getModel(\"item/my_item\") } // (2)!\n}\n</code></pre> <ol> <li>This sets <code>tintindex</code> 0 to read the color value 0 from the <code>minecraft:custom_model_data</code> component.</li> <li>This sets the model to <code>item/my_item</code>. In the model selector scope, you have additional functionality available    that can be used to generate models at runtime.</li> </ol>"},{"location":"addon/items/creating-items/#composite","title":"Composite","text":"<p>This model type allows you to render multiple models in the same space.</p> modelDefinition { }<pre><code>model = composite {\n  models += /* ... */ // (1)!\n}\n</code></pre> <ol> <li>Adds a model to the composite. You can either create a model like for the root model, or define a model selector    lambda directly.</li> </ol>"},{"location":"addon/items/creating-items/#condition","title":"Condition","text":"<p>This model type allows you to choose a model based on a condition.</p> modelDefinition { }<pre><code>model = condition(ConditionItemModelProperty.KeybindDown(Keybind.LEFT)) { // (1)!\n    onTrue = buildModel { getModel(\"item/left\") } // (2)!\n    onFalse = buildModel { getModel(\"item/not_left\") }\n}\n</code></pre> <ol> <li>This condition checks if the keybind <code>LEFT</code> is pressed. If it is, the model <code>item/left</code> is used, otherwise <code>item/not_left</code>.</li> <li><code>buildModel { /* ... */ }</code> is a shortcut for <code>model { model = { /* ... */ } }</code>.</li> </ol>"},{"location":"addon/items/creating-items/#select","title":"Select","text":"<p>This model type allows you to choose a model based on a value.</p> modelDefinition { }<pre><code>model = select(SelectItemModelProperty.ChargedType) { // (1)!\n    case[ChargedType.NONE] = { getModel(\"item/crossbow\")}\n    case[ChargedType.ARROW] = { getModel(\"item/crossbow_arrow\")}\n    case[ChargedType.ROCKET] = composite { /* ... */ }\n}\n</code></pre> <ol> <li>Selects over the value of the <code>minecraft:charged_projectile</code>.</li> </ol>"},{"location":"addon/items/creating-items/#range-dispatch","title":"Range Dispatch","text":"modelDefinition { }<pre><code>model = rangeDispatch(RangeDispatchItemModelProperty.Cooldown) { // (1)!\n    entry[0] = { getModel(\"item/my_item_ready\") }\n    entry[0.5] = { getModel(\"item/my_item_half_ready\") }\n    entry[1] = { getModel(\"item/my_item_not_ready\") }\n}\n</code></pre> <ol> <li>Selects a model based on the value of the <code>minecraft:cooldown</code> component. You can add as many    intermediate models as you want. The client will always render the one with the closest lower value.</li> </ol>"},{"location":"addon/items/creating-items/#special","title":"Special","text":"<p>There are various special model types available. These use hardcoded rendering logic and are not achievable through regular model files.</p> <p>The following special models exist: <code>bedSpecialModel</code>, <code>bannerSpecialModel</code>, <code>conduitSpecialModel</code>, <code>chestSpecialModel</code>, <code>decoratedPotSpecialModel</code> <code>headSpecialModel</code>, <code>shulkerBoxSpecialModel</code>, <code>shieldSpecialModel</code>, <code>standingSignSpecialModel</code>, <code>tridentSpecialModel</code>, <code>hangingSignSpecialModel</code></p> modelDefinition { }<pre><code>model = chestSpecialModel {\n    texture = ResourcePath.of(ResourceType.ChestTexture, \"my_addon:iron_chest\")\n    openness = 0.5\n}\n</code></pre>"},{"location":"addon/items/creating-items/#novaitem","title":"NovaItem","text":""},{"location":"addon/items/creating-items/#getting-an-itemstack","title":"Getting an ItemStack","text":"<p>To get an ItemStack from a <code>NovaItem</code>, use <code>NovaItem.createItemStack(amount)</code>.</p>"},{"location":"addon/items/creating-items/#getting-itembehaviors","title":"Getting ItemBehaviors","text":"<p>Using the function <code>hasItemBehavior&lt;T&gt;()</code> and <code>getItemBehavior&lt;T&gt;()</code> you can check for and get an ItemBehavior of a certain type.</p>"},{"location":"addon/items/creating-items/#client-side-items","title":"Client-side items","text":"<p>Using <code>NovaItem.clientsideProvider</code> and <code>NovaItem.createClientsideItemBuilder()</code> you can obtain client-side items.</p> <p>To understand the difference between a normal (server-side) and a client-side item, you first need to understand how custom items are handled in Nova. In order to be extremely flexible when it comes to changing custom model data, the underlying vanilla item type, the lore format of the item or its display name, Nova's ItemStacks do not store this information at all. All of these values are actually only applied on packet level, which can be observed by running the command <code>/data get entity @p SelectedItem</code> while holding an item from Nova: its item type will always be <code>shulker_shell</code> and it won't have any custom model data, display name or lore, even though it has one for your game.</p> <p>Coming back to client-side item builders and providers: These are wrappers for the ItemStacks that the client actually sees. They should only be used in cases where the ItemStack isn't actually stored anywhere, for example as a button in a GUI or for <code>FakeEntities</code>.</p> <p>Generally, you should use <code>NovaItem.clientsideProvider</code> and <code>NovaItem.createClientsideItemBuilder()</code> when working with GUIs and <code>NovaItem.createItemStack(amount)</code> if you need an item to give to a player.</p>"},{"location":"addon/items/enchantments/","title":"Enchantments","text":""},{"location":"addon/items/enchantments/#enchantable-items","title":"Enchantable Items","text":"<p>To make a <code>NovaItem</code> enchantable, add the <code>Enchantable</code> behavior:</p> <pre><code>val EXAMPLE_ITEM = registerItem(\"example_item\", Enchantable())\n</code></pre> configs/example_item.yml<pre><code>enchantment_value: 10 # (1)!\nsupported_enchantments: # (2)!\n   - minecraft:sharpness\n   - minecraft:smite\n   - minecraft:bane_of_arthropods\n   - minecraft:knockback\n   - minecraft:fire_aspect\n   - minecraft:looting\n   - minecraft:sweeping_edge\n   - minecraft:unbreaking\n   - minecraft:mending\n</code></pre> <ol> <li>The enchantment value of the item. This value defines how enchantable an item is.    A higher enchantment value means more secondary and higher-level enchantments.    Vanilla enchantment values: wood: <code>15</code>, stone: <code>5</code>, iron: <code>14</code>, diamond: <code>10</code>, gold: <code>22</code>, netherite: <code>15</code></li> <li>The supported enchantments of this item. Since <code>primary_enchantments</code> is not defined, these are also the primary    enchantments of the item.</li> </ol> <p><code>supported_enchantments</code> vs. <code>primary_enchantments</code></p> <p>Supported enchantments: The enchantments that can be applied to the item, i.e. via anvil or commands.   Primary enchantments: The enchantments that appear in the enchanting table.</p> <p>If you're defining <code>supported_enchantments</code> via the config, <code>primary_enchantments</code> will default to <code>supported_enchantments</code>.   Once you add <code>primary_enchantments</code> to the config, you'll need to add all enchantments from <code>supported_enchantments</code>   to <code>primary_enchantments</code>.</p>"},{"location":"addon/items/enchantments/#custom-enchantments","title":"Custom Enchantments","text":"<p>You can register a custom enchantment like this:</p> Enchantments.kt<pre><code>@Init(stage = InitStage.PRE_PACK) // (1)!\nobject Enchantments {\n\n    val EXAMPLE_ENCHANTMENT = ExampleAddon.enchantment(\"example_enchantment\") {\n        // ...\n    }\n\n}\n</code></pre> <p>Refer to the KDocs for list of available functions and properties.</p>"},{"location":"addon/items/equipment/","title":"Equipment","text":""},{"location":"addon/items/equipment/#creating-equipment","title":"Creating equipment","text":"<p>Custom equipment (armor) can be registered like this:</p> <pre><code>@Init(stage = InitStage.PRE_PACK) // (1)!\nobject Equipment {\n\n   val EXAMPLE = ExampleAddon.equipment(\"example\") {\n      humanoid  { // (2)!\n         layer { // (3)!\n            texture(\"example\") // (4)!\n            emissivityMap(\"example_emissivity_map\") // (5)!\n            dyeable(Color.WHITE) // (8)!\n         }\n      }\n\n      humanoidLeggings {\n         layer {\n            texture(\"example\") // (6)!\n            emissivityMap(\"example_emissivity_map\") // (7)!\n         }\n      }\n   }\n\n}\n</code></pre> <ol> <li>Nova will load this class during addon initialization, causing your armor to be registered.</li> <li>The type of equipment. You can also create equipment for horses, dogs, and more.</li> <li>You can layer multiple textures on top of each other. This layering is flat, there is no three-dimensional effect    like for the player skin.</li> <li>The path to the texture. This resolves the file under <code>textures/entity/equipment/humanoid/example.png</code></li> <li>(optional) The path to the emissivity map. This resolves the file under <code>textures/entity/equipment/humanoid/example_emissivity_map.png</code>    Black pixels are interpreted as not emissive, white pixels are interpreted as fully emissive.</li> <li>The path to the texture. This resolves the file under <code>textures/entity/equipment/humanoid/example.png</code></li> <li>(optional) The path to the emissivity map. This resolves the file under <code>textures/entity/equipment/humanoid/example_emissivity_map.png</code>    Black pixels are interpreted as not emissive, white pixels are interpreted as fully emissive.</li> <li>(optional) Makes this layer dyeable and uses <code>Color.WHITE</code> if no dye is applied.    Dyeable items also require the <code>Dyeable</code> item behavior.</li> </ol> <p>After creating the armor, you can apply it to items using the <code>Equippable</code> behavior:</p> <pre><code>val EXAMPLE_HELMET = registerItem(\"example_helmet\", Equippable(Armor.EXAMPLE, EquipmentSlot.HEAD))\n</code></pre>"},{"location":"addon/items/equipment/#animated-equipment","title":"Animated equipment","text":"<p>You can also create animated armor:</p> Equipment.kt<pre><code>val EXAMPLE = ExampleAddon.animatedEquipment(\"example\") {\n   humanoid  {\n      layer {\n          texture(5, InterpolationMode.NONE, \"frame_1\", \"frame_2\", \"frame_3\") // (1)!\n      }\n   }\n\n   /* ... */\n}\n</code></pre> <ol> <li>Creates a non-interpolated animation that switches through the three defined frames every 5 ticks.    Note that interpolation is achieved by pre-generating all interpolated frames, which may drastically    increase resource pack size.</li> </ol>"},{"location":"addon/items/equipment/#compatibility-with-client-side-rendering-mods","title":"Compatibility with client-side rendering mods","text":"<p>Emissive textures are implemented via a core shader and are not compatible with shader mods.</p>"},{"location":"addon/items/item-behaviors/","title":"Item Behaviors","text":"<p>In Nova, item logic is implemented via <code>ItemBehaviors</code>. There are some default behaviors available, but you can also create your own custom behaviors.</p>"},{"location":"addon/items/item-behaviors/#default-item-behaviors","title":"Default Item Behaviors","text":"<p>For a list of all available default item behaviors, refer to the KDocs.</p>"},{"location":"addon/items/item-behaviors/#custom-item-behaviors","title":"Custom Item Behaviors","text":"<p>You can create a custom item behavior by implementing the <code>ItemBehavior</code> interface.</p>"},{"location":"addon/items/item-behaviors/#base-data-components","title":"Base data components","text":"<p>The <code>ItemBehavior</code> interface specifies a <code>baseDataComponents</code> property, which are the default data components of <code>NovaItems</code> with that behavior.</p> <p>Example usage: <pre><code>override val baseDataComponents: Provider&lt;DataComponentMap&gt; = buildDataComponentMapProvider {\n    // item has max damage of 500\n    this[DataComponentTypes.MAX_DAMAGE] = 500\n\n    // item has a config-reloadable enchantable level taken from the \"my_level\" config entry\n    this[DataComponentTypes.ENCHANTABLE] = Items.EXAMPLE_ITEM.config.entry&lt;Int&gt;(\"my_level\")\n        .map { level -&gt; Enchantable.enchantable(level) }\n}\n</code></pre></p>"},{"location":"addon/items/item-behaviors/#vanilla-material-properties","title":"Vanilla material properties","text":"<p>Some functionality can not yet be achieved by using data components, as it is still bound to the vanilla item type. For such cases, you can specify VanillaMaterialProperties which will change the client-side item type.</p>"},{"location":"addon/items/item-behaviors/#client-side-item-stack","title":"Client-side item stack","text":"<p>To modify the client-side item, you can override <code>modifyClientSideStack</code>. The data of the client-side stack will not be stored in the world and is only intended for display purposes. Furthermore, the components of the client-side stack will not affect the tooltip, e.g. adding the <code>DAMAGE</code> component will not cause the damage value to be shown in the advanced tooltip. (Assuming advanced tooltips are handled by Nova via <code>/nova advancedTooltips</code>).</p> <p>Inspecting client-side item data</p> <p>You can inspect the client-side version of a server-side item stack by creating a client-side copy via <code>/nova debug giveClientsideStack</code>, then run <code>/paper dumpitem</code> to print the item data in chat.</p>"},{"location":"addon/items/item-behaviors/#itembehaviorholder-and-itembehaviorfactory","title":"ItemBehaviorHolder and ItemBehaviorFactory","text":"<p><code>ItemBehaviorHolder</code> is a sealed interface with two implementations: <code>ItemBehavior</code> and <code>ItemBehaviorFactory</code>, where <code>ItemBehaviorFactory</code> creates <code>ItemBehavior</code> instances based on a <code>NovaItem</code> instance. This allows you to create factories for your <code>ItemBehaviors</code> that read from the item's config file.  </p> Example custom ItemBehavior with ItemBehaviorFactory<pre><code>class MyBehavior(value: Provider&lt;Int&gt;) : ItemBehavior {\n\n   private val value by value // (1)!\n\n   companion object : ItemBehaviorFactory&lt;MyBehavior&gt; {\n\n      override fun create(item: NovaItem): MyBehavior {\n         return MyBehavior(item.config.entry&lt;Int&gt;(\"value\"))\n      }\n\n   }\n\n}\n</code></pre> <ol> <li>Delegating to the obtained provider makes this property config-reloadable without any additional code.</li> </ol> <p>Now, you could, for example, assign the same <code>ItemBehaviorFactory</code> to multiple items, while still accessing different configs.</p> <pre><code>@Init(stage = InitStage.PRE_PACK) // (1)!\nobject Items {\n\n    val EXAMPLE_ITEM_1 = ExampleAddon.registerItem(\"example_1\", MyBehavior) // configs/example_1.yml\n    val EXAMPLE_ITEM_2 = ExampleAddon.registerItem(\"example_2\", MyBehavior) // configs/example_2.yml\n    val EXAMPLE_ITEM_3 = ExampleAddon.registerItem(\"example_3\", MyBehavior) // configs/example_3.yml\n\n}\n</code></pre> <ol> <li>Nova will load this class during addon initialization, causing the item fields to be initialized and your items to be registered.</li> </ol>"},{"location":"addon/items/item-behaviors/#item-data","title":"Item Data","text":"<p>Data for Nova's ItemStacks can be stored using CBF via the extension functions  <code>ItemStack.storeData</code> and <code>ItemStack.retrieveData</code>. Default data for this can be added into an ItemBehavior's <code>defaultCompound</code>.</p> <p>Alternatively, it is also possible to store data in Bukkit's persistent data container.</p>"},{"location":"addon/items/recipes/","title":"Recipes","text":""},{"location":"addon/items/recipes/#adding-recipes-to-your-addon","title":"Adding recipes to your addon","text":"<p>Recipes files are placed under <code>recipes/&lt;namespace&gt;/type</code>, where the <code>namespace</code> is the namespace of the addon that registered this recipe type (<code>minecraft</code> for Minecraft recipe types) and <code>type</code> the name of the recipe type. For more information about the recipe format and default recipe types, read the admin page on it.</p>"},{"location":"addon/items/recipes/#creating-a-custom-recipe-type","title":"Creating a custom Recipe Type","text":"<p>Recipe types are registered over the <code>RecipeTypeRegistry</code>. All the following values are required to create a new <code>RecipeType</code>:</p> Name Type Usage <code>dirName</code> <code>String</code> The name for the directory of your recipe type. <code>recipeClass</code> <code>KClass&lt;T&gt;</code> The class of your recipe type, must be a subclass of <code>NovaRecipe</code>. <code>group</code> <code>RecipeGroup&lt;T&gt;?</code> The recipe group that displays the recipe in the recipe explorer gui. <code>deserializer</code> <code>RecipeDeserializer&lt;T&gt;?</code> The deserializer that deserializes the recipe files to an instance of the previously specified <code>recipeClass</code>. <p>Creating a custom Recipe Type</p> Recipe ClassRecipe DeserializerRecipe Group <p>Every recipe that is created also creates a new instance of the <code>recipeClass</code>. That object then contains all the information about the recipe (e.g. Input, Output, Time, etc.).</p> <p>The following example is the <code>PulverizerRecipe</code> from the Machines addon: PulverizerRecipe<pre><code>class PulverizerRecipe(\n    key: NamespacedKey,\n    input: RecipeChoice,\n    result: ItemStack,\n    time: Int,\n) : ConversionNovaRecipe(key, input, result, time) {\n    override val type = RecipeTypes.PULVERIZER\n}\n</code></pre> Since a Pulverizer just converts one input item to another output item, I could use the pre-existing <code>ConversionNovaRecipe</code>. Depending on your recipe type, you might need to directly inherit from <code>NovaRecipe</code> though.</p> <p>The recipe deserializer deserializes the recipe file to an instance of the <code>recipeClass</code>.</p> <p>For the <code>PulverizerRecipe</code> from Machines, the recipe deserializer is actually quite easy, as you can just extend the already existing <code>ConversionRecipeDeserializer</code>: PulverizerRecipeDeserializer<pre><code>object PulverizerRecipeDeserializer : ConversionRecipeDeserializer&lt;PulverizerRecipe&gt;() {\n    override fun createRecipe(json: JsonObject, key: NamespacedKey, input: RecipeChoice, result: ItemStack, time: Int) =\n        PulverizerRecipe(key, input, result, time)\n}\n</code></pre></p> <p>However, depending on you recipe type you might need to do some more work. The following deserializer is used for the fluid infuser recipe: FluidInfuserRecipeDeserializer<pre><code>object FluidInfuserRecipeDeserializer : RecipeDeserializer&lt;FluidInfuserRecipe&gt; {\n\n    override fun deserialize(json: JsonObject, file: File): FluidInfuserRecipe {\n        val mode = json.getDeserialized&lt;FluidInfuserRecipe.InfuserMode&gt;(\"mode\")!!\n        val fluidType = json.getDeserialized&lt;FluidType&gt;(\"fluid_type\")!!\n        val fluidAmount = json.getLong(\"fluid_amount\")!!\n        val input = parseRecipeChoice(json.get(\"input\"))\n        val time = json.getInt(\"time\")!!\n        val result = ItemUtils.getItemBuilder(json.getString(\"result\")!!).get()\n\n        return FluidInfuserRecipe(getRecipeKey(file), mode, fluidType, fluidAmount, input, result, time)\n    }\n\n}\n</code></pre></p> <p>Info</p> <p>Make sure to always use the <code>parseRecipeChoice(JsonElement)</code>, <code>ItemUtils.getItemBuilder(String)</code> and<code>getRecipeKey(File)</code> utility methods instead of using your own logic.</p> <p>The recipe group is only used for the recipe explorer GUI, so your recipes will already work without it. However, it is still required to create a recipe group.</p> <p>As always, it is very easy to create a recipe group for conversion recipes: PulverizingRecipeGroup<pre><code>object PulverizingRecipeGroup : ConversionRecipeGroup&lt;PulverizerRecipe&gt;() {\n    override val priority = 4 // (1)!\n    override val icon = Items.PULVERIZER.model.clientsideProvider // (2)!\n    override val texture = GuiTextures.RECIPE_PULVERIZER // (3)!\n}\n</code></pre></p> <ol> <li>The priority defines where in the recipe explorer your recipe type is going to be. (Lower value -&gt; left | Higher value -&gt; right)</li> <li>The icon displayed for your recipe type.</li> <li>The GUI Texture used when displaying your recipe type.</li> </ol> <p>However, if your recipe is not a <code>ConversionNovaRecipe</code>, your recipe group might be a bit more work: (The resulting GUI needs to be in the dimensions <code>9x3</code>)</p> FluidInfuserRecipeGroup<pre><code>object FluidInfuserRecipeGroup : RecipeGroup&lt;FluidInfuserRecipe&gt;() {\n\n    override val texture = GuiTextures.RECIPE_FLUID_INFUSER\n    override val icon = Items.FLUID_INFUSER.model.clientsideProvider\n    override val priority = 6\n\n    override fun createGui(recipe: FluidInfuserRecipe): Gui {\n        val progressItem: ItemBuilder\n        val translate: String\n        if (recipe.mode == FluidInfuserRecipe.InfuserMode.INSERT) {\n            progressItem = GuiItems.TP_FLUID_PROGRESS_LEFT_RIGHT.model.createClientsideItemBuilder()\n            translate = \"menu.machines.recipe.insert_fluid\"\n        } else {\n            progressItem = GuiItems.TP_FLUID_PROGRESS_RIGHT_LEFT.model.createClientsideItemBuilder()\n            translate = \"menu.machines.recipe.extract_fluid\"\n        }\n\n        progressItem.setDisplayName(Component.translatable(\n            translate,\n            Component.text(recipe.fluidAmount),\n            Component.translatable(recipe.fluidType.localizedName)\n        ))\n\n        return Gui.builder()\n            .setStructure(\n                \". f . t . . . . .\",\n                \". f p i . . . r .\",\n                \". f . . . . . . .\")\n            .addIngredient('i', createRecipeChoiceItem(recipe.input)) // (1)!\n            .addIngredient('r', createRecipeChoiceItem(listOf(recipe.result)))\n            .addIngredient('p', progressItem)\n            .addIngredient('f', StaticFluidBar(3, FLUID_CAPACITY, recipe.fluidType, recipe.fluidAmount))\n            .addIngredient('t', DefaultGuiItems.TP_STOPWATCH.model\n                .createClientsideItemBuilder()\n                .setDisplayName(Component.translatable(\"menu.nova.recipe.time\", Component.text(recipe.time / 20.0)))\n            ).build()\n    }\n\n}\n</code></pre> <ol> <li>This function creates an InvUI item for a <code>RecipeChoice</code>. When clicked, it shows you recipes / usages for that     item. It also automatically cycles through all possible input options if there is more than one.</li> </ol> <p> InvUI Documentation</p>"},{"location":"addon/items/tools/","title":"Tools","text":""},{"location":"addon/items/tools/#creating-tools","title":"Creating Tools","text":"<p>To create a custom tool, apply the <code>Tool</code> item behavior:</p> <pre><code>val EXAMPLE_ITEM = item(\"example_item\") {\n    behaviors(Tool())\n    maxStackSize(1)\n}\n</code></pre> configs/example_item.yml<pre><code># The tool level\ntool_level: minecraft:iron\n# The tool category\ntool_category: minecraft:sword\n# The block breaking speed\nbreak_speed: 1.5\n# The attack damage\nattack_damage: 6\n# The attack speed\nattack_speed: 2.0\n# The knockback bonus\nknockback_bonus: 1\n# If sweep attacks can be performed with this tool\ncan_sweep_attack: true\n# If this tool can break blocks in creative\ncan_break_blocks_in_creative: false\n</code></pre>"},{"location":"addon/items/tools/#tool-tiers","title":"Tool Tiers","text":"<p>Each tool tier maps to a numerical tool level. Those tool levels are then used to determine whether a tool tier is good enough to break a block.</p> Tool Type Level ToolTier (Nova) No Tool 0 <code>null</code> Wooden 0 <code>VanillaToolTiers.WOOD</code> Golden 0 <code>VanillaToolTiers.GOLD</code> Stone 1 <code>VanillaToolTiers.STONE</code> Iron 2 <code>VanillaToolTiers.IRON</code> Diamond 3 <code>VanillaToolTiers.DIAMOND</code> Netherite 3 <code>VanillaToolTiers.NETHERITE</code> <p>The numerical level values are assigned to the tool tiers in the <code>tool_levels.yml</code> config file:</p> tool_levels.yml<pre><code>wood: 0\ngold: 0\nstone: 1\niron: 2\ndiamond: 3\n</code></pre>"},{"location":"addon/items/tools/#registering-a-custom-tool-tier","title":"Registering a custom tool tier","text":"<p>You can register a custom tool tier like this:</p> <pre><code>@Init(stage = InitStage.PRE_PACK) // (1)!\nobject ToolTiers {\n\n    val EXAMPLE_TIER = ExampleAddon.registerToolTier(\"example_tier\")\n\n}\n</code></pre> <ol> <li>Nova will load this class during addon initialization, causing your tool levels to be registered.</li> </ol> <p>Then, assign a numerical tool level value to your registered tier in the <code>tool_levels.yml</code> config file:</p> tool_levels.yml<pre><code>example_tier: 4\n</code></pre> <p>The specified level of <code>4</code> would give your custom tool the ability to break all blocks that <code>DIAMOND</code> or <code>NETHERITE</code> tools could break and would also be able to break custom blocks that have a tool tier configured which resolves to a tool level of <code>4</code>. This way, your tool can even break blocks that require a custom tool tier of another addon, as long as your tool level is high enough.</p>"},{"location":"addon/items/tools/#tool-categories","title":"Tool Categories","text":"<p>Tool Categories define what type of tool your item is. They determine which blocks can be broken with which item. By default, there are six tool categories available:</p> Tool Type ToolCategory (Nova) Sword <code>VanillaToolCategories.SWORD</code> Pickaxe <code>VanillaToolCategories.PICKAXE</code> Axe <code>VanillaToolCategories.AXE</code> Shovel <code>VanillaToolCategories.SHOVEL</code> Hoe <code>VanillaToolCategories.HOE</code> Shears <code>VanillaToolCategories.SHEARS</code>"},{"location":"addon/items/tools/#registering-a-custom-tool-category","title":"Registering a custom tool category","text":"<p>You can register a custom tool category like this:</p> <pre><code>@Init(stage = InitStage.PRE_PACK) // (1)!\nobject ToolCategories {\n\n    val EXAMPLE_CATEGORY = ExampleAddon.registerToolCategory(\"example_category\")\n\n}\n</code></pre> <ol> <li>Nova will load this class during addon initialization, causing your tool categories to be registered.</li> </ol> <p>You can then use your new tool category in the <code>Breakable</code> behavior of your custom block.</p>"},{"location":"addon/migration-guide/0.11-0.12/","title":"Migration Guide 0.11 \u279d 0.12","text":""},{"location":"addon/migration-guide/0.11-0.12/#building","title":"Building","text":"<p>You will now need to set the kotlin compiler jvm target to <code>17</code>: build.gradle.kts<pre><code>tasks {\n    withType&lt;KotlinCompile&gt; {\n        kotlinOptions {\n            jvmTarget = \"17\"\n        }\n    }\n}\n</code></pre></p>"},{"location":"addon/migration-guide/0.11-0.12/#blockoptions","title":"BlockOptions","text":"<p>The <code>BlockOptions</code> constructor has changed. You will now need to set a list of <code>ToolCategories</code> and a <code>SoundGroup</code> instead of individual sounds. Refer to BlockOptions for more information.</p>"},{"location":"addon/migration-guide/0.11-0.12/#itembehavior","title":"ItemBehavior","text":"<p>All configurable <code>ItemBehaviors</code> have been reworked to load their data from configs using the new <code>MaterialOptions</code>. In most cases, you'll no longer need to instantiate them, but rather just use their companion object in the <code>NovaItem</code> constructor and configure them in the material-specific config file. Those properties can now be accessed in code using <code>&lt;someItemBehavior&gt;.options.&lt;someProperty&gt;</code> instead of <code>&lt;somItemBehavior&gt;.&lt;someProperty&gt;</code>. Refer to ItemBehaviors for more information.</p> <p>The <code>getLore</code> and <code>getName</code> methods have been replaced by <code>updatePacketItemData</code> which combines those two methods and adds more options.</p>"},{"location":"addon/migration-guide/0.11-0.12/#overlays","title":"Overlays","text":"<p>The <code>width</code> (BossBarOverlay, ActionBarOverlay) and <code>endY</code> (BossBarOverlay) were removed. You can still set them by overwriting the <code>getWidth</code> and <code>getEndY</code> methods, but this is no longer mandatory.</p>"},{"location":"addon/migration-guide/0.11-0.12/#misc","title":"Misc","text":"<ul> <li>Some NovaMaterialRegistry functions have been slightly changed to include the new <code>maxStackSize</code> parameter</li> <li>The <code>ToolUtils.damgeTool</code> functions have been moved to <code>DamageableUtils.damageItem</code></li> <li><code>SoundEffect</code> has been removed</li> <li><code>ValueReloadable</code> has been replaced by <code>Provider</code>.</li> <li>General refactoring: You might need to change some imports regarding item (behaviors), tools, etc.</li> </ul>"},{"location":"addon/migration-guide/0.12-0.13/","title":"Migration Guide 0.12 \u279d 0.13","text":""},{"location":"addon/migration-guide/0.12-0.13/#initialization","title":"Initialization","text":"<p>With 0.13, we bring a new way to initialize your registries and other classes. Simple annotate a class with  <code>@Init</code> and it will be loaded during the initialization phase. We recommend annotating your registry classes with it. More info</p>"},{"location":"addon/migration-guide/0.12-0.13/#the-end-of-novamaterial","title":"The end of <code>NovaMaterial</code>","text":"<p>We've decided to split <code>NovaMaterial</code> into <code>NovaItem</code> and <code>NovaBlock</code>. This allows for more flexibility, as you can now have a block that is not an item. Currently, the <code>materials.json</code> file is still used to register items and blocks, but this might be changed in the future.</p> <p>All extension functions / properties and the like have be renamed as you'd expect, i.e. <code>ItemStack.novaMaterial</code> is now <code>ItemStack.novaItem</code>, <code>Block.novaMaterial</code> is now <code>Block.novaBlock</code>, etc. Please let us know if we've missed anything.</p>"},{"location":"addon/migration-guide/0.12-0.13/#related-changes","title":"Related changes","text":"<ul> <li><code>NovaBlock</code> has been renamed to <code>BlockBehavior</code></li> <li>The <code>vanillaMaterialProperties</code> and <code>attributeModifiers</code> fields in <code>ItemBehavior</code> have been changed to getter functions</li> </ul>"},{"location":"addon/migration-guide/0.12-0.13/#registries","title":"Registries","text":"<p>We've switched all \"registry-like\" classes to Minecraft's built-in <code>Registry</code> system. We've also added builders for <code>NovaItem</code> and <code>NovaBlock</code> to make it easier to register them and to reduce future breaking changes when adding new properties.\u2122</p> <p>Therefore, we've also deprecated <code>NamespacedId</code> in favor of Mojang's <code>ResourceLocation</code>.</p> <p>Check out the registering items, registering blocks sections again.</p>"},{"location":"addon/migration-guide/0.12-0.13/#related-changes_1","title":"Related changes","text":"<ul> <li>With the new registry system, all default entries are now in separate classes. If they're related to vanilla minecraft,   the classes are prefixed with <code>Vanilla</code> (such as <code>VanillaToolCategories</code>, <code>VanillaToolTiers</code>, etc.). Nova's content is   prefixed with <code>Default</code> (such as <code>DefaultGuiMaterials</code>, <code>DefaultGuiTextures</code>, <code>DefaultItems</code>, etc.).</li> </ul>"},{"location":"addon/migration-guide/0.12-0.13/#itemstack-data","title":"ItemStack data","text":"<p>We've changed how data is stored in <code>ItemStacks</code>. Previously, this used Bukkit's <code>PersistentDataContainer</code>, but we've  changed this to use our custom <code>CBFCompoundTag</code>. Using <code>ItemStack.novaCompound</code>, you can now retrieve a <code>NamespacedCompound</code> to store data in. This should generally improve performance, as we won't need to (de)serialize data every time it's accessed, as the data is now cached in our new NBT tag type.</p> <p>You can still use the <code>ItemStack.retrieveData</code> and <code>ItemStack.storeData</code> extension functions. They will automatically move your data from the old <code>PersistentDataContainer</code> to the new <code>CBFCompoundTag</code>.</p>"},{"location":"addon/migration-guide/0.12-0.13/#tileentity-guis","title":"TileEntity GUIs","text":"<p>We've reworked how TileEntity GUIs work. There is no longer a lazy <code>gui</code> property in <code>TileEntity</code>, instead the GUI class is now retrieved using reflection and needs to be annotated with <code>@IndividualTileEntityGui</code> or <code>@GlobalTileEntityGui</code>. This makes TileEntity GUI's more flexible as you now have the option to have one GUI instance per player. More Info</p>"},{"location":"addon/migration-guide/0.12-0.13/#related-changes_2","title":"Related changes","text":"<ul> <li>If you've used the <code>VisualizeRegionItem</code>, you will now need to provide a <code>Player</code> for which the region should be visualized.   This also requires you to use an <code>IndividualTileEntityGui</code> instead of a <code>GlobalTileEntityGui</code>.</li> </ul>"},{"location":"addon/migration-guide/0.12-0.13/#tool-levels-tool-tiers","title":"Tool Levels -&gt; Tool Tiers","text":"<p><code>ToolLevel</code> is now <code>ToolTier</code> and allows for better customization of tool tiers that have the same mining level. More info</p>"},{"location":"addon/migration-guide/0.12-0.13/#switch-to-kyori-adventure-api-chat-components","title":"Switch to kyori adventure api (chat components)","text":"<p>We've completely switched to kyori adventure components. Boss- and action bar overlays now use the <code>Component</code> class instead of md_5's <code>Array&lt;out BaseComponent&gt;</code>. This also includes <code>CharSizes</code>, <code>MovedFonts</code>, <code>MoveCharacters</code>, <code>FontChar</code> and everything else. We've removed related utility functions for the bungee component api.</p>"},{"location":"addon/migration-guide/0.12-0.13/#reworked-bossbaroverlay","title":"Reworked BossBarOverlay","text":"<p>Boss bar overlays have been completely reworked. More info</p>"},{"location":"addon/migration-guide/0.12-0.13/#new-hitbox-system","title":"New Hitbox System","text":"<p>With Mojang adding interaction entities in 1.19.4, we've reworked our hitbox system to support them. More Info</p>"},{"location":"addon/migration-guide/0.12-0.13/#new-multimodel-system","title":"New MultiModel System","text":"<p>With Mojang adding display entities in 1.19.4, we've reworked our <code>Model</code> and <code>MultiModel</code> system to use those instead of armor stands. This feature is not yet documented here, but you can use <code>MovableMultiModel</code> and <code>FixedMultiModel</code> to deal with a larger amount of display entities that are supposed to display models from an item stack.</p>"},{"location":"addon/migration-guide/0.12-0.13/#removal-of-default-upgrade-types","title":"Removal of default upgrade types","text":"<p>If you've previously used any of the upgrade types that came with Nova, these have been moved to the <code>simple_upgrades</code> addon.</p> build.gradle.kts dependencies { }<pre><code>implementation(\"xyz.xenondevs:simple-upgrades:1.0-SNAPSHOT\")\n</code></pre> build.gradle.kts addon { }<pre><code>depend.add(\"simple_upgrades\") // (1)!\n</code></pre> <ol> <li>Create a hard dependency on the <code>simple_upgrades</code> addon!</li> </ol> <p>The SimpleUpgrades addon also provides several top level functions for creating holders so that you won't have to change much in your code. See: UpgradeFunctions.kt</p>"},{"location":"addon/migration-guide/0.12-0.13/#removal-of-nova-api-from-transitive-dependencies","title":"Removal of <code>nova-api</code> from transitive dependencies","text":"<p>We've seen that some people accidentally used classes from the <code>nova-api</code> module in their addons. This module is intended for third party plugin developers and provides a very limited api. To avoid confusion and accidental imports of the wrong class, we've removed <code>nova-api</code> from the transitive dependencies of the <code>nova</code> module.</p> <p>This means that you can no longer instantiate the Plugin API events (it's really just one). Instead, we now offer the <code>NovaEventFactory</code> class which provides methods to create and call those events, without the need of having the event class in your compile time classpath.</p> <p>Since <code>nova-api</code> is still in the runtime classpath, you can add the <code>nova-api</code> module back to your compile time dependencies if you really want to, but we generally discourage this.</p>"},{"location":"addon/migration-guide/0.12-0.13/#invui-10","title":"InvUI 1.0","text":"<p>InvUI has been updated to <code>1.0</code>. This includes a lot of api-breaking changes, so please check out the InvUI Docs.</p>"},{"location":"addon/migration-guide/0.12-0.13/#general-refactoring","title":"General Refactoring","text":"<ul> <li>A lot of classes have been moved around or renamed.</li> <li>We've moved a lot of utility stuff to the <code>xenondevs-commons</code> project (specifically: providers, json utilities,   collection utilities and some reflection utilities). This means that you might need to change some   imports of extension functions and the like. Using IntelliJ's \"Optimize Imports\" feature should fix most of these issues.</li> <li>We've renamed all classes containing <code>GUI</code> to their proper upper camel case name <code>Gui</code>.</li> <li>A lot of classes and functions that should've been internal have been made internal. This probably won't affect you.</li> </ul>"},{"location":"addon/migration-guide/0.13-0.14/","title":"Migration Guide 0.13 \u279d 0.14","text":"<p>This release is mainly just the update to 1.20, but there are a few changes that you should be aware of.</p>"},{"location":"addon/migration-guide/0.13-0.14/#removed-spigotresourceid-from-the-addon-description-and-the-related-gradle-task","title":"Removed <code>spigotResourceId</code> from the addon description and the related gradle task","text":"<p>Instead, you can now set a list of <code>ProjectDistributors</code> in code, which will be used to check for updates:</p> MyAddon.kt<pre><code>object MyAddon : Addon() {\n\n    override val projectDistributors = listOf(\n        ProjectDistributor.hangar(/*project id*/), //(1)!\n        ProjectDistributor.modrinth(/*project id*/), //(2)!\n        ProjectDistributor.github(/*project id*/) //(3)!\n    )\n\n}\n</code></pre> <ol> <li>Example: <code>ProjectDistributor.hangar(\"xenondevs/Machines\")</code></li> <li>Example: <code>ProjectDistributor.modrinth(\"nova-framework\")</code></li> <li>Example: <code>ProjectDistributor.github(\"Nova-Addons/Machines\")</code></li> </ol>"},{"location":"addon/migration-guide/0.13-0.14/#changed-novarecipekey-namspacedkey-to-novarecipeid-resourcelocation","title":"Changed <code>NovaRecipe.key: NamspacedKey</code> to <code>NovaRecipe.id: ResourceLocation</code>","text":"<p>In the effort to convert everything from <code>NamespacedId</code> / <code>NamespacedKey</code> to <code>ResourceLocation</code>, the <code>NovaRecipe</code> class has now also been updated to use <code>ResourceLocation</code>. If you've created a custom recipe deserializer, you'll probably now also need to switch to <code>RecipeDeserializer#getRecipeId(File)</code>.</p>"},{"location":"addon/migration-guide/0.13-0.14/#smithing-recipes","title":"Smithing Recipes","text":"<p>Since Mojang has changed smithing, the <code>SMITHING_TRANSFORM</code> and recipe files now also need to be in a <code>smithing_transform</code> directory. You'll also now need to specify a <code>template</code> ingredient. There is currently no support for smithing trim recipes.</p>"},{"location":"addon/migration-guide/0.14-0.15/","title":"0.14 \u279d 0.15","text":""},{"location":"addon/migration-guide/0.14-0.15/#paper-migration","title":"Paper migration","text":"<p>Nova has migrated to Paper. This includes significant changes to the build environment, so check out the Nova-Addon-Template on GitHub for an up-to-date example. This also means that you'll no longer need to run BuildTools. It's also no longer possible to reload the server, even if you're in dev mode with <code>-DNovaDev</code>, but this didn't work properly before anyway.</p>"},{"location":"addon/migration-guide/0.14-0.15/#init-annotation","title":"Init annotation","text":"<p>The <code>@Init</code> annotation now requires a <code>stage</code> parameter. More info</p>"},{"location":"addon/migration-guide/0.14-0.15/#configs","title":"Configs","text":"<p>Nova now uses a fork of SpongePowered/Configurate, <code>configReloadable</code> has been deprecated and nova items- and blocks now properly have a config associated with them.</p> old<pre><code>val A: Long by configReloadble { NovaConfig[Items.EXAMPLE_ITEM].getLong(\"some.value\") }\nval B: Long by configReloadable { NovaConfig[\"namespace:name\"].getLong(\"some.value\") }\n</code></pre> new<pre><code>val A: Long by Items.EXAMPLE_ITEM.config.entry&lt;Long&gt;(\"some\", \"value\")\nval B: Long by Configs[\"namespace:name\"].entry&lt;Long&gt;(\"some\", \"value\")\n</code></pre> <p>More Info</p>"},{"location":"addon/migration-guide/0.14-0.15/#itembehavior","title":"ItemBehavior","text":"<ul> <li><code>ItemBehavior</code> is now an interface.</li> <li>The same <code>ItemBehavior</code> instance can now be used for multiple <code>NovaItem</code>s.</li> <li>The <code>modifyItemBuilder</code> function has been deprecated in favor of a new <code>getDefaultCompound</code> function.</li> <li>Many default item behaviors such as <code>Damageable</code> are now also interfaces.   This allows you to (for example) implement your own damaging logic (such as using energy).</li> <li>All item behavior <code>*Options</code> classes (such as <code>FoodOptions</code>, <code>ToolOptions</code>, etc.) have been removed as   the properties have been moved to the new item behavior interfaces.</li> <li><code>NovaItem#getBehavior</code> now asserts non-null by default. Added <code>NovaItem#getBehaviorOrNull</code> for nullable access.</li> <li><code>ItemBehavior#handleInteract</code> now accepts <code>WrappedPlayerInteractEvent</code> instead of <code>PlayerInteractEvent</code>. This wrapping    class has an additional parameter called <code>actionPerformed</code>, which is used to signal whether a custom action has been run.    Additionally, <code>handleInteract</code> is now always called, even if an action (such as a tile-entity gui being opened) has    already been performed.</li> </ul> <p>More Info</p>"},{"location":"addon/migration-guide/0.14-0.15/#utility-functions","title":"Utility functions","text":"<p>ItemBehavior-related utility function such as those in <code>DamageableUtils</code> have been moved to the companion object of  their respective <code>ItemBehavior</code>.</p>"},{"location":"addon/migration-guide/0.14-0.15/#packet-event-listeners","title":"Packet Event Listeners","text":"<p>Packet Event listeners now need a <code>PacketListener</code> interface. More Info</p>"},{"location":"addon/migration-guide/0.14-0.15/#advancements","title":"Advancements","text":"<p>The advancement dsl builder has been removed. You can still register advancements via <code>AdvancementLoader</code>, but you'll need to use Mojang's internal advancement builders. The built-in utility functions for creating advancements about obtaining Nova items (<code>obtainNovaItemAdvancement</code>, <code>obtainNovaItemsAdvancement</code>) are still available.</p>"},{"location":"addon/migration-guide/0.15-0.16/","title":"0.15 \u279d 0.16","text":""},{"location":"addon/migration-guide/0.15-0.16/#minecraft-version-change","title":"Minecraft version change","text":"<p>Updated to Minecraft 1.20.4</p>"},{"location":"addon/migration-guide/0.16-0.17/","title":"0.16 \u279d 0.17","text":""},{"location":"addon/migration-guide/0.16-0.17/#minecraft-version","title":"Minecraft version","text":"<p>Updated to Minecraft 1.21.1</p>"},{"location":"addon/migration-guide/0.16-0.17/#asset-index-files-removed","title":"Asset index files removed","text":"<p>Nova no longer interprets asset index files such as <code>materials.json</code>. Instead, everything is registered in code now. This goes hand in hand with the new model builder system, which you can read more about here.</p>"},{"location":"addon/migration-guide/0.16-0.17/#registry-element-builders","title":"Registry Element Builders","text":"<p>All registry element builders are now in DSL-style: previously<pre><code>val ITEM = item(\"item\")\n    .behaviors(/*...*/)\n    .register()\n</code></pre> now<pre><code>val ITEM = item(\"item\") {\n    behaviors(/*...*/)\n}\n</code></pre></p>"},{"location":"addon/migration-guide/0.16-0.17/#items","title":"Items","text":""},{"location":"addon/migration-guide/0.16-0.17/#data-components","title":"Data components","text":"<p>With Minecraft 1.20.5, data components have been introduced. You can now also specify these in <code>ItemBehaviors</code>. More info</p>"},{"location":"addon/migration-guide/0.16-0.17/#enchantments","title":"Enchantments","text":"<p>Since enchantment categories were dropped by Vanilla, Nova has also removed enchantment categories. This means there are some changes to how the <code>Enchantable</code> behavior is configured. More info</p> <p>Additionally, the <code>Enchantment</code> Nova class and all related utility functions have been removed, as it they are no longer needed.</p>"},{"location":"addon/migration-guide/0.16-0.17/#nova-compound","title":"Nova Compound","text":""},{"location":"addon/migration-guide/0.16-0.17/#item-categories","title":"Item Categories","text":"<p>Addons can no longer define item categories. Instead, one category per addon is created by default. Server admins can still customize item categories in <code>configs/nova/item_categories.yml</code>.</p> <p>The <code>novaCompound</code> of <code>ItemStacks</code> now needs to be written back to the <code>ItemStack</code> after modification.</p>"},{"location":"addon/migration-guide/0.16-0.17/#blockstates-tile-entities","title":"Block(states) / Tile-Entities","text":"<p>Nova blocks have been drastically changed. Block states now work similarly to Minecraft's block states.</p> <p>See Blocks for more information.</p> <p>Tile-entities have undergone major refactoring, many function for retrieving data have been renamed or (re)moved. The functions that were kept in <code>TileEntity</code> are now prefixed with <code>stored...</code> instead of <code>get...</code>. Region-related functions have been moved to the <code>Region</code> companion object. Side-config related functions have been removed.</p> <p>See Tile Entities for more information.</p>"},{"location":"addon/migration-guide/0.16-0.17/#blockmanager-and-tileentitymanager-removed","title":"BlockManager and TileEntityManager removed","text":"<p><code>BlockManager</code> was removed. To place or break blocks, use <code>BlockUtils#placeBlock</code> and <code>BlockUtils#breakBlock</code>. To retrieve the block state at a certain position, you can use the extension property <code>novaBlockState</code> on <code>org.bukkit.Block</code>.</p> <p><code>TileEntityManager</code> was removed. To get the tile-entity at a certain position, use <code>WorldDataManager#getTileEntity</code>.</p>"},{"location":"addon/migration-guide/0.16-0.17/#multi-block-linked-block-states-removed","title":"Multi-block / Linked block states removed","text":"<p>The multi-block system via linked block states has been removed from Nova, as it was conceptually incompatible with the new block states. Instead, you can easily replicate the functionality via a custom block behavior that places/destroys additional blocks in <code>BlockBehavior#handlePlace</code> and <code>BlockBehavior#handleBreak</code>.</p>"},{"location":"addon/migration-guide/0.16-0.17/#block-behaviors","title":"Block Behaviors","text":"<p>A lot of block logic, such as breaking, sounds, drops, etc. has been moved into separate block behaviors. See Block Behaviors for more information.</p>"},{"location":"addon/migration-guide/0.16-0.17/#contexts","title":"Contexts","text":"<p>The existing block contexts have been replaced with a more flexible Context system.</p>"},{"location":"addon/migration-guide/0.16-0.17/#tile-entity-instantiation","title":"Tile-Entity instantiation","text":"<p>Tile-entities are now instantiated off-main, possibly before Nova initialization is completed, and in possibly unloaded chunks. More info</p>"},{"location":"addon/migration-guide/0.16-0.17/#tile-entity-async-tick","title":"Tile-Entity async tick","text":"<p>The <code>handleAsyncTick</code> function has been removed. Instead, you can use the tile-entities <code>coroutineSupervisor</code> to launch coroutines for async tasks.</p>"},{"location":"addon/migration-guide/0.16-0.17/#tile-entity-networks","title":"Tile-Entity networks","text":"<p>The tile-entity network system has been completely rewritten and now also has a documentation page.</p>"},{"location":"addon/migration-guide/0.16-0.17/#upgrade-system-moved-to-simple-upgrades","title":"Upgrade system moved to Simple-Upgrades","text":"<p>The upgrade system has been completely moved to simple upgrades and is no longer a part of Nova. You can still use it, but it will no longer be documented or referenced in the Nova docs.</p>"},{"location":"addon/migration-guide/0.16-0.17/#providers","title":"Providers","text":"<p>There were also some changes to <code>Providers</code>. You now need to call <code>get()</code> instead of <code>.value</code> to access the value. Additionally, <code>Providers</code> are now lazy, meaning they only load or update their value when they are accessed.</p>"},{"location":"addon/migration-guide/0.16-0.17/#initialization-dispatcher","title":"Initialization dispatcher","text":"<p>It is now possible to specify whether initialization tasks should be run <code>SYNC</code> or <code>ASYNC</code>, independently of the stage. The previously existing stages <code>POST_WORLD_ASYNC</code> and <code>POST_PACK_ASYNC</code> have been removed. More info</p>"},{"location":"addon/migration-guide/0.16-0.17/#general-refactoring","title":"General refactoring","text":"<p>Apart from huge changes to blocks, tile-entities, etc. some packages have been moved as well. Most notable changes:</p> <ul> <li><code>xyz.xenondevs.nova.tileentity</code> to <code>xyz.xenondevs.nova.world.block.tileentity</code></li> <li><code>xyz.xenondevs.nova.item</code> to <code>xyz.xenondevs.nova.world.item</code></li> <li><code>xyz.xenondevs.nova.player</code> to <code>xyz.xenondevs.nova.world.player</code></li> <li><code>xyz.xenondevs.nova.data.configs</code> to <code>xyz.xenondevs.nova.configs</code></li> <li><code>xyz.xenondevs.nova.data.serialization</code> to <code>xyz.xenondevs.nova.serialization</code></li> <li><code>xyz.xenondevs.nova.data.recipe</code> to <code>xyz.xenondevs.nova.recipe</code></li> <li><code>xyz.xenondevs.nova.data.resources</code> to <code>xyz.xenondevs.nova.resources</code></li> </ul>"},{"location":"addon/migration-guide/0.16-0.17/#nms-utilities","title":"NMS-Utilities","text":"<p>The NMS-Utilities library has been merged into Nova.</p>"},{"location":"addon/migration-guide/0.16-0.17/#advancement-utilities-removed-from-docs","title":"Advancement utilities removed from docs","text":"<p>The few utility functions Nova still provides for interacting with nms advancement classes have been consciously removed from the docs. Please use a third-party advancement library instead.</p>"},{"location":"addon/migration-guide/0.17-0.18/","title":"0.17 \u279d 0.18","text":""},{"location":"addon/migration-guide/0.17-0.18/#minecraft-version","title":"Minecraft version","text":"<p>Updated to 1.21.4</p>"},{"location":"addon/migration-guide/0.17-0.18/#addons-are-now-loaded-as-paper-plugins","title":"Addons are now loaded as Paper plugins","text":"<p>Addons are now loaded as Paper plugins. This includes some changes to the build setup, so please check out the updated Nova-Addon-Template.</p> <p>This also means that id and name are no longer separate. Instead, the lowercase name of the plugin is now also the id. Please verify that this does not result in a different id than before.</p> <p>The nova gradle plugin will automatically generate a <code>paper-plugin.yml</code>, as well as loader- bootstrapper- and plugin main class for you. You can also create your own loader- bootstrapper- and main classes. If you do so, please define them in the configuration of the nova gradle plugin, and NOT in the <code>paper-plugin.yml</code>, as the gradle plugin needs to inject some code into them. Also note that defining a custom loader will disable the library loading functionality via the <code>libraryLoader</code> dependency configuration.</p> <p>Nova will automatically move configs, recipes, and other data from <code>plugins/Nova/...</code> to the data folder of your plugin.</p>"},{"location":"addon/migration-guide/0.17-0.18/#early-initialization","title":"Early initialization","text":"<p>All PRE_WORLD initialization phases are now earlier (during Bootstrap phase). At this time, most Bukkit classes are not usable yet, as they depend on a not yet existing <code>MinecraftServer</code> instance.</p> <p>Common exceptions that may indicate that you're trying to access things too early are:</p> <ul> <li><code>java.lang.IllegalStateException: Trying to access unbound value ...</code></li> <li><code>Caused by: java.lang.NullPointerException: Cannot invoke ... because \"org.bukkit.Bukkit.server\" is null</code></li> </ul>"},{"location":"addon/migration-guide/0.17-0.18/#item-models","title":"Item models","text":"<p>With 1.21.4, Mojang has introduced Item model definitions. The existing model selection functionality of items and blocks has changed to accommodate this new functionality. Items can no longer have multiple (named) models, as this is now achievable through the new custom model data component.</p> <p>See Item Model Definitions for a full tutorial on Nova's item model definition builder.</p> <p>Basically,</p> <pre><code>models {\n    selectModel {\n        getModel(\"...\")\n    }\n}\n</code></pre> <p>becomes</p> <pre><code>modelDefinition {\n    model = buildModel { \n        getModel(\"...\")\n    }\n}\n</code></pre> <p>The item model definition builder also offers <code>numberedModels</code> and <code>rangedModels</code> functions as replacements for <code>selectModel(IntRange, ...)</code>. These can then be accessed via custom model data.</p>"},{"location":"addon/migration-guide/0.17-0.18/#block-models","title":"Block models","text":"<p>Block model selection has been simplified a bit and is no longer as nested as before:</p> 0.180.17 <pre><code>stateBacked(BackingStateCategory.NOTE_BLOCK, BackingStateCategory.MUSHROOM_BLOCK) {\n    getModel(\"...\")\n}\n</code></pre> <pre><code>models {\n    stateBacked(BackingStateCategory.NOTE_BLOCK, BackingStateCategory.MUSHROOM_BLOCK)\n    selectModel {\n        getModel(\"...\")\n    }\n}\n</code></pre> <p>(same for <code>entityBacked</code>)</p> <p>Item model definitions for block models</p> <p>You can also use item model definitions for block models via <code>entityItemBacked</code>. This allows you to use <code>minecraft:special</code> models, such as chests or signs for blocks.</p>"},{"location":"addon/migration-guide/0.17-0.18/#default-itemblock-behavior-factory-companion-objects","title":"Default item/block behavior factory companion objects","text":"<p>The companion objects of the default item/block behaviors that allow configuration are no longer item/block behavior factories. This was done to merge the \"hardcoded\" and \"configurable\" ways to create instances of these item behaviors.</p> <p>Basically, this means that <code>behaviors(Tool, Damageable, Enchantable)</code> becomes <code>behaviors(Tool(), Damageable(), Enchantable()</code>. If you don't change any of the default parameters, all values will always be read from the config. If you specify any parameter, a config entry will not be necessary, but existing config entries will still override the hardcoded value.</p>"},{"location":"addon/migration-guide/0.17-0.18/#equipment","title":"Equipment","text":"<p>In 1.21.2, Mojang introduced custom equipment. Following this naming, <code>ArmorRegistry</code> is now <code>EquipmentRegistry</code> and offers new functionality, such as custom armor for non-player entities. Animated armor now also works for all clients, including those running shader mods.</p> 0.180.17 <pre><code>@Init(stage = InitStage.PRE_PACK)\nobject Equipment : EquipmentRegistry by Machines.registry {\n\n    val STAR = equipment(\"star\") {\n        humanoid {\n            layer {\n                texture(\"star\")\n                emissivityMap(\"star_emissivity_map\")\n            }\n        }\n        humanoidLeggings { // (1)!\n            layer {\n                texture(\"star\")\n                emissivityMap(\"star_emissivity_map\")\n            }\n        }\n    }\n\n}\n</code></pre> <ol> <li>Minecraft separates <code>humanoid</code> and <code>humanoid_leggins</code> into two categories, I don't know why either.</li> </ol> <pre><code>@Init(stage = InitStage.PRE_PACK)\nobject Armor : ArmorRegistry by Machines.registry {\n\n    val STAR = armor(\"star\") {\n        texture {\n            texture(\"armor/star_layer_1\", \"armor/star_layer_2\")\n            emissivityMap(\"armor/star_layer_1_emissivity_map\", \"armor/star_layer_2_emissivity_map\")\n        }\n    }\n\n}\n</code></pre> <p><code>Wearable</code> is now named <code>Equippable</code></p>"},{"location":"addon/migration-guide/0.17-0.18/#gui-textures","title":"Gui textures","text":"<p>The gui texture builder has been simplified:</p> 0.180.17 <pre><code>val RECIPE_CRAFTING = guiTexture(\"recipe_crafting\") {\n    path(\"gui/recipe/crafting\")\n}\n</code></pre> <pre><code>val RECIPE_CRAFTING = guiTexture(\"recipe_crafting\") {\n    texture {\n        path(\"gui/recipe/crafting\")\n    }\n}\n</code></pre>"},{"location":"addon/migration-guide/0.17-0.18/#providers","title":"Providers","text":"<p>Providers have been reworked. They are now thread-safe and lazy both up- and downstream.</p> <ul> <li>The packages  <code>xyz.xenondevs.commons.provider.immutable</code> and <code>xyz.xenondevs.commons.provider.mutable</code>   have been collapsed into the parent package <code>xyz.xenondevs.commons.provider</code>.</li> <li><code>Provider#update</code> has been removed. Similar functionality can be replicated by creating a mutable provider and calling   <code>set</code> on it.</li> <li>Extension functions for collection-mapping functionality, such as <code>flatMap</code>, have been renamed (to <code>flatMapCollection</code>)   in order to make room for <code>flatMap((T) -&gt; Provider&lt;R&gt;)</code>.</li> <li><code>Provider.orElse(MutableProvider)</code> has been removed as it was not compatible with lazy upstream propagation   (<code>Provider.orElse(Provider)</code> still exists).</li> <li>Nova's <code>ConfigProvider</code> no longer exists. Instead, equivalent extension functions are now available on <code>Provider&lt;ConfigurationNode&gt;</code>.</li> </ul>"},{"location":"addon/migration-guide/0.17-0.18/#invui-200-alpha1","title":"InvUI 2.0.0-alpha.1","text":"<p>InvUI has been updated to a pre-release version of 2.0.0.</p> <p>See the GitHub release page for a list of breaking changes and new features.</p>"},{"location":"addon/migration-guide/0.17-0.18/#reactive-api","title":"Reactive API","text":"<p>InvUI now offers an experimental reactive API in the <code>invui-kotlin</code> module. This includes extension functions for <code>Item.Builder#setItemProvider</code>, <code>PagedGui#setContent</code>, ..., that accept a <code>Provider</code>. The item/gui/window will be automatically updated when the provider's value changes, removing the need for manual <code>notifyWindows</code> calls.</p> Reactive API example <p>Since the InvUI documentation is not updated yet, here is an example on how to use the reactive API:</p> <pre><code>val num: MutableProvider&lt;Int&gt; = mutableProvider(0) // stores the number of clicks on the '#' item\nval query: MutableProvider&lt;String&gt; = mutableProvider(\"\") // stores the anvil window text\n\nfun example(player: Player) {\n    // example item that shows click count\n    Structure.addGlobalIngredient('#', Item.builder()\n        .setItemProvider(num) { num -&gt; ItemBuilder(Material.BLACK_STAINED_GLASS_PANE).setName(\"Count: $num\") } // item updates based on num provider\n        .addClickHandler { _, _ -&gt; num.set(num.get() + 1) }) // click increments num\n\n    // page buttons\n    Structure.addGlobalIngredient('&gt;', BoundItem.pagedGui()\n        .setItemProvider { _, gui -&gt; ItemBuilder(Material.ARROW).setName(\"Go to page ${gui.page + 2}/${gui.pageAmount}\") }\n        .addClickHandler { _, gui, click -&gt; if (click.clickType == ClickType.LEFT) gui.page++ })\n    Structure.addGlobalIngredient('&lt;', BoundItem.pagedGui()\n        .setItemProvider { _, gui -&gt; ItemBuilder(Material.ARROW).setName(\"Go to page ${gui.page}/${gui.pageAmount}\") }\n        .addClickHandler { _, gui, click -&gt; if (click.clickType == ClickType.LEFT) gui.page-- })\n\n    // marker\n    Structure.addGlobalIngredient('x', Markers.CONTENT_LIST_SLOT_HORIZONTAL)\n\n    AnvilWindow.split()\n        .setTitle(\"InvUI\")\n        .addRenameHandler(query) // automatically writes text into query provider\n        .setUpperGui(\n            Gui.builder()\n                .setStructure(\"###\")\n                .addIngredient('#', Item.simple(ItemBuilder(Material.BLACK_STAINED_GLASS_PANE).setName(\"\"))) // this item does nothing\n        )\n        .setLowerGui(PagedGui.items()\n            .setStructure(\n                \"x x x x x x x x x\",\n                \"x x x x x x x x x\",\n                \"x x x x x x x x x\",\n                \"# # &lt; # # # &gt; # #\")\n            .setContent(query) { query -&gt; // content updates based on query provider\n                Material.entries\n                    .filter { !it.isLegacy &amp;&amp; it.isItem &amp;&amp; it.name.contains(query, true) }\n                    .map { Item.simple(ItemStack(it)) }\n            })\n        .open(player)\n}\n</code></pre> <p>And this is what it looks like: </p>"},{"location":"addon/migration-guide/0.17-0.18/#resourcetype-in-resourcepath","title":"ResourceType in ResourcePath","text":"<p><code>ResourcePath</code> now includes a <code>ResourceType</code> parameter to specify the type (and path / extension) of the resource.</p>"},{"location":"addon/migration-guide/0.17-0.18/#other-changes","title":"Other changes","text":"<ul> <li>All usages of <code>net.minecraft.resources.ResourceLocation</code> have been replaced with <code>net.kyori.adventure.key.Key</code></li> </ul>"},{"location":"addon/migration-guide/0.18-0.19/","title":"0.18 \u279d 0.19","text":""},{"location":"addon/migration-guide/0.18-0.19/#minecraft-version","title":"Minecraft version","text":"<p>Updated to 1.21.5</p>"},{"location":"addon/migration-guide/0.18-0.19/#invui","title":"InvUI","text":"<p>Updated InvUI to 2.0.0-alpha.8, which contains numerous breaking changes. See the InvUI GitHub release page for details.</p>"},{"location":"addon/migration-guide/0.18-0.19/#itembehavior","title":"ItemBehavior","text":"<ul> <li><code>ItemBehavior.defaultPatch</code> has been removed with no replacement</li> <li><code>ItemBehavior.baseDataComponents</code> is now a provider of <code>xyz.xenondevs.nova.world.item.DataComponentMap</code>  instead of the nms <code>DataComponentMap</code>. The new <code>DataComponentMap</code> allows the usage of Paper's data component types.  Use the top-level function <code>buildDataComponentMapProvider { }</code> for a builder DSL.</li> <li><code>ItemBehavior#handleEquip</code> has been updated to use Paper's <code>EntityEquipmentChangedEvent</code>.  Note that this handler is fired more often than the old one, such as when joining the server or when equipping  an item in a hand. Nova's custom <code>ArmorEquipEvent</code> has been removed.</li> <li>Removed overloads for default item behavior factory functions (and updated their constructors) that  accepted <code>Holder&lt;SoundEvent&gt;</code>. Use <code>Key</code> instead.</li> </ul>"},{"location":"addon/migration-guide/0.18-0.19/#addon-registries","title":"Addon Registries","text":"<p>The registry interfaces (such as <code>ItemRegistry</code>, <code>BlockRegistry</code>) have been deprecated. All registration functions are now available on the <code>Addon</code> object.</p> 0.180.19 <pre><code>@Init(stage = InitStage.PRE_PACK)\nobject Equipment : EquipmentRegistry by Machines.registry {\n\n    val STAR = equipment(\"star\") {\n        humanoid {\n            layer {\n                texture(\"star\")\n            }\n        }\n        humanoidLeggings {\n            layer {\n                texture(\"star\")\n            }\n        }\n    }\n\n}\n</code></pre> <pre><code>import xyz.xenondevs.nova.addon.machines.Machines.equipment\n\n@Init(stage = InitStage.PRE_PACK)\nobject Equipment {\n\n    val STAR = equipment(\"star\") {\n        humanoid {\n            layer {\n                texture(\"star\")\n            }\n        }\n        humanoidLeggings {\n            layer {\n                texture(\"star\")\n            }\n        }\n    }\n\n}\n</code></pre>"},{"location":"addon/migration-guide/0.19-0.20/","title":"0.19 \u279d 0.20","text":""},{"location":"addon/migration-guide/0.19-0.20/#minecraft-version","title":"Minecraft version","text":"<p>Updated to 1.21.6</p>"},{"location":"addon/migration-guide/0.19-0.20/#itembehavior","title":"ItemBehavior","text":"<ul> <li><code>modifyClientSideStack</code> now receives the server-side <code>ItemStack</code> instead of <code>data: NamespacedCompound</code>.     The data can still be accessed by using the <code>ItemStack.retrieveData</code> extension functions on <code>server: ItemStack</code>.</li> </ul>"},{"location":"addon/migration-guide/0.19-0.20/#commons-provider","title":"commons-provider","text":"<p>Updated to <code>2.0.0-alpha.4</code>, which contains the following breaking changes:</p> <ul> <li>Removed <code>MutableProvider.defaultsTo</code>, use <code>orElse</code> instead. (For CBF compounds, entry providers can now have a default value)</li> <li>Removed <code>MutableProvider.orElse(Provider)</code> with no replacement</li> <li>Removed <code>MutableProvider.detached</code> with no replacement</li> <li>Some extension functions, such as <code>map</code> and <code>flatMap</code>, are now member functions on <code>Provider</code> / <code>MutableProvider</code>, which   means that you may need to remove some invalid imports.</li> </ul> <p>Check out the updated commons-provider KDocs.</p>"},{"location":"addon/migration-guide/0.19-0.20/#cbf","title":"CBF","text":"<p>Updated to <code>1.0.0-alpha.2</code>, which contains major changes to how custom serializers work. Check out the updated CBF Docs and CBF KDocs.</p>"},{"location":"addon/migration-guide/0.19-0.20/#invui","title":"InvUI","text":"<p>Updated to <code>2.0.0-alpha.14</code>, which contains one breaking change:</p> <ul> <li>Removed <code>Gui#remove(...)</code> in favor of <code>Gui#setSlotElement(..., null)</code></li> </ul>"},{"location":"addon/misc/events/","title":"Events","text":""},{"location":"addon/misc/events/#working-with-bukkit-events","title":"Working with Bukkit Events","text":"<p>Of course, you can also use Bukkit's events. To register an event listener, use the <code>Listener.registerEvents()</code> extension function.</p>"},{"location":"addon/misc/events/#working-with-packet-events","title":"Working with Packet Events","text":"<p>You can also listen to incoming and outgoing packets. To do so, implement the <code>PacketListener</code> interface and register your listener using the <code>PacketListener.registerPacketHandler()</code> extension function. Then, you can use the <code>@PacketHandler</code> annotation to mark event methods.</p> <p>Packet Event Types</p> <p>Please note that this currently does not include all possible packets, as the system is still in development. Feel free to open an issue or a pull request if you need another packet type.</p>"},{"location":"addon/misc/events/#calling-events-from-novas-plugin-api","title":"Calling events from Nova's Plugin API","text":"<p>You might've noticed that the <code>nova-api</code> module is not in your classpath. This module is explicitly for developers of third party plugins and provides a stable API for Nova. To prevent addon developers from accidentally using those classes, <code>nova-api</code> is not a transitive dependency of <code>nova</code>.</p> <p>To still call events from Nova's Plugin API, use the <code>NovaEventFactory</code>:</p> <pre><code>// obtain drops from the block\nval drops: MutableList&lt;ItemStack&gt; = block.getAllDrops().toMutableList()\n// call the event (might mutate drops list)\nNovaEventFactory.callTileEntityBlockBreakEvent(this, block, drops)\n</code></pre>"},{"location":"addon/misc/project-distributors/","title":"Configuring project distributors for update notifications","text":"<p>To set up update notifications, simply override the <code>projectDistributors</code> list in your addon object:</p> MyAddon.kt<pre><code>object MyAddon : Addon() {\n\n    override val projectDistributors = listOf(/*your distributors*/)\n\n}\n</code></pre> <p>By default, there are three different distributors available:</p> Distributor Code Hangar <code>ProjectDistributor.hangar(/*project id*/)</code> Modrinth <code>ProjectDistributor.modrinth(/*project id*/)</code> GitHub <code>ProjectDistributor.github(/*project id*/)</code> <p>You can also create your own distributor by implementing the <code>ProjectDistributor</code> interface.</p> <p>Order of update checks</p> <p>When checking for updates, all registered distributors are checked in the order they are specified in the list. This means that if you want users to download your updates from a specific distributor, you should put it at the top of the list.</p> <p>Pre-release versions</p> <p>Users will only be notified of pre-release versions if they themselves are using a pre-release version.</p>"},{"location":"addon/misc/scheduler/","title":"Scheduler","text":"<p>To access the Bukkit scheduler, you can use the top-level functions <code>runTask</code>, <code>runTaskLater</code>, <code>runTaskTimer</code>, <code>runAsyncTask</code>, <code>runAsyncTaskLater</code>, and <code>runAsyncTaskTimer</code>.</p>"},{"location":"addon/resourcepack/addon-assets/","title":"Addon Assets","text":"<p>Minecraft Resource Pack Format</p> <p>Before continuing here, make sure to familiarize yourself with the Minecraft Resource Pack Format if you haven't already.</p> <p>All assets intended for the resource pack should be placed in <code>src/main/resources/assets/</code>. Nova will automatically read and extract assets from the following subdirectories into the final resource pack:</p> <ul> <li><code>atlases/</code> - Wiki</li> <li><code>textures/</code> - Wiki</li> <li><code>models/</code> - Wiki (unused models will not be included)</li> <li><code>lang/</code> - Wiki</li> <li><code>fonts/</code> - Wiki</li> <li><code>sounds/</code> and <code>sounds.json</code> - Wiki</li> </ul>"},{"location":"addon/resourcepack/addon-assets/#models","title":"Models","text":"<p>For creating custom block models, we recommend using Blockbench. For entity-backed blocks, Nova allows you to create oversized models. If you want to take advantage of this, you'll need to deactivate Blockbench's size limit:</p> <p></p>"},{"location":"addon/resourcepack/addon-assets/#language-files","title":"Language Files","text":"<p>Language files belong in the <code>lang</code> folder. The format for these files is the same one minecraft uses. If you need the locale code for a language, you can search for it here.</p> <p>Warning</p> <p>Make sure to use the \"in-game\" locale code since ISO-639-3 isn't implemented by Minecraft (yet?)</p> <p>For English (United States), create a file called <code>en_us.json</code> in the <code>lang</code> folder. The format <code>[&lt;type&gt;].&lt;namespace/addon-id&gt;.&lt;item&gt;</code> should be used for the translations keys. The type can be left out if it's a generic message. In general, the following types should be used:</p> <ul> <li><code>item</code> - For translations related to items</li> <li><code>block</code> - For translations related to blocks</li> <li><code>menu</code> - For GUI related translations</li> <li><code>inventory</code> - For inventory names</li> <li><code>container</code> - For fluid container names</li> <li><code>command</code> - For command responses</li> <li><code>advancement</code> - For advancements</li> </ul> <p>You can of course use your own type names, just make sure to include your addons namespace in the key.</p> <pre><code>{\n  \"item.example_addon.ruby\": \"Ruby\",\n  \"block.example_addon.solar_panel\": \"Solar Panel\",\n  \"advancement.example_addon.ruby.title\": \"Ruby\",\n  \"advancement.example_addon.ruby.description\": \"Acquire a ruby\",\n  \"advancement.example_addon.solar_panel.title\": \"Clean Energy\",\n  \"advancement.example_addon.solar_panel.description\": \"Craft a Solar Panel\"\n}\n</code></pre>"},{"location":"addon/resourcepack/build-logic/","title":"Custom resource pack build logic","text":"<p>To run code during the resource pack build process, you'll need to register a <code>PackTask</code>. Pack tasks are functions annotated with <code>@PackTask</code> and need to be located in a class that implements the <code>PackTaskHolder</code> interface. Those holders then need to be registered with <code>ResourcePackBuilder.registerTaskHolders</code>.</p> <pre><code>ResourcePackBuilder.registerTaskHolders(::CustomTaskHolder)\n</code></pre> CustomTaskHolder.kt<pre><code>class CustomTaskHolder(private val builder: ResourcePackBuilder) : PackTaskHolder {\n\n    @PackTask\n    fun customTask() {\n        // Do something\n    }\n\n}\n</code></pre>"},{"location":"addon/resourcepack/build-logic/#packtask","title":"PackTask","text":"<p>The <code>@PackTask</code> annotation has three optional parameters: <code>stage: BuildStage</code>, <code>runAfter: Array&lt;String&gt;</code> and <code>runBefore: Array&lt;String&gt;</code>.</p>"},{"location":"addon/resourcepack/build-logic/#build-stages","title":"Build Stages","text":"<p>There are two build stages: <code>PRE_WORLD</code> and <code>POST_WORLD</code>. This is because some logic needs to be done before the world has been loaded (such as assigning block states to nova block types) but some other logic might need to interact with other plugins that are only loaded after the world has been loaded (for example rendering the WAILA textures for blocks of custom item services). By default, the stage is <code>BuildStage.AUTOMATIC</code>, which means that the build stage will be determined based on the given <code>runAfter</code> and <code>runBefore</code> dependencies. If there are no dependencies, the stage will be <code>PRE_WORLD</code>.</p>"},{"location":"addon/resourcepack/build-logic/#dependencies","title":"Dependencies","text":"<p>You can define which tasks should be run before or after your task using the <code>runAfter</code> and <code>runBefore</code> parameters. This is quite similar to the Initialization dependencies, with the exception that you don't define classes but task names. Tasks are named after their simple class- and function name, separated by a <code>#</code>. So if you have a class <code>CustomTaskHolder</code> with the function <code>customTask</code>, the task name would be <code>CustomTaskHolder#customTask</code>. The benefit of using strings instead of class references is that you can configure dependencies to specific tasks instead of the whole task holder class.</p> <p>As an example, Nova's <code>EnchantmentContent#write</code> task requires language files to be loaded, certain font characters to have been created and char sizes to be calculated, but it also writes to the language files, which means that it needs to run before the <code>LanguageContent#write</code> task. This is how it's configured:</p> <pre><code>@PackTask(\n    runAfter = [\"LanguageContent#loadLangFiles\", \"EnchantmentContent#createBackgroundChars\", \"CharSizeCalculator#calculateCharSizes\"],\n    runBefore = [\"LanguageContent#write\"]\n)\nprivate fun write() {\n    // ...\n}\n</code></pre> <p>This is just an example, EnchantmentContent was made obsolete with data-driven enchantments in Minecraft 1.21</p>"},{"location":"addon/resourcepack/build-logic/#resourcepackbuilder","title":"ResourcePackBuilder","text":"<p>As shown in the example above, you'll register a task holder constructor that accepts a <code>ResourcePackBuilder</code> instance as parameter. This builder instance organizes the build process and provides you with access to other task holders.</p>"},{"location":"addon/resourcepack/build-logic/#accessing-files","title":"Accessing files","text":"<p>Resource pack building might take place entirely in memory or on disk in the <code>plugins/Nova/resource_pack/.build/</code> directory, depending on the server configuration. In-memory resource pack generation is implemented using JIMFS and is the reason why all file access runs over <code>java.nio.Path</code> instead of <code>java.io.File</code>. You can resolve any file using <code>ResourcePackBuilder#resolve</code>.</p>"},{"location":"addon/resourcepack/build-logic/#retrieving-packtaskholder-instances","title":"Retrieving <code>PackTaskHolder</code> instances","text":"<p>When creating a custom task, you might want to interact with existing task holders from your own addon, Nova, or other addons. To retrieve a task holder instance, call <code>resourcePackBuilder.getHolder&lt;HolderType&gt;()</code> with the holder class as type parameter.</p> <pre><code>class CustomTaskHolder(private val builder: ResourcePackBuilder) : PackTaskHolder {\n\n    @PackTask\n    fun customTask() {\n        val languageContent = builder.getHolder&lt;LanguageContent&gt;()\n        languageContent.setTranslation(\"en_us\", \"translation.key\", \"Hello World\")\n    }\n\n}\n</code></pre>"},{"location":"addon/resourcepack/build-logic/#retrieving-resource-filters","title":"Retrieving resource filters","text":"<p>Resource filters are used to filter out resources that should not be included in the resource pack. They can be configured by server admins and addon developers using <code>ResourcePackBuilder.registerResourceFilter</code>. During the build process, you can retrieve the filters using <code>resourcePackBuilder.getResourceFilters(stage)</code>. If you write additional files, you should check whether they are configured to be excluded.</p>"},{"location":"addon/resourcepack/build-logic/#important-built-in-task-holders","title":"Important built-in task holders","text":"<p>The following are the most important built-in task holders, which you might need to interact with in code. You should prefer using these instead of direct file access, because they would probably overwrite your changes and are generally more convenient and performant to use.</p> <p>All other pack tasks</p> <p>A list of all pack tasks and their execution order will be shown in the console every time the resource pack is built.</p>"},{"location":"addon/resourcepack/build-logic/#modelcontent","title":"ModelContent","text":"<p>Provides you with access to block and item models. Everything related to the creation of custom models should run through this.</p> <p>Using <code>ModelContent#rememberUsage</code>, you can mark a model as used, so it (and all its parents) will be included in the resource pack. This is performed automatically for all models that are assigned to <code>NovaItems</code> or <code>NovaBlocks</code>.</p>"},{"location":"addon/resourcepack/build-logic/#languagecontent","title":"LanguageContent","text":"<p>Provides you with access to language files.</p> <pre><code>@PackTask\nfun task() {\n    val languageContent = builder.getHolder&lt;LanguageContent&gt;()\n    languageContent.setTranslation(\"en_us\", \"translation.key\", \"Hello World\")\n}\n</code></pre>"},{"location":"addon/resourcepack/build-logic/#fontcontent","title":"FontContent","text":"<p>Provides you with access to fonts.</p>"},{"location":"addon/resourcepack/build-logic/#vanillafonts","title":"<code>vanillaFonts</code>","text":"<p>This map shows the fonts that are part of the base game assets. These fonts are not included in Nova's resource pack.</p>"},{"location":"addon/resourcepack/build-logic/#customfonts","title":"<code>customFonts</code>","text":"<p>This map stores custom fonts and custom overrides to existing fonts from base packs, Nova, and addons. You can get and create custom fonts using <code>fontContent.get</code>, <code>fontContent.getOrCreate</code>, <code>fontContent.add</code>, etc.</p>"},{"location":"addon/resourcepack/build-logic/#mergedfonts","title":"<code>mergedFonts</code>","text":"<p>This map shows both <code>vanillaFonts</code> and <code>customFonts</code> merged together in the same way they'd be merged for the client. This might be useful if you want to add custom characters to the <code>minecraft:default</code> font without overriding existing characters. Using <code>Font.findFirstUnoccupied</code> or <code>Font.findFirstUnoccupiedRange</code> you could then search for an unoccupied range of code points.</p>"},{"location":"addon/resourcepack/build-logic/#movedfontcontent","title":"MovedFontContent","text":"<p>Allows you to request vertically moved fonts.</p> <pre><code>@PackTask\nfun task() {\n    val movedFontContent = builder.getHolder&lt;MovedFontContent&gt;()\n    movedFontContent.requestMovedFonts(ResourcePath(\"namespace\", \"name\"), 0..19)\n}\n</code></pre>"},{"location":"addon/resourcepack/build-logic/#textureiconcontent","title":"TextureIconContent","text":"<p>Allows you to request textures for Nova's texture-icon font.</p> <pre><code>@PackTask\nfun task() {\n    val textureIconContent = builder.getHolder&lt;TextureIconContent&gt;()\n    textureIconContent.addIcons(\"minecraft:item/diamond\", \"minecraft:item/emerald\")\n}\n</code></pre> <p>They can then be retrieved later:</p> <pre><code>val component: Component = TextureIconContent.getIcon(Key.key(\"minecraft:item/diamond\")).component\n</code></pre>"},{"location":"addon/tile-entity/gui/","title":"TileEntity Menu","text":"<p>Check out the InvUI wiki</p> <p>If you're not familiar with the InvUI library, you'll have trouble understanding the following guide. You can check out the wiki here. Nova registers some default ingredients which can be used in the Gui Builder. You can check out the default ingredients here. Don't register your own global ingredients!</p>"},{"location":"addon/tile-entity/gui/#creating-a-tileentitymenu","title":"Creating a TileEntityMenu","text":"<p>If you want your TileEntity to have a GUI, you'll have to create a TileEntityMenu class. You can do this by inheriting from either <code>GlobalTileEntityMenu</code> or <code>IndividiualTileEntityMenu</code>. The difference between the two is that the <code>GlobalTileEntityMenu</code> will only have one instance per tile-entity, while the <code>IndividualTileEntityMenu</code> will have one instance per player.</p> <p>To mark your menu class as a TileEntity menu, you'll have to annotate it with the <code>@TileEntityMenuClass</code> annotation. Nova will automatically instantiate your menu class when needed. (Note that your <code>NovaBlock</code> will require the <code>TileEntityInteractive</code> behavior to open the GUI.)</p> <p>Example GUIs</p> GlobalTileEntityMenuIndividualTileEntityMenu <pre><code>@TileEntityMenuClass\nprivate inner class SolarPanelMenu : GlobalTileEntityMenu() {\n\n    override val gui = Gui.builder()\n        .setStructure(\n            \"1 - - - - - - - 2\",\n            \"| u # # e # # # |\",\n            \"| # # # e # # # |\",\n            \"| # # # e # # # |\",\n            \"3 - - - - - - - 4\")\n        .addIngredient('u', OpenUpgradesItem(upgradeHolder))\n        .addIngredient('e', EnergyBar(3, energyHolder)) // (1)!\n        .build()\n\n}\n</code></pre> <ol> <li>The <code>energyHolder</code> will be explained in an upcoming section.</li> </ol> <p>For most cases, this is the menu class you'll want to extend.</p> <pre><code>@TileEntityMenuClass\nprivate inner class VacuumChestMenu(player: Player) : IndividualTileEntityMenu(player) {\n\n    override val gui = Gui.builder()\n        .setStructure(\n            \"1 - - - - - - - 2\",\n            \"| s u # i i i p |\",\n            \"| r # # i i i d |\",\n            \"| f # # i i i m |\",\n            \"3 - - - - - - - 4\")\n        /* ... */\n        .addIngredient('r', region.createVisualizeRegionItem(player)) // (1)!\n        /* ... */\n        .build()\n\n}\n</code></pre> <ol> <li>This is what we need the Player instance for. The visualize region button can be toggled by every player individually, which is why we need different <code>Gui</code> instances for each player.  If you're intrested in the <code>region</code> field, you can check out the Region section.</li> </ol> <p>Gui Textures</p> <p>If you want to use a GuiTexture, simply pass it to the <code>GlobalTileEntityMenu</code> / <code>IndividualTileEntityMenu</code> constructor.</p>"},{"location":"addon/tile-entity/introduction/","title":"Introduction","text":"<p>Tile-Entities are blocks that have additional data and logic attached to them.</p>"},{"location":"addon/tile-entity/introduction/#creating-a-tile-entity","title":"Creating a Tile-Entity","text":"<p>Before registering the <code>NovaBlock</code> for a tile-entity, you'll need to create a class that extends <code>TileEntity</code>:</p> <pre><code>class ExampleTileEntity(\n    pos: BlockPos,\n    blockState: NovaBlockState,\n    data: Compound\n) : TileEntity(pos, blockState, data) {\n\n    // ...\n\n}\n</code></pre> <p>Now, you can register the block:</p> <pre><code>@Init(stage = InitStage.PRE_PACK) // (1)!\nobject Blocks {\n\n    val EXAMPLE_TILE_ENTITY = ExampleAddon.tileEntity(\"example_tile_entity\", ::ExampleTileEntity) {\n        behaviors(\n            TileEntityLimited, // (2)!\n            TileEntityDrops, // (3)!\n            TileEntityInteractive // (4)!\n        )\n        tickrate(20) // (5)!\n    }\n\n}\n</code></pre> <ol> <li>Nova will load this class during addon initialization, causing your blocks to be registered.</li> <li>Enables tile-entity limits.    (Note that if this behavior is not present, tile-entity limit tracking will also be disabled and placing this tile-entity    will not count towards global limits.)</li> <li>Delegates the drop logic to <code>TileEntity.getDrops</code>.</li> <li>Delegates interactions to <code>TileEntity.handleRightClick</code>. This is also required if your tile-entity has a GUI.</li> <li>The rate at which <code>TileEntity.handleTick</code> function is called.    This defaults to <code>20</code>, so you wouldn't need to specify it in this case.</li> </ol> <p>Tile-Entities are instantiated off-main</p> <p>Tile-Entities are constructed off-main, so you cannot interact with world state during object construction. Also, it is not guaranteed that the chunk the tile-entity is in is loaded at the time of construction. For such cases, use <code>TileEntity.handleEnable()</code> and <code>TileEntity.handleDisable()</code>.</p> <p>Additionally, especially concerning tile-entites that are in spawn chunks, Nova might not be fully initialized when the tile-entity is constructed. As such, you cannot rely on anything that is not initialized pre world to be available during tile-entity construction. (Such as RecipeManager for example, which needs to wait for the initialization of supported third-party custom item plugins.)</p>"},{"location":"addon/tile-entity/introduction/#accessing-tile-entity-data","title":"Accessing Tile-Entity data","text":"<p>Tile-Entity data is stored in our CBF Format, so make sure to check out the CBF Documentation.</p> Default Nova Binary Adapters <p>Nova provides binary adapters for the following types by default: <code>NamespacedCompound</code>, <code>Color</code>, <code>Location</code>, <code>NamespacedKey</code>, <code>NamespacedId</code>, <code>ResourceLocation</code>, <code>VirtualInventory</code>, <code>BlockPos</code>, <code>ItemStack</code>, <code>NetworkType</code>, <code>AbilityType</code>, <code>AttachmentType</code>, <code>RecipeType</code>, <code>Table</code>, <code>ItemFilter</code>, <code>NovaBlock</code>, <code>NovaItem</code>, <code>ToolCategory</code>, <code>ToolTier</code></p> <p>You can register binary adapters for your own types as explained in the CBF Documentation. If you require a binary adapter for a type from Java / Minecraft / Paper, please request it on GitHub.</p> <p>To access tile-entity data, you can use the <code>storedValue</code> function to retrieve a <code>MutableProvider&lt;T&gt;</code> to which you can delegate:</p> storedValue (not null)<pre><code>private val someInt: Int by storedValue(\"someInt\") { 0 }\n</code></pre> storedValue (nullable)<pre><code>private val someString: String? by storedValue(\"someString\")\n</code></pre> <p>And that's it! When the tile-entity gets saved, those properties will automatically be saved with it.</p> <p>Providers are lazy</p> <p>Since Providers are lazy, it is safe to use them to access things that are initialized post world, as long as their values are not resolved immediately.</p> <p>Alternatively, you can also use <code>retrieveData</code> and <code>storeData</code> functions to manually read and write data. For that, you may also want to override the <code>saveData</code> function.</p>"},{"location":"addon/tile-entity/introduction/#utility-functions-for-commonly-stored-data-types","title":"Utility functions for commonly stored data types","text":"<p>There are a few utility functions available in <code>TileEntity</code> for storing commonly used data:</p> <ul> <li><code>storedInventory</code> - Creates or reads a VirtualInventory   from internal storage. Also registers a drop provider that drops the inventory's contents when the tile-entity is   destroyed.</li> <li><code>storedFluidContainer</code> - Creates or reads a <code>FluidContainer</code> from internal storage.</li> <li><code>storedRegion</code> - Creates or reads a DynamicRegion from internal storage.</li> </ul>"},{"location":"addon/tile-entity/region/","title":"Regions","text":""},{"location":"addon/tile-entity/region/#region","title":"Region","text":"<p>Generally, a region is an area between a <code>min</code> and a <code>max</code> Location.  </p> <pre><code>val region = Region(min, max)\n</code></pre> <p>The <code>Region</code> companion object provides several utility functions for creating regions, such as:</p> <ul> <li><code>Region.surrounding(pos, radius)</code></li> <li><code>Region.inFrontOf(tileEntity, ...)</code></li> <li>and more</li> </ul>"},{"location":"addon/tile-entity/region/#visualization","title":"Visualization","text":"<p>To display the outline of this region with particles, you can use the <code>VisualRegion</code> object:</p> <pre><code>// to show the region:\nVisualRegion.showRegion(player, regionUUID, region)\n// to hide the region\nVisualRegion.hideRegion(player, regionUUID)\n// to toggle on / off\nVisualRegion.toggleView(player, regionUUID, region)\n</code></pre> <p>If you want a \"Visualize Region\" button in your GUI, you can use the <code>VisualRegionItem</code>:</p> <pre><code>VisualizeRegionItem(regionUuid) { region }\n</code></pre>"},{"location":"addon/tile-entity/region/#dynamic-region","title":"Dynamic Region","text":"<p>A <code>DynamicRegion</code> is a type of region intended for use in tile-entities: Using a <code>MutableProvider&lt;Int&gt;</code> for the size, the region can be dynamically resized. It provides several gui-components to inspect, modify, and visualize the region.</p> <p>Using <code>TileEntity#storedRegion</code>, we can create a <code>DynamicRegion</code>:</p> <pre><code>class ExampleTileEntity(pos: BlockPos, blockState: NovaBlockState, data: Compound) : TileEntity(pos, blockState, data) {\n\n    private val region = storedRegion(\n        \"region\",\n        minSize = provider(1), // (1)!\n        maxSize = provider(10), // (2)!\n        defaultSize = 5, // (3)!\n        createRegion = { size -&gt; Region.surrounding(pos, size) } // (4)!\n    )\n\n    @TileEntityMenuClass\n    inner class ExampleTileEntityMenu(player: Player) : IndividualTileEntityMenu(player) {\n\n        override val gui = Gui.builder()\n            .setStructure(\n                \"v # # # # # # # #\",\n                \"# # + # d # - # #\",\n                \"# # # # # # # # #\")\n            .addIngredient('+', region.increaseSizeItem)\n            .addIngredient('-', region.decreaseSizeItem)\n            .addIngredient('d', region.displaySizeItem)\n            .addIngredient('v', region.visualizeRegionItem)\n            .build()\n\n    }\n\n}\n</code></pre> <ol> <li>The minimum size of the region.</li> <li>The maximum size of the region.</li> <li>The default size of the region when it is created. After that, the size can be changed and changes will be saved.</li> <li>A lambda that creates the desired region based on the configured size. This is invoked every time the size is changed.</li> </ol>"},{"location":"addon/tile-entity-networks/custom-network-types/","title":"Custom Network Types","text":""},{"location":"addon/tile-entity-networks/custom-network-types/#network-type","title":"Network Type","text":"<p>You can register a custom network type like this:</p> <pre><code>@Init(stage = InitStage.PRE_WORLD)\nclass NetworkTypes {\n\n    val EXAMPLE = ExampleAddon.registerNetworkType(\n        name = \"example\",\n        createNetwork = ::ExampleNetwork, // (1)!\n        createGroup = ::ExampleNetworkGroup, // (2)!\n        validateLocal = ExampleNetwork::validateLocal, // (3)!\n        tickDelay = provider(1), // (4)!\n        holderTypes = arrayOf(ExampleDataHolder::class, ItemHolder::class) // (5)!\n    )\n\n}\n</code></pre> <ol> <li>A function that creates the <code>Network</code> based on <code>NetworkData</code>.</li> <li>A function that creates the <code>NetworkGroup</code> based on <code>NetworkGroupData</code></li> <li>A function that validates a local network (i.e. a network of two end points that are placed directly next to each other).</li> <li>The delay between network ticks.</li> <li>The holder types that <code>NetworkNodes</code> require in order to qualify for this network type.    Can be one or multiple and do not necessarily need to be custom.</li> </ol>"},{"location":"addon/tile-entity-networks/custom-network-types/#network-group","title":"Network Group","text":"<p>A <code>NetworkGroup</code> is a subset of a network cluster containing only the networks of your specific network type. The given network list is immutable and the NetworkGroup is re-created every time a network of the group is changed.</p> <p>The following implementation simply delegates the main <code>tick</code> function to all networks of the group. Depending on your needs, you may implement more complex logic here. For example, item networks take a snapshot of all inventories on a group level in order to implement item locking. There are also additional functions available that you can override in <code>NetworkGroup</code>, some of which are not called in parallel with other network clusters.</p> <p>To prevent code duplication, simply delegate the data properties to the <code>NetworkGroupData</code> that you receive in the constructor:</p> <pre><code>class ExampleNetworkGroup(data: NetworkGroupData&lt;ExampleNetwork&gt;) : NetworkGroup&lt;ExampleNetwork&gt;, NetworkGroupData&lt;ExampleNetwork&gt; by data {\n\n    override fun tick() {\n        networks.forEach(ExampleNetwork::tick)\n    }\n\n}\n</code></pre>"},{"location":"addon/tile-entity-networks/custom-network-types/#network","title":"Network","text":"<p>A <code>Network</code> is a collection of <code>NetworkNodes</code> that are directly connected to each other. The given nodes map is immutable and the network is re-created every time changes are made to its layout.</p> <p>To prevent code duplication, simply delegate the data properties to the <code>NetworkData</code> that you receive in the constructor:</p> <pre><code>class ExampleNetwork(data: NetworkData&lt;ExampleNetwork&gt;) : Network&lt;ExampleNetwork&gt;, NetworkData&lt;ExampleNetwork&gt; by data {\n\n    fun tick() {\n        // tick logic\n    }\n\n}\n</code></pre> <p>Which nodes will be part of the network?</p> <p>Generally, only network nodes that qualify for the network type will be part of networks of that type.   For bridges, this means that they were registered as supporting the given network type. For end points, this means   that they have the required data holders.</p>"},{"location":"addon/tile-entity-networks/custom-network-types/#local-network-validation","title":"Local Network Validation","text":"<p>Local networks are networks that consist of exactly two end points and no bridges. They are created when two network nodes that have the correct <code>EndPointDataHolders</code> are placed directly next to each other.</p> <p>For performance reasons, it is not optimal to always create a network between two adjacent tile-entities, because even if they have the correct end point data holders and as such qualify for your custom network type, they might not be in a state where they will actually interact with each other. (For example, if your <code>EndPointDataHolder</code> has something like a side configuration, it may be configured to <code>INSERT</code> on both sides.)</p> <p>Using the <code>validateLocal</code> function, you can prevent such networks from being created in the first place.</p> EnergyNetwork - validateLocal<pre><code>fun validateLocal(from: NetworkEndPoint, to: NetworkEndPoint, face: BlockFace): Boolean {\n    val energyHolderFrom: EnergyHolder = from.holders.firstInstanceOfOrNull&lt;EnergyHolder&gt;() ?: return false\n    val energyHolderTo: EnergyHolder = to.holders.firstInstanceOfOrNull&lt;EnergyHolder&gt;() ?: return false\n    val conFrom: NetworkConnectionType? = energyHolderFrom.connectionConfig[face]\n    val conTo: NetworkConnectionType? = energyHolderTo.connectionConfig[face.oppositeFace]\n\n    return conFrom != conTo || conFrom == NetworkConnectionType.BUFFER\n}\n</code></pre>"},{"location":"addon/tile-entity-networks/custom-network-types/#endpointdataholder","title":"EndPointDataHolder","text":"<p>A custom <code>EndPointDataHolder</code> is only required if you want to supply additional data that is not already covered by the built-in data holders <code>EnergyHolder</code>, <code>ItemHolder</code>, <code>FluidHolder</code> to the network.</p> <p><code>EndPointDataHolder</code> only has one property: <code>allowedFaces</code>, which is a set of <code>BlockFaces</code> that specifies at which sides of the block this <code>EndPointDataHolder</code> is present. As such, if your custom network type requires <code>ExampleDataHolder</code>, and, for example <code>NORTH</code> is not an allowed face, then there will never be a network of your custom type at the <code>NORTH</code> face.</p> <pre><code>class ExampleDataHolder : EndPointDataHolder {\n\n    override val allowedFaces: Set&lt;BlockFace&gt;\n        get() = TODO(\"Not yet implemented\")\n\n}\n</code></pre> <p>For reference, all built-in <code>EndPointDataHolders</code> delegate this to their <code>connectionConfig</code>: EnergyHolder (built-in), ContainerEndPointDataHolder (built-in)<pre><code>val connectionConfig: MutableMap&lt;BlockFace, NetworkConnectionType&gt;\n\noverride val allowedFaces: Set&lt;BlockFace&gt;\n    get() = connectionConfig.mapNotNullTo(enumSet()) { (face, type) -&gt;\n        if (type != NetworkConnectionType.NONE) face else null\n    }\n</code></pre></p>"},{"location":"addon/tile-entity-networks/introduction/","title":"Tile Entity Networks - Introduction","text":""},{"location":"addon/tile-entity-networks/introduction/#overview","title":"Overview","text":"<p>The following diagram is intended to give a quick overview on how Nova's network system works. For more detailed information, check out the KDocs.</p> <pre><code>classDiagram\n  note for NetworkCluster \"A collection of networks that\\nshare at least one NetworkNode.\"\n  class NetworkCluster\n\n  note for NetworkGroup \"A subset of a network cluster,\\ngrouped by network type.\"\n  class NetworkGroup {\n      &lt;&lt;interface&gt;&gt;\n  }\n\n  note for Network \"A collection of network nodes\\nthat are connected to each other.\"\n  class Network {\n      &lt;&lt;interface&gt;&gt;\n  }\n\n  class NetworkNode {\n      &lt;&lt;interface&gt;&gt;\n  }\n\n  class NetworkEndPoint {\n      &lt;&lt;interface&gt;&gt;\n  }\n\n  note for NetworkBridge \"Cables / Pipes / etc.\"\n  class NetworkBridge {\n      &lt;&lt;interface&gt;&gt;\n  }\n\n  note for EndPointDataHolder \"Holds data for a specific\\nnetwork type.\"\n  class EndPointDataHolder {\n      &lt;&lt;interface&gt;&gt;\n  }\n\n  NetworkCluster o-- NetworkGroup : contains\n  NetworkGroup o-- Network : contains\n  Network o-- NetworkNode : contains\n  NetworkNode &lt;|-- NetworkEndPoint : implements\n  NetworkNode &lt;|-- NetworkBridge : implements\n  NetworkEndPoint *-- EndPointDataHolder : contains</code></pre> <p>In most cases, you won't need to worry about the network system and will just inherit from NetworkedTileEntity to make your tile-entity network compatible.</p> Visualization: Networks vs. Network Clusters <p>(Item-)Networks <code>/nova debug showNetwork nova:item</code>: The particles visualize what network a block belongs to. As you can see, each cable section is a different network and every chest is part of two networks.</p> <p></p> <p>Network Clusters <code>/nova debug showNetworkClusters</code>: The particles visualize what network cluster a block belongs to. Since the four left networks all share chests, and the four right networks all share chests, there are only two network clusters.</p> <p></p>"},{"location":"addon/tile-entity-networks/introduction/#network-tick","title":"Network Tick","text":"<p>Most of the tick logic of networks is run in parallel with networks from other clusters:</p> <pre><code>graph TD\n    A[Server Tick] --&gt; B[Sync Network Tick\\nNetwork preparation logic that accesses world state and thus cannot be run in parallel]\n    B --&gt; C1[Cluster 1 Tick]\n    B --&gt; C2[Cluster 2 Tick]\n    B --&gt; CN[Cluster ... Tick]\n    C1 --&gt; D[Sync Network Tick\\nNetwork post-tick logic that accesses world state and thus cannot be run in parallel]\n    C2 --&gt; D\n    CN --&gt; D\n    D --&gt; E[Server Tick]\nsubgraph Parallel\n    direction LR\n    C1\n    C2\n    CN\nend</code></pre> <p>Because network tick logic is run in parallel, it is imperative that networks do not modify the world state (apart from the data stored in the NetworkNodes themselves), which also requires update handlers (for example for inventories or fluid containers) to behave in the same way.</p>"},{"location":"addon/tile-entity-networks/introduction/#default-network-types","title":"Default network types","text":"<p>By default, Nova ships with 3 network types: <code>nova:energy</code>, <code>nova:item</code> and <code>nova:fluid</code>.</p> Id EndPointDataHolder type Description <code>nova:energy</code> <code>EnergyHolder</code> Distributes energy between end points. <code>nova:item</code> <code>ItemHolder</code> Distributes items between end points. <code>nova:fluid</code> <code>FluidHolder</code> Distributes fluids between end points."},{"location":"addon/tile-entity-networks/introduction/#un-registering-networknodes","title":"(Un-)registering NetworkNodes","text":"<p>To register/unregister <code>NetworkNodes</code>, queue a network task using <code>NetworkManager</code>:</p> <pre><code>NetworkManager.queueAddEndPoint(endPoint) // registers an end point\nNetworkManager.queueAddBridge(bridge, supportedNetworkTypes) // registers a bridge\n\nNetworkManager.queueRemoveEndPoint(endPoint) // unregisters an end point\nNetworkManager.queueRemoveBridge(bridge) // unregisters a bridge\n</code></pre> <p>You'll need to add <code>NetworkNodes</code> after they've been placed and also remove them when they're destroyed. You don't need to add/remove on chunk (un-)load.</p> <p>If you're using NetworkedTileEntity, this will be done for you.</p>"},{"location":"addon/tile-entity-networks/introduction/#interacting-with-networkstate-advanced","title":"Interacting with NetworkState (advanced)","text":"<p>To interact with any network-related data (for example <code>connectionConfig</code> of <code>ItemHolder</code>), you need to queue a network task using <code>NetworkManager</code> to prevent concurrency issues. Here, you'll also obtain an instance of <code>NetworkState</code>, which gives you access to all network-related data of the given chunk's world. For more information, check out the KDocs.</p> <pre><code>NetworkManager.queueRead(chunkPos) { state: NetworkState -&gt;\n    // code that only reads from state\n}\n\nNetworkManager.queueWrite(chunkPos) { state: NetworkState -&gt;\n    // code that writes to state\n}\n\nNetworkManager.queue(chunkPos) { state: NetworkState -&gt;\n    var hasWritten = false\n    // code that may write to state\n    return@queue hasWritten\n}\n</code></pre> <p>After a network task that writes to the state was executed, dirty networks will be rebuilt.</p>"},{"location":"addon/tile-entity-networks/networked-tile-entity/","title":"NetworkedTileEntity","text":"<p><code>NetworkedTileEntity</code> inherits from <code>TileEntity</code> and <code>NetworkEndPoint</code> and provides you with an easy way to make your <code>TileEntity</code> network-compatible.</p> <pre><code>class ExampleTileEntity(\n    pos: BlockPos,\n    blockState: NovaBlockState,\n    data: Compound\n) : NetworkedTileEntity(pos, blockState, data) {\n\n}\n</code></pre>"},{"location":"addon/tile-entity-networks/networked-tile-entity/#end-point-data-holders","title":"End Point Data Holders","text":"<p>To make data available for networks, we need to add <code>EndPointDataHolders</code> to our tile-entity. For the built-in network types, there are utility functions in <code>NetworkedTileEntity</code> to easily create them from the tile-entity's internal data.</p>"},{"location":"addon/tile-entity-networks/networked-tile-entity/#energy","title":"Energy","text":"<p>Create an <code>EnergyHolder</code> via <code>NetworkedTileEntity#storedEnergyHolder</code>:</p> <pre><code>class ExampleTileEntity(pos: BlockPos, blockState: NovaBlockState, data: Compound) : NetworkedTileEntity(pos, blockState, data) {\n\n    private val energyHolder = storedEnergyHolder(\n        maxEnergy = provider(1000L), // (1)!\n        allowedConnectionType = NetworkConnectionType.BUFFER // (2)!\n    )\n\n    override fun handleTick() {\n        energyHolder.energy += 10 // (3)!\n    }\n\n}\n</code></pre> <ol> <li>The maximum amount of energy that can be stored.</li> <li>Networks can both insert and extract energy.</li> <li>Every tick, we generate 10J of energy.</li> </ol>"},{"location":"addon/tile-entity-networks/networked-tile-entity/#item","title":"Item","text":"<p>Create an <code>ItemHolder</code> via <code>NetworkedTileEntity#storedItemHolder</code>:</p> <pre><code>class ExampleTileEntity(pos: BlockPos, blockState: NovaBlockState, data: Compound) : NetworkedTileEntity(pos, blockState, data) {\n\n    private val inputInventory = storedInventory(name = \"input\", size = 9) // (1)!\n    private val outputInventory = storedInventory(name = \"output\", size = 9) // (2)!\n\n    private val itemHolder = storedItemHolder(\n        inputInventory to NetworkConnectionType.INSERT, // (3)!\n        outputInventory to NetworkConnectionType.EXTRACT // (4)!\n    )\n\n}\n</code></pre> <ol> <li>Example inventory intended for input with 9 slots.</li> <li>Example inventory intended for output with 9 slots.</li> <li>Networks can only insert into the input inventory.</li> <li>Networks can only extract from the output inventory.</li> </ol>"},{"location":"addon/tile-entity-networks/networked-tile-entity/#fluid","title":"Fluid","text":"<p>Create a <code>FluidHolder</code> via <code>NetworkedTileEntity#storedFluidHolder</code>:</p> <pre><code>class ExampleTileEntity(pos: BlockPos, blockState: NovaBlockState, data: Compound) : NetworkedTileEntity(pos, blockState, data) {\n\n    private val fluidContainer = storedFluidContainer(\n        name = \"fluidContainer\",\n        allowedTypes = setOf(FluidType.WATER), // (1)!\n        capacity = provider(10_000L) // (2)!\n    )\n\n    private val fluidHolder = storedFluidHolder(\n        fluidContainer to NetworkConnectionType.EXTRACT // (3)!\n    )\n\n    override fun handleTick() {\n        fluidContainer.addFluid(FluidType.WATER, 1_000) // (4)!\n    }\n\n}\n</code></pre> <ol> <li>The types of fluid that can be put into this container. (Only water in this case)</li> <li>The maximum amount of fluid that can be stored.</li> <li>Networks can only extract from the fluid container.</li> <li>Every tick, the fluid container replenishes by 1_000 mB of water.</li> </ol>"},{"location":"addon/tile-entity-networks/networked-tile-entity/#side-configuration-gui","title":"Side Configuration Gui","text":"<p>Using <code>SideConfigMenu</code>, we can easily add a <code>Gui</code> to our tile-entity with which we can change the side-configuration for all built-in network types:</p> <pre><code>class ExampleTileEntity(pos: BlockPos, blockState: NovaBlockState, data: Compound) : NetworkedTileEntity(pos, blockState, data) {\n\n    // end point data holders from the previous examples\n    private val energyHolder = storedEnergyHolder(provider(1000L), NetworkConnectionType.BUFFER)\n    private val inputInventory = storedInventory(\"input\", 9)\n    private val outputInventory = storedInventory(\"output\", 9)\n    private val itemHolder = storedItemHolder(inputInventory to NetworkConnectionType.INSERT, outputInventory to NetworkConnectionType.EXTRACT)\n    private val fluidContainer = storedFluidContainer(\"fluidContainer\", setOf(FluidType.WATER), provider(10_000L))\n    private val fluidHolder = storedFluidHolder(fluidContainer to NetworkConnectionType.EXTRACT)\n\n    @TileEntityMenuClass\n    inner class ExampleTileEntityMenu : GlobalTileEntityMenu() {\n\n        private val sideConfigMenu = SideConfigMenu(\n            endPoint = this@ExampleTileEntity,\n            // localization keys for inventories\n            inventories = mapOf(\n                itemHolder.getNetworkedInventory(inputInventory) to \"inventory.example_addon.input\",\n                itemHolder.getNetworkedInventory(outputInventory) to \"inventory.example_addon.output\"\n            ),\n            // localization keys for fluid contains\n            containers = mapOf(fluidContainer to \"container.example_addon.fluid_tank\"),\n            openPrevious = ::openWindow\n        )\n\n        override val gui = Gui.builder()\n            .setStructure(\n                \"s # # # # # # # #\",\n                \"# i i i # o o o #\",\n                \"# i i i # o o o #\",\n                \"# i i i # o o o #\",\n                \"# # # # # # # # #\")\n            .addIngredient('s', OpenSideConfigItem(sideConfigMenu))\n            .addIngredient('i', inputInventory)\n            .addIngredient('o', outputInventory)\n            .build()\n\n    }\n\n}\n</code></pre> <p></p> <p>Of course, nothing stops you from creating your own side-config gui.</p>"},{"location":"addon/worldgen/biome/","title":"Biomes","text":"<p>Warning</p> <p>This worldgen page is still a work in progress. Some Json formats/code examples/features might be missing and will be added in the future. Custom biomes also aren't fully supported yet. Injecting them into <code>LevelStems</code> has to be done manually for now.</p> <p>Biomes are regions in the world with distinct features, carvers, climate, effects and much more. This page only covers the <code>BiomeBuilder</code> for now. If you're looking for the Json format, check out the Minecraft Wiki.</p> <p>First, let's get into more detail on the individual components of a biome.</p>"},{"location":"addon/worldgen/biome/#climate","title":"Climate","text":"<p>As the name suggests, <code>ClimateSettings</code> determine the climate of a biome. I.e. the weather, snow behavior and temperature. The <code>BiomeClimateSettingsBuilder</code> class provides a fluent API for creating <code>ClimateSettings</code>.</p>"},{"location":"addon/worldgen/biome/#special-effects","title":"Special effects","text":"<p>The <code>BiomeSpecialEffects</code> determine the general look of a biome, including its fog, foliage, water and sky color or even ambient particles. These effects also include the ambient sounds of the biome. Check out The <code>BiomeSpecialEffectsBuilder</code> kdoc for more information.</p>"},{"location":"addon/worldgen/biome/#mob-spawn-settings","title":"Mob spawn settings","text":"<p>The <code>MobSpawnSettings</code> determine the mobs and their spawn conditions of a biome. Check out the <code>MobSpawnSettingsBuilder</code> kdoc for more information.</p>"},{"location":"addon/worldgen/biome/#example","title":"Example","text":"Biomes.kt<pre><code>@OptIn(ExperimentalWorldGen::class)\n@Init(stage = InitStage.POST_PACK_PRE_WORLD)\nobject Biomes : BiomeRegistry by ExampleAddon.registry {\n\n    private val MISC_ORES = listOf(OrePlacements.ORE_DIRT, OrePlacements.ORE_GRAVEL, OrePlacements.ORE_GRANITE_UPPER, OrePlacements.ORE_GRANITE_LOWER, OrePlacements.ORE_DIORITE_UPPER, OrePlacements.ORE_DIORITE_LOWER, OrePlacements.ORE_ANDESITE_UPPER, OrePlacements.ORE_ANDESITE_LOWER, OrePlacements.ORE_TUFF)\n    private val MINERAL_ORES = listOf(OrePlacements.ORE_COAL_UPPER, OrePlacements.ORE_COAL_LOWER, OrePlacements.ORE_IRON_UPPER, OrePlacements.ORE_IRON_MIDDLE, OrePlacements.ORE_IRON_SMALL, OrePlacements.ORE_GOLD, OrePlacements.ORE_GOLD_LOWER, OrePlacements.ORE_REDSTONE, OrePlacements.ORE_REDSTONE_LOWER, OrePlacements.ORE_DIAMOND, OrePlacements.ORE_DIAMOND_LARGE, OrePlacements.ORE_DIAMOND_BURIED, OrePlacements.ORE_LAPIS, OrePlacements.ORE_LAPIS_BURIED, OrePlacements.ORE_COPPER)\n    private val DECORATION_ORES = listOf(CavePlacements.UNDERWATER_MAGMA, MiscOverworldPlacements.DISK_SAND, MiscOverworldPlacements.DISK_CLAY, MiscOverworldPlacements.DISK_GRAVEL)\n\n    val PLAINS = biome(\"plains\")\n        .carvers(Carving.AIR, Carvers.CAVE, Carvers.CAVE_EXTRA_UNDERGROUND, Carvers.CANYON)\n        .features(Decoration.LAKES, MiscOverworldPlacements.LAKE_LAVA_SURFACE, MiscOverworldPlacements.LAKE_LAVA_UNDERGROUND)\n        .feature(Decoration.LOCAL_MODIFICATIONS, CavePlacements.AMETHYST_GEODE)\n        .features(Decoration.UNDERGROUND_STRUCTURES, CavePlacements.MONSTER_ROOM, CavePlacements.MONSTER_ROOM_DEEP)\n        .features(Decoration.UNDERGROUND_ORES, *(MISC_ORES + MINERAL_ORES + DECORATION_ORES).toTypedArray())\n        .features(Decoration.FLUID_SPRINGS, MiscOverworldPlacements.SPRING_LAVA, MiscOverworldPlacements.SPRING_WATER)\n        .features(Decoration.VEGETAL_DECORATION, CavePlacements.GLOW_LICHEN, VegetationPlacements.PATCH_TALL_GRASS_2, VegetationPlacements.TREES_PLAINS, VegetationPlacements.FLOWER_PLAINS, VegetationPlacements.PATCH_GRASS_PLAIN, VegetationPlacements.BROWN_MUSHROOM_NORMAL, VegetationPlacements.RED_MUSHROOM_NORMAL, VegetationPlacements.PATCH_SUGAR_CANE, VegetationPlacements.PATCH_PUMPKIN)\n        .feature(Decoration.TOP_LAYER_MODIFICATION, MiscOverworldPlacements.FREEZE_TOP_LAYER)\n        .climateSettings {\n            downfall(.4f)\n            hasPrecipitation(true)\n            temperature(.8f)\n        }\n        .specialEffects {\n            fogColor(0xC0D8FF)\n            skyColor(0x78A7FF)\n            waterColor(0x3F76E4)\n            waterFogColor(0x050533)\n            ambientMoodSound {\n                blockSearchExtent(8)\n                soundPositionOffset(2.0)\n                soundEvent(SoundEvents.AMBIENT_CAVE)\n                tickDelay(6000)\n            }\n        }\n        .mobSpawnSettings {\n            addSpawn(MobCategory.AMBIENT, EntityType.BAT, minGroupSize = 8, maxGroupSize = 8, weight = 10)\n\n            addSpawn(MobCategory.CREATURE, EntityType.SHEEP, minGroupSize = 4, maxGroupSize = 4, weight = 12)\n            addSpawn(MobCategory.CREATURE, EntityType.PIG, minGroupSize = 4, maxGroupSize = 4, weight = 10)\n            addSpawn(MobCategory.CREATURE, EntityType.CHICKEN, minGroupSize = 4, maxGroupSize = 4, weight = 10)\n            addSpawn(MobCategory.CREATURE, EntityType.COW, minGroupSize = 4, maxGroupSize = 4, weight = 8)\n            addSpawn(MobCategory.CREATURE, EntityType.HORSE, minGroupSize = 2, maxGroupSize = 6, weight = 5)\n            addSpawn(MobCategory.CREATURE, EntityType.DONKEY, minGroupSize = 1, maxGroupSize = 3, weight = 1)\n\n            addSpawn(MobCategory.MONSTER, EntityType.SPIDER, minGroupSize = 4, maxGroupSize = 4, weight = 100)\n            addSpawn(MobCategory.MONSTER, EntityType.ZOMBIE, minGroupSize = 4, maxGroupSize = 4, weight = 95)\n            addSpawn(MobCategory.MONSTER, EntityType.ZOMBIE_VILLAGER, minGroupSize = 1, maxGroupSize = 1, weight = 5)\n            addSpawn(MobCategory.MONSTER, EntityType.SKELETON, minGroupSize = 4, maxGroupSize = 4, weight = 100)\n            addSpawn(MobCategory.MONSTER, EntityType.CREEPER, minGroupSize = 4, maxGroupSize = 4, weight = 100)\n            addSpawn(MobCategory.MONSTER, EntityType.SLIME, minGroupSize = 4, maxGroupSize = 4, weight = 100)\n            addSpawn(MobCategory.MONSTER, EntityType.ENDERMAN, minGroupSize = 1, maxGroupSize = 4, weight = 10)\n            addSpawn(MobCategory.MONSTER, EntityType.WITCH, minGroupSize = 1, maxGroupSize = 1, weight = 5)\n\n            addSpawn(MobCategory.WATER_CREATURE, EntityType.GLOW_SQUID, minGroupSize = 4, maxGroupSize = 6, weight = 10)\n        }\n        .register()\n\n}\n</code></pre>"},{"location":"addon/worldgen/carver/","title":"Carvers","text":"<p>Warning</p> <p>This worldgen page is still a work in progress. Some Json formats/code examples/features might be missing and will be added in the future.</p> <p>TODO - Check out the Minecraft Wiki in the meantime.</p>"},{"location":"addon/worldgen/codec/","title":"Codecs","text":"<p><code>Codecs</code> are Mojang's way of serializing and deserializing objects via Json and NBT. They are relevant in world generation because they are used to deserialize pretty much every aspect of datapack-supported world generation. In simpler terms, a <code>Codec</code> is pretty much just a <code>Encoder</code> and <code>Decoder</code> combined defining how to serialize and deserialize an object into primitive types. (1) So here's a quick overview on how to use them.</p> <ol> <li>Minecraft also includes a ton of other default <code>Codecs</code> in the <code>ExtraCodecs</code> class. Make sure to check it out as well!</li> </ol>"},{"location":"addon/worldgen/codec/#dataresults","title":"DataResults","text":"<p>Before getting into <code>Codecs</code>, we need to take a look at <code>DataResults</code>. A <code>DataResult</code> is pretty much just a fancier version of Kotlin's <code>Result</code> type. They either contain a value or an error. The difference is that <code>DataResult's</code> can contain a so called <code>PartialResult</code> (which often is just the input value or a partially deserialized value). <code>Codecs</code> can be adapted to serialize/deserialize using <code>DataResults</code> using the following functions:</p> <ul> <li><code>Codec.comapFlatMap</code> - Deserialize into a <code>DataResult</code> but serialize normally.</li> <li><code>Codec.flatComapMap</code> - Serialize into a <code>DataResult</code> but deserialize normally.</li> <li><code>Codec.flatXmap</code> - Serialize and deserialize into a <code>DataResult</code>.</li> </ul> <p>Keep these functions in mind for the following examples.</p> <p>Tip</p> <p>Nova also has a <code>Result&lt;R&gt;.asDataResult()</code> extension function to convert Kotlin's <code>Result</code> into a <code>DataResult</code>. So for a convenient way to safely deserialize a value and return a <code>DataResult</code>, you can run <code>runCatching { /* ... */ }.asDataResult()</code></p>"},{"location":"addon/worldgen/codec/#dynamicops","title":"DynamicOps","text":"<p><code>DynamicOps</code> are Mojang's way of abstracting away the difference between different serialization formats. DFU includes <code>JsonOps</code> by default. Minecraft adds <code>NbtOps</code> and <code>RegistryOps</code>. <code>DynamicOps</code> are used to define the format in which primitive types are serialized and deserialized. All other types are built on top of these primitive types.</p> Number types implementation in <code>JsonOps</code> <p>For example, to serialize/deserialize numbers, <code>DynamicOps</code> defines the <code>createNumeric</code>  and <code>getNumberValue</code> functions. <code>JsonOps</code> implements these functions like this:</p> JsonOps.java<pre><code>public JsonElement createNumeric(Number i) {\n    return new JsonPrimitive(i);\n}\n\npublic DataResult&lt;Number&gt; getNumberValue(JsonElement input) {\n    if (input instanceof JsonPrimitive) {\n        if (input.getAsJsonPrimitive().isNumber()) {\n            return DataResult.success(input.getAsNumber());\n        }\n\n        if (input.getAsJsonPrimitive().isBoolean()) {\n            return DataResult.success(input.getAsBoolean() ? 1 : 0);\n        }\n\n        if (this.compressed &amp;&amp; input.getAsJsonPrimitive().isString()) {\n            try {\n                return DataResult.success(Integer.parseInt(input.getAsString()));\n            } catch (NumberFormatException var3) {\n                return DataResult.error(\"Not a number: \" + var3 + \" \" + input);\n            }\n        }\n    }\n\n    return input instanceof JsonPrimitive &amp;&amp; input.getAsJsonPrimitive().isBoolean() ? DataResult.success(input.getAsJsonPrimitive().getAsBoolean() ? 1 : 0) : DataResult.error(\"Not a number: \" + input);\n}\n</code></pre>"},{"location":"addon/worldgen/codec/#codecs-for-simple-types","title":"Codecs for simple types.","text":"<p>For classes that can be defined as a single type, a preexisting <code>PrimitveCodec</code> should be used to define the <code>Codec</code> for that type. A simple example would be a <code>Codec</code> for Minecraft's <code>ResourceLocation</code>. Since a <code>ResourceLocation</code> can be  constructed from a single <code>String</code>, we can use the preexisting <code>Codec.String</code> to define our <code>Codec</code>.</p> ResourceLocation implementation used for this example <p>To simplify, here's a more basic implementation of <code>ResourceLocation</code>:</p> ResourceLocation.kt<pre><code>data class ResourceLocation(\n    val namespace: String,\n    val location: String\n) {\n\n    override fun toString(): String {\n        return \"$namespace:$location\"\n    }\n\n    companion object {\n\n        /**\n         * Matches any lowercase alphanumeric (and `_`) string that starts with a lowercase letter\n         */\n        val PART_PATTERN = Regex(\"\"\"^[a-z][a-z\\d_]*$\"\"\")\n\n        /**\n         * Matches the Pattern [PART_PATTERN] twice separated by a colon\n         */\n        val COMPLETE_PATTERN = Regex(\"\"\"^[a-z][a-z\\d_]*:[a-z][a-z\\d_]*$\"\"\")\n\n        fun read(id: String): DataResult&lt;ResourceLocation&gt; {\n            val namespace: String\n            val location: String\n\n            if (id.matches(COMPLETE_PATTERN)) {\n                val parts = id.split(':')\n                namespace = parts[0]\n                location = parts[1]\n            } else if (id.matches(PART_PATTERN)) {\n                namespace = \"minecraft\"\n                location = id\n            } else {\n                return DataResult.error { \"ResourceLocation \\\"$id\\\" does neither match pattern $COMPLETE_PATTERN nor $PART_PATTERN\" }\n            }\n\n            return DataResult.success(ResourceLocation(namespace, location))\n        }\n\n    }\n\n}\n</code></pre> ResourceLocation.kt<pre><code>val CODEC: Codec&lt;ResourceLocation&gt; =\n    Codec.STRING // (1)!\n        .comapFlatMap(ResourceLocation::read, ResourceLocation::toString) // (2)!\n        .stable() // (3)!\n</code></pre> <ol> <li>As mentioned above, we can use the preexisting <code>Codec.String</code> to define our <code>Codec</code> since we only need a single string to parse the <code>ResourceLocation</code>.</li> <li>We use <code>comapFlatMap</code> to deserialize into a <code>DataResult</code> and serialize normally (Calling <code>toString</code> shouldn't fail).    Also use <code>read</code> to deserialize the <code>ResourceLocation</code> from the provided <code>String</code>.</li> <li>Specify that the <code>Codec</code> is stable.</li> </ol> <p>So in other words, we're now just telling the serializer how to serialize and deserialize our <code>ResourceLocation</code> type  to/from a <code>String</code>.</p>"},{"location":"addon/worldgen/codec/#codecs-for-more-nested-types","title":"Codecs for more nested types","text":"<p>In the previous example, we just mapped a preexisting <code>Codec</code> to our type. But what if we want to define a <code>Codec</code> for a more complex type with multiple fields? For this, we can use <code>RecordCodecBuilder</code> to define a <code>Codec</code> for our type. Here's the <code>data class</code> we want to define a <code>Codec</code> for:</p> <pre><code>data class Example(\n    val id: ResourceLocation,\n    val ints: List&lt;Int&gt;,\n    val defaultString: String\n)\n</code></pre> <p>So let's break this type down into its parts. We can see that <code>Example</code> has three fields: <code>id</code>, <code>ints</code> and <code>defaultString</code>.  </p> <code>id</code> <p><code>id</code> is a <code>ResourceLocation</code> which we already know how to serialize/deserialize. So we can just use our previously  defined Codec` again:</p> <pre><code>ResourceLocation.CODEC // (1)!\n    .fieldOf(\"id\") // (2)!\n    .forGetter(Example::id) // (3)!\n</code></pre> <ol> <li>Use the previously defined <code>Codec</code> for <code>ResourceLocation</code>.</li> <li>Specify the name of the field in the serialized format.</li> <li>Specify how to get the value of the field from the <code>Example</code> instance.</li> </ol> <code>ints</code> <p><code>ints</code> is a <code>List&lt;Int&gt;</code> which is just a list of the primitive type <code>Int</code>. So we can just call <code>Codec.INT.listOf()</code> to define a <code>Codec</code> for <code>List&lt;Int&gt;</code>:</p> <pre><code>Codec.INT.listOf() // (1)!\n    .fieldOf(\"ints\") // (2)!\n    .forGetter(Example::ints) // (3)!\n</code></pre> <ol> <li>Use the <code>listOf</code> function on <code>Codec.INT</code> to define a <code>Codec</code> for <code>List&lt;Int&gt;</code>.</li> <li>Specify the name of the field in the serialized format.</li> <li>Specify how to get the value of the field from the <code>Example</code> instance.</li> </ol> <code>defaultString</code> <p><code>defaultString</code> is a <code>String</code> which is a primitive type. But we want to make it optional with a default value of <code>\"default\"</code>. So we can use <code>Codec.STRING.optionalFieldOf</code> to define a <code>Codec</code> for <code>String</code> with a default value:</p> <pre><code>Codec.STRING // (1)!\n    .optionalFieldOf(\"defaultString\", \"default\") // (2)!\n    .forGetter(Example::defaultString) // (3)!\n</code></pre> <ol> <li>Use the existing <code>Codec.STRING</code> for <code>String</code>.</li> <li>Specify the name of the field in the serialized format and the default value.    To specifiy a default-value for a non <code>MapCodec</code> use <code>Codec.String.orElse(\"default\")</code>.</li> <li>Specify how to get the value of the field from the <code>Example</code> instance.</li> </ol> <p>Putting all these together, we can now define a <code>Codec</code> for our <code>Example</code> type:</p> <pre><code>val CODEC: Codec&lt;Example&gt; = RecordCodecBuilder.create { instance -&gt;\n   instance.group(\n           ResourceLocation.CODEC.fieldOf(\"id\").forGetter(Example::id),\n           Codec.INT.listOf().fieldOf(\"ints\").forGetter(Example::ints),\n           Codec.STRING\n              .optionalFieldOf(\"defaultString\", \"default\")\n              .forGetter(Example::defaultString)\n   ).apply(instance, ::Example)\n}\n</code></pre> <ol> <li>List all the fields of the <code>Example</code> type.</li> <li>Apply the fields to the <code>RecordCodecBuilder</code> instance and use the <code>::Example</code> constructor reference to specify how to    construct an <code>Example</code> instance from the defined fields.</li> </ol> <p>So let's test it out by serializing and deserializing an <code>Example</code> instance:</p> <pre><code>val testId = ResourceLocation(\"minecraft\", \"stone\")\nval test = Example(testId, listOf(1, 2, 3), \"hello\")\n</code></pre> <p>Using our <code>Codec</code> and <code>JsonOps</code>:</p> <pre><code>{\n  \"id\": \"minecraft:stone\",\n  \"ints\": [1, 2, 3],\n  \"defaultString\": \"hello\"\n}\n</code></pre> <p>And now let's deserialize the same json, but without the <code>defaultString</code> field. And the result is:</p> <pre><code>Example(id=minecraft:stone, ints=[1, 2, 3], defaultString=default)\n</code></pre>"},{"location":"addon/worldgen/codec/#registry-codecs","title":"Registry Codecs","text":""},{"location":"addon/worldgen/codec/#minecraftnova-registries","title":"Minecraft/Nova registries","text":"<p>If you want to retrieve an instance of a type that is registered in one of Minecraft's/Nova's registries, you can use the <code>Registry.byNameCodec</code> function. This will automatically build a <code>Codec</code> that will serialize/deserialize a <code>ResourceLocation</code> and then use that <code>ResourceLocation</code> to retrieve the instance from the <code>Registry</code>. (<code>holderByNameCodec</code> also exists if you need a <code>Holder</code> instead of an instance).</p> <p>If you also want to allow the <code>Codec</code> to serialize/deserialize inline, you can use the <code>RegistryFileCodec</code> class. For example, the <code>ConfiguredFeature</code> class has both a <code>DIRECT_CODEC</code>, which only deserializes inline and a <code>CODEC</code>, which also checks the <code>Registry</code> if the deserialized type is a <code>ResourceLocation</code>:</p> <pre><code>public static final Codec&lt;ConfiguredFeature&lt;?, ?&gt;&gt; DIRECT_CODEC = BuiltInRegistries.FEATURE.byNameCodec().dispatch((config) -&gt; { // (1)!\n    return config.feature;\n}, Feature::configuredCodec);\n\npublic static final Codec&lt;Holder&lt;ConfiguredFeature&lt;?, ?&gt;&gt;&gt; CODEC = RegistryFileCodec.create(Registries.CONFIGURED_FEATURE, DIRECT_CODEC);\n</code></pre> <ol> <li>Checks the individual <code>ConfiguredFeature</code> <code>Codecs</code> of each <code>Feature</code>.</li> </ol>"},{"location":"addon/worldgen/codec/#custom-registry-like-types","title":"Custom registry-like types","text":"<p>If you want to define a <code>Codec</code> for a custom type that is registered in a custom registry-like type, you can use the <code>ExtraCodecs.stringResolverCodec</code> and <code>ExtraCodecs.idResolverCodec</code> functions. These functions take 2 mapping <code>Functions</code> as parameters: one for element to id and one for id to element (since primitives aren't nullable in Java, the <code>idResolverCodec</code> function also takes a <code>int</code> that represent the id of non-existing elements).</p> <p>For example, let's say we have a custom <code>Registry</code> that maps <code>String</code> to a generic <code>T</code>:</p> <pre><code>class SimpleRegistry&lt;T : Any&gt; {\n\n    private val byId: MutableMap&lt;String, T&gt; = mutableMapOf()\n    private val byValue: MutableMap&lt;T, String&gt; = mutableMapOf()\n\n    fun register(id: String, value: T) {\n        byId[id] = value\n        byValue[value] = id\n    }\n\n}\n</code></pre> <p>We can define a <code>codec</code> function:</p> <pre><code>fun codec(): Codec&lt;T&gt; {\n    return ExtraCodecs.stringResolverCodec(byValue::get, byId::get)\n}\n</code></pre>"},{"location":"addon/worldgen/codec/#enums","title":"Enums","text":"<p>Minecraft also provides a built-in way of serializing/deserializing enums. Just implement the <code>StringRepresentable</code> interface and implement the <code>getSerializedName</code> function:</p> <pre><code>enum class ExampleEnum: StringRepresentable {\n    A, B, C;\n\n    override fun getSerializedName() = this.name\n\n    companion object {\n        val VALUES = values()\n    }\n}\n</code></pre> <p>Now we can call <code>StringRepresentable.fromEnum</code> to get a <code>Codec</code> for our enum:</p> <pre><code>companion object {\n    val VALUES = values()\n\n    val CODEC = StringRepresentable.fromEnum(::VALUES)\n}\n</code></pre>"},{"location":"addon/worldgen/codec/#more-utilities","title":"More utilities","text":"<p>Note</p> <p>This section isn't required to properly use <code>Codecs</code>, but it contains a lot of useful utilities that might save you some time in the future.</p>"},{"location":"addon/worldgen/codec/#eitherxor","title":"Either/Xor","text":"<p>If your <code>Codec</code> should be able to serialize/deserialize 2 different types, you can use the <code>Codec.either</code> function  (or <code>EitherCodec</code> class) to define a <code>Codec</code> that can serialize/deserialize both types. One common use case is accepting both a <code>ResourceLocation</code> and a <code>TagKey</code>:</p> <p>Already built into Nova</p> <p>Nova already provides a <code>ResourceLocationOrTagKey</code> class that wraps an <code>Either&lt;ResourceLocation, TagKey&lt;T&gt;&gt;</code> and provides a <code>Codec</code> via the <code>codec</code> function.</p> <pre><code>val CODEC: Codec&lt;Either&lt;ResourceLocation, TagKey&lt;Biome&gt;&gt;&gt; = Codec.either(\n    ResourceLocation.CODEC,\n    TagKey.hashedCodec(Registries.BIOME)\n)\n</code></pre> <p>If you only want to allow one of the types (sometimes both types could be deserialized and lead to confusion), you can use the <code>ExtraCodecs.xor</code> function:</p> <pre><code>val CODEC: Codec&lt;Either&lt;ResourceLocation, TagKey&lt;Biome&gt;&gt;&gt; = ExtraCodecs.xor( // (1)!\n    ResourceLocation.CODEC,\n    TagKey.hashedCodec(Registries.BIOME)\n)\n</code></pre> <ol> <li>Please note that this is redundant here since <code>TagKey</code> needs to start with <code>#</code> and <code>ResourceLocation</code> can't start     with <code>#</code>. But it can be useful for other types.</li> </ol>"},{"location":"addon/worldgen/codec/#number-codecs-within-a-range","title":"Number codecs within a range","text":"<p>If you want to serialize/deserialize a number but only within a certain range, you can use the <code>Codec.intRange</code>, <code>Codec.floatRange</code> and <code>Codec.doubleRange</code> functions:</p> <pre><code>val CHANCE_CODEC: Codec&lt;Float&gt; = Codec.floatRange(0.0f, 1.0f)\n</code></pre>"},{"location":"addon/worldgen/codec/#pair-like-types","title":"Pair like types","text":"<p>Some types might usually need a <code>RecordCodecBuilder</code> to be serialized/deserialized, but if they only have 2 fields of the same type, you can use the <code>ExtraCodecs.intervalCodec</code> function:</p> IntRange Codec<pre><code>val INT_RANGE_CODEC: Codec&lt;IntRange&gt; = ExtraCodecs.intervalCodec(\n    Codec.INT,\n    \"min_inclusive\",\n    \"max_inclusive\",\n    { min, max -&gt; runCatching { IntRange(min, max) }.asDataResult() },\n    IntRange::start,\n    IntRange::endInclusive\n)\n</code></pre>"},{"location":"addon/worldgen/codec/#catching-exceptions","title":"Catching Exceptions","text":"<p>If you don't want to deal with <code>DataResults</code> while decoding and just want to throw exceptions instead, you can wrap your <code>Codec</code> via the <code>ExtraCodecs.catchDecoderException</code> function:</p> <pre><code>val CODEC: Codec&lt;Example&gt; = ExtraCodecs.catchDecoderException(Example.CODEC)\n</code></pre> <p>this will catch any <code>Exceptions</code> thrown while decoding and turn them into <code>DataResult</code> errors.</p>"},{"location":"addon/worldgen/worldgen/","title":"World Generation Overview","text":"<p>Nova's worldgen is completely based on Minecraft's custom worldgen format with some additions. However, you can also register everything worldgen-related in code if you don't want to use Json. If you  do decide to use Json files, make sure to create a <code>data/worldgen</code> directory in your addon's resources folder before you  start. This is where all your worldgen files will be stored.</p> <p>Below you'll find a quick overview of the format how to use it. Check the sidebar for more detailed information.</p>"},{"location":"addon/worldgen/worldgen/#structures","title":"Structures","text":"<p>Structures are used to generate structures or connected structures in the world (e.g. jungle temple, villages, etc.). Currently not fully supported.</p>"},{"location":"addon/worldgen/worldgen/#features","title":"Features","text":"<p>Check out the <code>Features</code> Overview page for more information.</p> <p>Features (sometimes also called decorators) are used to add additional decorations to the world (e.g. trees, ores, etc.).</p>"},{"location":"addon/worldgen/worldgen/#carvers","title":"Carvers","text":"<p>Check out the <code>Carvers</code> Overview page for more information.</p> <p>Carvers are used to carve out caves and ravines in the world.</p>"},{"location":"addon/worldgen/worldgen/#noise","title":"Noise","text":"<p>Noise setting are responsible for generating the terrain of worlds and determines which blocks to use. Because Nova's region file format is currently pretty inefficient, these settings aren't currently supported.</p>"},{"location":"addon/worldgen/worldgen/#biomes","title":"Biomes","text":"<p>Check out the <code>Biomes</code> and <code>BiomeInjections</code> page for more information.</p> <p>Biomes are regions in the world with distinct features, carvers,  climate, effects and much more.</p> <p>If you want to add <code>PlacedFeatures</code> to an already existing biome, check out the <code>BiomeInjections</code> page.</p>"},{"location":"addon/worldgen/worldgen/#custom-dimensions","title":"Custom Dimensions","text":"<p>TODO</p>"},{"location":"addon/worldgen/features/custom-feature/","title":"Custom Features","text":"<p>Check out the <code>Codecs</code> page</p> <p>Make sure to check out the Codecs page before creating a custom feature.</p>"},{"location":"addon/worldgen/features/custom-feature/#1-empty-feature","title":"1. Empty Feature","text":"<p>To create a custom feature, you'll need to create a new object and extend Nova's <code>FeatureType</code> class. This class needs a <code>Codec</code> for your feature configuration in the constructor, but you can just leave a <code>TODO()</code> call there  for now. You'll also need a <code>FeatureConfiguration</code> class (unless a pre-existing one fits your needs).</p> <p>So let's keep everything empty for now:</p> ExampleFeature.kt<pre><code>object ExampleFeature : FeatureType&lt;ExampleFeatureConfig&gt;(TODO()) {\n\n    override fun place(ctx: FeaturePlaceContext&lt;ExampleFeatureConfig&gt;): Boolean {\n        TODO()\n    }\n\n}\n\nclass ExampleConfiguration : FeatureConfiguration\n</code></pre>"},{"location":"addon/worldgen/features/custom-feature/#2-configuration","title":"2. Configuration","text":"<p>For this example, we'll create a feature that generates a cuboid of blocks. We'll make the height, width and block of the cuboid configurable. Let's also change our configuration class to a <code>data class</code>.</p> ExampleFeature.kt<pre><code>data class ExampleConfiguration(\n    val blockState: BlockStateProvider,\n    val height: IntProvider,\n    val width: IntProvider\n) : FeatureConfiguration\n</code></pre>"},{"location":"addon/worldgen/features/custom-feature/#3-codec","title":"3. Codec","text":"<p>Now we just need to add a <code>Codec</code> to tell Minecraft how to deserialize our configuration.</p> ExampleFeature.kt<pre><code>data class ExampleConfiguration(\n    val blockState: BlockStateProvider,\n    val height: IntProvider,\n    val width: IntProvider\n) : FeatureConfiguration {\n\n    companion object {\n\n        @JvmField\n        val CODEC: Codec&lt;ExampleConfiguration&gt; = RecordCodecBuilder.create { instance -&gt;\n            instance.group(\n                BlockStateProvider.CODEC.fieldOf(\"state\").forGetter(ExampleConfiguration::blockState), // (1)!\n                IntProvider.codec(1, 16).fieldOf(\"height\").forGetter(ExampleConfiguration::height), // (2)!\n                IntProvider.codec(1, 16).fieldOf(\"width\").forGetter(ExampleConfiguration::width)\n            ).apply(instance, ::ExampleConfiguration)\n        }\n\n    }\n\n}\n</code></pre> <ol> <li>Use the <code>BlockStateProvider</code> <code>Codec</code> to deserialize the <code>blockState</code> field.    If you only want to support Nova's <code>BlockNovaMaterial</code>, you can use <code>BlockNovaMaterial.CODEC</code> instead.</li> <li>Use the <code>Codec</code> of <code>IntProvider</code> to deserialize the <code>height</code> and <code>width</code> fields. The <code>codec</code> method takes a minimum     and maximum value, which will be used to clamp the value if it's outside the range (Only enforced for deserialized     IntProviders!).</li> </ol> <p>Now we can pass the <code>CODEC</code> field to the <code>FeatureType</code> constructor.</p> ExampleFeature.kt<pre><code>object ExampleFeature : FeatureType&lt;ExampleConfiguration&gt;(ExampleConfiguration.CODEC) { /* ... */ }\n</code></pre>"},{"location":"addon/worldgen/features/custom-feature/#4-place-function","title":"4. Place function","text":"<p>Finally, we can implement the <code>place</code> function. This function is called for each position returned by the  <code>PlacementModifiers</code>defined in the outer <code>PlacedFeature</code>. The <code>FeaturePlaceContext</code> contains, as the name suggests, the context of the feature placement. This includes the  <code>origin</code> (the position of the feature), the <code>level</code>, a <code>random</code> instance and the <code>config</code> (our configuration). If the feature is used in another feature (For example, the <code>minecraft:random_selector</code> feature), that feature can also be accessed through the <code>topFeature</code> method.</p> <p>Random usage</p> <p>To ensure consistency for the same seed across worlds, you should only use the <code>random</code> instance provided by the <code>FeaturePlaceContext</code>. Do not use <code>Random</code> or <code>ThreadLocalRandom</code> directly.</p> <p>If you have a <code>BlockNovaMaterial</code> or Bukkit <code>Material</code> you want to place, you can use the <code>setBlock</code> method of the <code>FeatureType</code> class.</p> ExampleFeature.kt<pre><code>object ExampleFeature : FeatureType&lt;ExampleConfiguration&gt;(ExampleConfiguration.CODEC) {\n\n   override fun place(ctx: FeaturePlaceContext&lt;ExampleConfiguration&gt;): Boolean {\n      val config = ctx.config()\n      val random = ctx.random()\n      val level = ctx.level()\n      val pos = ctx.origin().mutable()\n\n      val width = config.width.sample(random)\n      val height = config.height.sample(random)\n      val stateProvider = config.blockState\n\n      for (x in -width / 2 until width / 2 + (width % 2)) {\n         for (y in -height / 2 until height / 2 + (height % 2)) {\n            for (z in -width / 2 until width / 2 + (width % 2)) {\n               val state = stateProvider.getState(random, pos)\n               pos.setWithOffset(ctx.origin(), x, y, z)\n               setBlock(level, pos, state)\n            }\n         }\n      }\n\n      return true // (1)!\n   }\n\n}\n</code></pre> <ol> <li>Feature was placed successfully.</li> </ol>"},{"location":"addon/worldgen/features/custom-feature/#5-registering-the-feature","title":"5. Registering the feature","text":"<p>Now we can register the feature type using Nova's <code>FeatureRegistry</code>.</p> FeatureTypes.kt<pre><code>@OptIn(ExperimentalWorldGen::class)\n@Init(stage = InitStage.POST_PACK_PRE_WORLD)\nobject FeatureTypes : FeatureRegistry by ExampleAddon.registry {\n\n    val EXAMPLE = registerFeatureType(\"example\", ExampleFeature)\n\n}\n</code></pre>"},{"location":"addon/worldgen/features/custom-feature/#6-using-the-feature","title":"6. Using the feature","text":"<p>We can now properly use our newly defined feature.</p> KotlinJson <p>First, let's create our <code>ConfiguredFeature</code> using the previously defined <code>ExampleConfiguration</code>:</p> ConfiguredFeatures.kt<pre><code>@OptIn(ExperimentalWorldGen::class)\n@Init(stage = InitStage.POST_PACK_PRE_WORLD)\nobject ConfiguredFeatures : FeatureRegistry by ExampleAddon.registry {\n\n    val EXAMPLE = registerConfiguredFeature(\n        \"example\",\n        FeatureTypes.EXAMPLE,\n        ExampleConfiguration( // (1)!\n            BlockStateProvider.simple(WrapperBlock(Blocks.STAR_SHARDS_ORE)),\n            height = UniformInt.of(1, 3),\n            width = UniformInt.of(1, 3)\n        )\n    )\n\n}\n</code></pre> <ol> <li>A cuboid of star shards ore with a random height and width between 1 and 3.</li> </ol> <p>And now just register our <code>PlacedFeature</code>:</p> <pre><code>@OptIn(ExperimentalWorldGen::class)\n@Init(stage = InitStage.POST_PACK_PRE_WORLD)\nobject PlacedFeatures : FeatureRegistry by ExampleAddon.registry {\n\n    val EXAMPLE = placedFeature(\"example\", ConfiguredFeatures.EXAMPLE)\n        .rarityFilter(10)\n        .moveToWorldSurface()\n        .randomVerticalOffset(10)\n        .biomeFilter()\n        .register()\n\n}\n</code></pre> <p>Finally, we can add our <code>PlacedFeature</code> to a biome. For this example, let's add it to all overworld biomes using <code>BiomeInjections</code>:</p> <pre><code>@OptIn(ExperimentalWorldGen::class)\n@Init(stage = InitStage.POST_PACK_PRE_WORLD)\nobject BiomeInjections : BiomeRegistry by ExampleAddon.registry {\n\n    val OVERWORLD_INJECTIONS = biomeInjection(\"overworld_injections\")\n        .biomes(BiomeTags.IS_OVERWORLD)\n        .feature(GenerationStep.Decoration.VEGETAL_DECORATION, PlacedFeatures.EXAMPLE)\n        .register()\n\n}\n</code></pre> <p>First, let's create our <code>ConfiguredFeature</code>:</p> configured_Feature/example.json<pre><code>{\n  \"type\": \"machines:example\",\n  \"config\": { // (1)!\n    \"state\": {\n      \"Name\": \"machines:star_shards_ore\"\n    },\n    \"height\": {\n      \"type\": \"minecraft:uniform\",\n      \"min_inclusive\": 1,\n      \"max_inclusive\": 3\n    },\n    \"width\": {\n      \"type\": \"minecraft:uniform\",\n      \"min_inclusive\": 1,\n      \"max_inclusive\": 3\n    }\n  }\n}\n</code></pre> <ol> <li>A cuboid of star shards ore with a random height and width between 1 and 3.</li> </ol> <p>And now just register our <code>PlacedFeature</code>:</p> placed_feature/example.json<pre><code>{\n   \"feature\": \"machines:example\",\n   \"placement\": [\n      {\n         \"type\": \"minecraft:rarity_filter\",\n         \"chance\": 10\n      },\n      {\n         \"type\": \"minecraft:heightmap\",\n         \"heightmap\": \"WORLD_SURFACE_WG\"\n      },\n      {\n         \"type\": \"minecraft:random_offset\",\n         \"xz_spread\": 0,\n         \"y_spread\": 10\n      }\n   ]\n}\n</code></pre> <p>Finally, we can add our <code>PlacedFeature</code> to a biome. For this example, let's add it to all overworld biomes using <code>BiomeInjections</code>:</p> <pre><code>{\n  \"biomes\": \"#minecraft:is_overworld\",\n  \"features\": [\n    [],\n    [],\n    [],\n    [],\n    [],\n    [],\n    [],\n    [],\n    [],\n    [\n       \"machines:example\"\n    ],\n    []\n  ]\n}\n</code></pre>"},{"location":"addon/worldgen/features/custom-feature/#7-result","title":"7. Result","text":"<p>And that's it! We now have a fully functional feature that's generated in the overworld.</p> <p></p>"},{"location":"addon/worldgen/features/features/","title":"Features Overview","text":"<p>Features (sometimes also called decorators) are used to add additional decorations to the world (e.g. trees, ores, etc.). Most features are registered in 3 \"steps\":</p>"},{"location":"addon/worldgen/features/features/#1-feature-type","title":"1. Feature Type","text":"<p>The feature type is the logic behind the feature. It's the only part that needs to be written in code. Minecraft already has a ton of default feature types (Although they're just called <code>Feature</code> in NMS). Check out the Minecraft Wiki for an up-to-date list of all feature types.</p>"},{"location":"addon/worldgen/features/features/#2-configured-feature","title":"2. Configured Feature","text":"<p>Some feature types require additional configuration which determines what the feature will generate. For example, the  <code>minecraft:ore</code> feature type requires a <code>minecraft:ore_configuration</code> to be defined. This configuration will determine  stuff like: what block the ore will be placed in, how large the ore vein will be, etc. For more details on a specific  configuration, check out its corresponding page in the sidebar. You can create configured feature files in the  <code>data/worldgen/configured_feature</code> directory.</p>"},{"location":"addon/worldgen/features/features/#3-placed-feature","title":"3. Placed Feature","text":"<p>A placed feature determines where and how a configured feature will be placed. You can create placed feature files in the <code>data/worldgen/placed_feature</code> directory. You can find more information on the Placed Feature page.</p>"},{"location":"addon/worldgen/features/features/#using-features","title":"Using Features","text":"<p>To register a new feature, you'll always need a placed feature. When creating a new biome or adding it to an existing one, you'll quickly notice that <code>features</code> is a 2d <code>JsonArray</code> instead of a 1-dimensional one. This is because Minecraft generates different feature categories in a specific order. Below you'll find a list of all feature categories in the order they're generated.</p> <ul> <li>raw_generation  (e.g. end islands) </li> <li>lakes  (e.g. lava lakes) </li> <li>local_modifications  (e.g. amethyst geodes) </li> <li>underground_structures  (e.g. dungeons) </li> <li>surface_structures  (e.g. villages) </li> <li>strongholds  (not used anymore) </li> <li>underground_ores</li> <li>underground_decoration  (e.g. sculk, also used for nether ores for some reason) </li> <li>fluid_springs  (e.g. water springs) </li> <li>vegetal_decoration  (e.g. trees, flowers) </li> <li>top_layer_modification  (used for post-generation modifications, e.g. snow) </li> </ul> <p>Make sure to add your feature to the correct category, or it might not generate at all/get destroyed by another feature.</p> Example: Vanilla birch forest <p>As an example, here's the features <code>JsonArray</code> of the vanilla birch forest biome:</p> <pre><code>\"features\": [\n    [],\n    [\n      \"minecraft:lake_lava_underground\",\n      \"minecraft:lake_lava_surface\"\n    ],\n    [\n      \"minecraft:amethyst_geode\"\n    ],\n    [\n      \"minecraft:monster_room\",\n      \"minecraft:monster_room_deep\"\n    ],\n    [],\n    [],\n    [\n      \"minecraft:ore_dirt\",\n      \"minecraft:ore_gravel\",\n      \"minecraft:ore_granite_upper\",\n      \"minecraft:ore_granite_lower\",\n      \"minecraft:ore_diorite_upper\",\n      \"minecraft:ore_diorite_lower\",\n      \"minecraft:ore_andesite_upper\",\n      \"minecraft:ore_andesite_lower\",\n      \"minecraft:ore_tuff\",\n      \"minecraft:ore_coal_upper\",\n      \"minecraft:ore_coal_lower\",\n      \"minecraft:ore_iron_upper\",\n      \"minecraft:ore_iron_middle\",\n      \"minecraft:ore_iron_small\",\n      \"minecraft:ore_gold\",\n      \"minecraft:ore_gold_lower\",\n      \"minecraft:ore_redstone\",\n      \"minecraft:ore_redstone_lower\",\n      \"minecraft:ore_diamond\",\n      \"minecraft:ore_diamond_large\",\n      \"minecraft:ore_diamond_buried\",\n      \"minecraft:ore_lapis\",\n      \"minecraft:ore_lapis_buried\",\n      \"minecraft:ore_copper\",\n      \"minecraft:underwater_magma\",\n      \"minecraft:disk_sand\",\n      \"minecraft:disk_clay\",\n      \"minecraft:disk_gravel\"\n    ],\n    [],\n    [\n      \"minecraft:spring_water\",\n      \"minecraft:spring_lava\"\n    ],\n    [\n      \"minecraft:glow_lichen\",\n      \"minecraft:forest_flowers\",\n      \"minecraft:trees_birch\",\n      \"minecraft:flower_default\",\n      \"minecraft:patch_grass_forest\",\n      \"minecraft:brown_mushroom_normal\",\n      \"minecraft:red_mushroom_normal\",\n      \"minecraft:patch_sugar_cane\",\n      \"minecraft:patch_pumpkin\"\n    ],\n    [\n      \"minecraft:freeze_top_layer\"\n    ]\n]\n</code></pre> <p>Check out the Biomes page for more information on how to create a new biome. If you want to add your feature to an existing biome, check out the Biome Injections page.</p>"},{"location":"addon/worldgen/features/placed-feature/","title":"Placed Features","text":"<p>A placed feature determines where and how a configured feature will be placed. Placed features work via placement modifiers  that can be applied to a configured feature. </p> <p>You can create placed feature files in the <code>data/worldgen/placed_feature</code> directory or register them in the <code>FeatureRegistry</code> in code.</p>"},{"location":"addon/worldgen/features/placed-feature/#structure","title":"Structure","text":"<code>feature</code> <p>The configured feature's id</p> <code>placement</code> <p>A list of placement modifiers. See Placement Modifiers for more information. </p> <p>Here's an example of Minecraft's large diamond ore placed feature: </p> KotlinJson <pre><code>@OptIn(ExperimentalWorldGen::class)\n@Init(stage = InitStage.POST_PACK_PRE_WORLD)\nobject PlacedFeatures : FeatureRegistry by ExampleAddon.registry {\n\n    val ORE_DIAMOND_LARGE_PLACEMENT = placedFeature(\"ore_diamond_large\", OreFeatures.ORE_DIAMOND_LARGE) // (1)!\n        .rarityFilter(9) // (2)!\n        .inSquareSpread() // (3)!\n        .heightRangeTriangle(VerticalAnchor.aboveBottom(-80), VerticalAnchor.aboveBottom(80)) // (4)!\n        .biomeFilter() // (5)!\n        .register()\n\n}\n</code></pre> <ol> <li>The configured feature to place</li> <li>Only give the feature a chance of \\({{}^{1}\\!/_{9}}\\) to generate</li> <li>Adds a random integer in the range \\([0;15]\\) to the x- and z-coordinates of the initial position</li> <li>Sets the y-coordinate to a value provided by the trapezoid height provider. <code>triangle</code> is a shortcut for the trapezoid height provider with a plateau of width 0. This provider provides a y-coordinate in the range \\([-80;80]\\) below/above the bedrock layer via an isosceles trapezoidal distribution. Since blocks can't be placed under the bedrock layer, this again halves the chance of the feature generating.</li> <li>Only generates the feature in biomes that contain this feature (the <code>in_square</code> placement modifiers might have generated a position in a different biome).</li> </ol> ore_diamond_large.json<pre><code>{\n  \"feature\": \"minecraft:ore_diamond_large\",\n  \"placement\": [\n    {\n      \"type\": \"minecraft:rarity_filter\", // (1)!\n      \"chance\": 9\n    },\n    {\n      \"type\": \"minecraft:in_square\" // (2)!\n    },\n    {\n      \"type\": \"minecraft:height_range\", // (3)!\n      \"height\": {\n        \"type\": \"minecraft:trapezoid\", // (4)!\n        \"max_inclusive\": {\n          \"above_bottom\": 80\n        },\n        \"min_inclusive\": {\n          \"above_bottom\": -80\n        }\n      }\n    },\n    {\n      \"type\": \"minecraft:biome\" // (5)!\n    }\n  ]\n}\n</code></pre> <ol> <li>Only give the feature a chance of \\({{}^{1}\\!/_{9}}\\) to generate</li> <li>Adds a random integer in the range \\([0;15]\\) to the x- and z-coordinates of the initial position</li> <li>Sets the y-coordinate to a value provided by the trapezoid height provider</li> <li>Provides a y-coordinate in the range \\([-80;80]\\) below/above the bedrock layer via an isosceles trapezoidal distribution. Since blocks can't be placed under the bedrock layer, this again halves the chance of the feature generating.</li> <li>Only generates the feature in biomes that contain this feature (the <code>in_square</code> placement modifiers might have generated a position in a different biome).</li> </ol>"},{"location":"addon/worldgen/features/placed-feature/#placement-modifiers","title":"Placement Modifiers","text":"<p>A Placement modifier takes an initial position and returns empty, one or more block positions. These modifiers are chained, and pretty much act like a lot of <code>flatMap</code> calls. In fact, that's exactly what Minecraft does internally:</p> PlacedFeature.java<pre><code>private boolean placeWithContext(PlacementContext ctx, RandomSource random, BlockPos pos) {\n    Stream&lt;BlockPos&gt; stream = Stream.of(pos);\n\n    for (PlacementModifier placementmodifier : this.placement) {\n        stream = stream.flatMap((blockPos) -&gt; {\n            return placementmodifier.getPositions(ctx, random, blockPos);\n        });\n    }\n\n    // ...\n}\n</code></pre> <p>So you can also think of these positions as attempts to place the configured feature. A list of vanilla placement modifiers can be found below.</p>"},{"location":"addon/worldgen/features/placed-feature/#minecraftbiome","title":"<code>minecraft:biome</code>","text":"<p>Returns the position if the configured feature is registered in the biome's <code>feature</code> list at the given position. Empty otherwise.</p> KotlinJson Example<pre><code>BiomeFilter.biome()\n</code></pre> Example<pre><code>{\n  \"type\": \"minecraft:biome\"\n}\n</code></pre>"},{"location":"addon/worldgen/features/placed-feature/#minecraftblock_predicate_filter","title":"<code>minecraft:block_predicate_filter</code>","text":"<p>Returns the position if the block predicate matches the block at the given position. Empty otherwise.</p> Name Description <code>predicate</code> The <code>BlockPredicate</code> KotlinJson Example<pre><code>BlockPredicateFilter.forPredicate(BlockPredicate.matchesTag(BlockTags.STONE_ORE_REPLACEABLES))\n</code></pre> Example<pre><code>{\n  \"type\": \"minecraft:block_predicate_filter\",\n  \"predicate\": {\n    \"type\": \"minecraft:matching_block_tag\",\n    \"tag\": \"minecraft:stone_ore_replaceables\"\n  }\n}\n</code></pre>"},{"location":"addon/worldgen/features/placed-feature/#minecraftcarving_mask","title":"<code>minecraft:carving_mask</code>","text":"<p>Returns all positions in the given position's chunk that were carved out by a carver.</p> Name Description <code>step</code> The carver step. Can be <code>air</code> or <code>liquid</code> KotlinJson Example<pre><code>CarvingMaskPlacement.forStep(GenerationStep.Carving.AIR)\n</code></pre> Example<pre><code>{\n  \"type\": \"minecraft:carving_mask\",\n  \"step\": \"air\"\n}\n</code></pre>"},{"location":"addon/worldgen/features/placed-feature/#minecraftcount","title":"<code>minecraft:count</code>","text":"<p>Returns the given position <code>count</code> times.</p> Name Description <code>count</code> An <code>IntProvider</code> (Range limit in Json is \\([0;256]\\)). The provided value is the number of times the position is returned KotlinJson Example - Simple<pre><code>CountPlacement.of(10)\n</code></pre> Example - Int Provider<pre><code>CountPlacement.of(UniformInt.of(1, 10))\n</code></pre> Example - Simple<pre><code>{\n  \"type\": \"minecraft:count\",\n  \"count\": 10\n}\n</code></pre> Example - Int Provider<pre><code>{\n  \"type\": \"minecraft:count\",\n  \"count\": {\n    \"type\": \"minecraft:uniform\",\n    \"min_inclusive\": 1,\n    \"max_inclusive\": 10\n  }\n}\n</code></pre>"},{"location":"addon/worldgen/features/placed-feature/#minecraftcount_on_every_layer","title":"<code>minecraft:count_on_every_layer</code>","text":"<p>Deprecated. For more information, check out the Minecraft Wiki</p>"},{"location":"addon/worldgen/features/placed-feature/#minecraftenvironment_scan","title":"<code>minecraft:environment_scan</code>","text":"<p>Scans for blocks matching the given block predicate up/down until it finds a matching block or the max number of steps is reached. If no matching block is found, empty is returned.</p> Name Description <code>direction_of_search</code> The direction of the scan. Can be <code>up</code> or <code>down</code> <code>target_condition</code> The <code>BlockPredicate</code> to match <code>allowed_search_condition</code> (optional) A <code>BlockPredicate</code> that each scanned block must match to allow further scanning. If not provided, no condition is applied. <code>max_steps</code> An <code>int</code> that determines the max number of steps. (Range limit in Json is \\([1;32]\\)) KotlinJson Example<pre><code>EnvironmentScanPlacement.scanningFor(\n    Direction.DOWN, // Search direction\n    BlockPredicate.solid(), // Target predicate\n    BlockPredicate.matchesBlocks(Blocks.AIR, Blocks.WATER), // Allowed search predicate\n    12 // Max steps\n)\n</code></pre> Example<pre><code>{\n  \"type\": \"minecraft:environment_scan\",\n  \"direction_of_search\": \"down\",\n  \"max_steps\": 12,\n  \"target_condition\": {\n    \"type\": \"minecraft:solid\"\n  },\n  \"allowed_search_condition\": {\n    \"type\": \"minecraft:matching_blocks\",\n    \"blocks\": [\n      \"minecraft:air\",\n      \"minecraft:water\"\n    ]\n  }\n}\n</code></pre>"},{"location":"addon/worldgen/features/placed-feature/#minecraftheight_range","title":"<code>minecraft:height_range</code>","text":"<p>Takes the input position and sets the y coordinate to a value provided by the given height provider.</p> Name Description <code>height</code> The <code>HeightProvider</code> providing the y-coordinate KotlinJson Example<pre><code>HeightRangePlacement.triangle(VerticalAnchor.aboveBottom(-80), VerticalAnchor.aboveBottom(80))\n</code></pre> Example<pre><code>{\n  \"type\": \"minecraft:height_range\",\n  \"height\": {\n    \"type\": \"minecraft:trapezoid\",\n    \"max_inclusive\": {\n      \"above_bottom\": 80\n    },\n    \"min_inclusive\": {\n      \"above_bottom\": -80\n    }\n  }\n}\n</code></pre>"},{"location":"addon/worldgen/features/placed-feature/#minecraftheightmap","title":"<code>minecraft:heightmap</code>","text":"<p>Takes the input position and sets the y coordinate to one block above the heightmap at the given position. Check out the heightmap gist page for image examples.</p> Name Description <code>heightmap</code> The heightmap type to use. Can be <code>WORLD_SURFACE_WG</code>, <code>WORLD_SURFACE</code>, <code>OCEAN_FLOOR_WG</code>, <code>OCEAN_FLOOR</code>, <code>MOTION_BLOCKING</code> or <code>MOTION_BLOCKING_NO_LEAVES</code>. KotlinJson Example<pre><code>HeightmapPlacement.onHeightmap(Heightmap.Types.WORLD_SURFACE_WG)\n</code></pre> Example<pre><code>{\n  \"type\": \"minecraft:heightmap\",\n  \"heightmap\": \"WORLD_SURFACE_WG\"\n}\n</code></pre>"},{"location":"addon/worldgen/features/placed-feature/#minecraftin_square","title":"<code>minecraft:in_square</code>","text":"<p>Adds a random integer in the range \\([0;15]\\) to the x- and z-coordinates of the given position.</p> KotlinJson Example<pre><code>InSquarePlacement.spread()\n</code></pre> Example<pre><code>{\n  \"type\": \"minecraft:in_square\"\n}\n</code></pre>"},{"location":"addon/worldgen/features/placed-feature/#minecraftnoise_based_count","title":"<code>minecraft:noise_based_count</code>","text":"<p>Gets the noise value at the given position and, if the value is positive, returns the given position multiple times. The amount of times the position is returned is determined by the following code: <pre><code>double noise = Biome.BIOME_INFO_NOISE.getValue((double)pos.getX() / noiseFactor, (double)pos.getZ() / noiseFactor, false);\nint count = (int)Math.ceil((noise + noiseOffset) * noiseToCountRatio);\n</code></pre></p> Name Description <code>noise_to_count_ratio</code> An <code>int</code> that defines the ratio of noise to count. <code>noise_factor</code> A <code>double</code> that scales the noise horizontally. The higher the value, the wider the peaks. <code>noise_offset</code> (optional in Json) A <code>double</code> that offsets the noise vertically. KotlinJson Example<pre><code>NoiseBasedCountPlacement.of(\n    160, // Noise to count ratio\n    80.0, // Noise factor\n    .3 // Noise offset\n)\n</code></pre> Example<pre><code>{\n  \"type\": \"minecraft:noise_based_count\"\n  \"noise_factor\": 80.0,\n  \"noise_offset\": 0.3,\n  \"noise_to_count_ratio\": 160,\n}\n</code></pre>"},{"location":"addon/worldgen/features/placed-feature/#minecraftnoise_threshold_count","title":"<code>minecraft:noise_threshold_count</code>","text":"<p>Returns the given position multiple times. If the noise value at the given position is below the given threshold, the position is returned <code>below_noise</code> times. Otherwise, it is returned <code>above_noise</code> times. Or, in code:</p> <pre><code>if (noise &lt; threshold) {\n  return below_noise;\n} else { // noise &gt;= threshold\n  return above_noise;\n}\n</code></pre> Name Description <code>noise_level</code> A <code>double</code> value of the threshold that determines whether the position is returned <code>below_noise</code> or <code>above_noise</code> times. <code>below_noise</code> An <code>int</code> that determines how often the position is returned if the noise value is below the threshold. <code>above_noise</code> An <code>int</code> that determines how often the position is returned if the noise value is above/equal to the threshold. KotlinJson Example<pre><code>NoiseThresholdCountPlacement.of(\n    -0.8, // Noise level\n    5, // Below noise\n    10 // Above noise\n)\n</code></pre> Example<pre><code>{\n  \"type\": \"minecraft:noise_threshold_count\",\n  \"noise_level\": -0.8\n  \"above_noise\": 10,\n  \"below_noise\": 5,\n}\n</code></pre>"},{"location":"addon/worldgen/features/placed-feature/#minecraftrandom_offset","title":"<code>minecraft:random_offset</code>","text":"<p>Offsets the given position by the provided <code>IntProvider's</code> values.</p> Name Description <code>xz_spread</code> An <code>IntProvider</code>. (Range limit in Json is \\([-16;16]\\)). x and z are sampled separately! <code>y_spread</code> An <code>IntProvider</code>. (Range limit in Json is \\([-16;16]\\)). KotlinJson Example<pre><code>RandomOffsetPlacement.of(ConstantInt.ZERO, UniformInt.of(3, 9))\n</code></pre> Example<pre><code>{\n  \"type\": \"minecraft:random_offset\",\n  \"xz_spread\": 0,\n  \"y_spread\": {\n    \"type\": \"minecraft:uniform\",\n    \"value\": {\n      \"max_inclusive\": 9,\n      \"min_inclusive\": 3\n    }\n  }\n}\n</code></pre>"},{"location":"addon/worldgen/features/placed-feature/#minecraftrarity_filter","title":"<code>minecraft:rarity_filter</code>","text":"<p>Either returns the given position or empty. The chance of returning the position is determined by the given chance and calculated via <code>1 / chance</code>.</p> Name Description <code>chance</code> A positive <code>int</code> that determines the average amount of tries between a success. KotlinJson Example<pre><code>RarityFilter.onAverageOnceEvery(9)\n</code></pre> Example<pre><code>{\n  \"type\": \"minecraft:rarity_filter\",\n  \"chance\": 9\n}\n</code></pre>"},{"location":"addon/worldgen/features/placed-feature/#minecraftsurface_relative_threshold_filter","title":"<code>minecraft:surface_relative_threshold_filter</code>","text":"<p>Returns the given position if the surface height at the given position is inside the specified range. Otherwise, returns empty. Check out the heightmap gist page for image examples.</p> Name Description <code>heightmap</code> The heightmap to use. Can be <code>WORLD_SURFACE_WG</code>, <code>WORLD_SURFACE</code>, <code>OCEAN_FLOOR_WG</code>, <code>OCEAN_FLOOR</code>, <code>MOTION_BLOCKING</code> or <code>MOTION_BLOCKING_NO_LEAVES</code>. <code>min_inclusive</code> (Optional in Json, defaults to \\(-2^{31}\\)) A <code>double</code> value that defines the minimum surface level. <code>max_inclusive</code> (Optional in Json, defaults to \\(2^{31} - 1\\)) A <code>double</code> value that defines the maximum surface level. KotlinJson Example<pre><code>SurfaceRelativeThresholdFilter.of(\n    Heightmap.Types.OCEAN_FLOOR_WG,\n    Int.MIN_VALUE, // min\n    -2 // max\n)\n</code></pre> Example<pre><code>{\n  \"type\": \"minecraft:surface_relative_threshold_filter\",\n  \"heightmap\": \"OCEAN_FLOOR_WG\",\n  \"max_inclusive\": -2\n}\n</code></pre>"},{"location":"addon/worldgen/features/placed-feature/#minecraftsurface_water_depth_filter","title":"<code>minecraft:surface_water_depth_filter</code>","text":"<p>If the amount of motion-blocking blocks under the surface is less than/equal to <code>max_water_depth</code>, returns the given position. Otherwise, returns empty.</p> Name Description <code>max_water_depth</code> An <code>int</code> defining the maximum allowed depth. KotlinJson Example<pre><code>SurfaceWaterDepthFilter.forMaxDepth(2)\n</code></pre> Example<pre><code>{\n  \"type\": \"minecraft:surface_water_depth_filter\",\n  \"max_water_depth\": 2\n}\n</code></pre>"},{"location":"addon/worldgen/features/placed-feature/#custom-placementmodifiers","title":"Custom <code>PlacementModifiers</code>","text":"<p>You can also implement your own custom <code>PlacementModifiers</code> by extending Minecraft's <code>PlacementModifier</code> class. You can then register your custom <code>PlacementModifier</code> via the <code>FeatureRegistry</code> either by creating a <code>PlacementModifierType</code> or by providing the <code>Codec</code> directly and thus creating an inline <code>PlacementModifierType</code>. Check out the Codecs page for more information on Mojang's serialization system. Here's how you'd implement the <code>minecraft:count</code> <code>PlacementModifier</code> as an example:</p> Inline PlacementModifierTypePlacementModifierType object PlacementModifiers.kt<pre><code>@OptIn(ExperimentalWorldGen::class)\n@Init(stage = InitStage.POST_PACK_PRE_WORLD)\nobject PlacementModifiers : FeatureRegistry by ExampleAddon.registry {\n\n    val COUNT_PLACEMENT = registerPlacementModifierType(\"count\", CountPlacement.CODEC)\n\n}\n</code></pre> CountPlacement.kt<pre><code>class CountPlacement(val count: IntProvider) : PlacementModifier() {\n\n    override fun getPositions(ctx: PlacementContext, random: RandomSource, pos: BlockPos): Stream&lt;BlockPos&gt; =\n        Stream.generate { pos }.limit(count.sample(random).toLong())\n\n    override fun type(): PlacementModifierType&lt;*&gt; = PlacementModifiers.COUNT_PLACEMENT\n\n    companion object {\n\n        @JvmField // (1)!\n        val CODEC: Codec&lt;CountPlacement&gt; = IntProvider\n            .codec(0, 256)\n            .fieldOf(\"count\")\n            .xmap(::CountPlacement, CountPlacement::count)\n            .codec()\n\n        @JvmStatic\n        fun of(count: Int) = CountPlacement(ConstantInt.of(count))\n\n        @JvmStatic\n        fun of(count: IntProvider) = CountPlacement(count)\n\n    }\n\n}\n</code></pre> <ol> <li>This allows <code>CODEC</code> to be accessed as a field from Java code instead of having to call <code>getCODEC()</code></li> </ol> CountPlacement.kt<pre><code>object CountPlacementType : PlacementModifierType&lt;CountPlacement&gt; {\n\n    private val CODEC: Codec&lt;CountPlacement&gt; = IntProvider\n        .codec(0, 256)\n        .fieldOf(\"count\")\n        .xmap(::CountPlacement, CountPlacement::count)\n        .codec()\n\n    override fun codec() = CODEC\n\n}\n</code></pre> PlacementModifiers.kt<pre><code>@OptIn(ExperimentalWorldGen::class)\n@Init(stage = InitStage.POST_PACK_PRE_WORLD)\nobject PlacementModifiers : FeatureRegistry by ExampleAddon.registry {\n\n    val COUNT_PLACEMENT = registerPlacementModifierType(\"count\", CountPlacementType)\n\n}\n</code></pre> CountPlacement.kt<pre><code>class CountPlacement(val count: IntProvider) : PlacementModifier() {\n\n    override fun getPositions(ctx: PlacementContext, random: RandomSource, pos: BlockPos): Stream&lt;BlockPos&gt; =\n        Stream.generate { pos }.limit(count.sample(random).toLong())\n\n    override fun type(): PlacementModifierType&lt;*&gt; = CountPlacementType\n\n    companion object {\n\n        @JvmStatic\n        fun of(count: Int) = CountPlacement(ConstantInt.of(count))\n\n        @JvmStatic\n        fun of(count: IntProvider) = CountPlacement(count)\n\n    }\n\n}\n</code></pre> <p>Minecraft also offers further abstraction via the <code>RepeatingPlacement</code> and <code>PlacementFilter</code> classes. They both override the <code>getPositions</code> method and provide the <code>count</code> and <code>shouldPlace</code> methods respectively.</p>"},{"location":"addon/worldgen/features/placed-feature/#inlined","title":"Inlined","text":"<p>Some placed features might not be worth registering in the <code>Registry</code> (e.g. <code>fill_layer</code> features for flat worlds). In such cases, <code>PlacementUtils.inlinePlaced</code> can be used to get a <code>Holder</code> that contains a <code>PlacedFeature</code> constructed from the <code>ConfiguredFeature</code> and <code>PlacementModifiers</code> provided.</p> <p>As an example, here's how <code>fill_layer</code> placed features are inlined in Minecraft's flat level generator:</p> FlatLevelGeneratorSettings.java<pre><code>/* ... */\n\nfor (layer = 0; layer &lt; layers.size(); ++layer) {\n    BlockState blockstate = layers.get(layer);\n\n    if (!Heightmap.Types.MOTION_BLOCKING.isOpaque().test(blockstate)) {\n        layers.set(layer, null);\n        builder.addFeature(GenerationStep.Decoration.TOP_LAYER_MODIFICATION, PlacementUtils.inlinePlaced(Feature.FILL_LAYER, new LayerConfiguration(layer, blockstate)));\n    }\n}\n\n/* ... */\n</code></pre>"},{"location":"addon/worldgen/features/configurations/bamboo/","title":"Bamboo feature","text":"<p>The <code>bamboo</code> feature is used to add bamboo to the world.</p>"},{"location":"addon/worldgen/features/configurations/bamboo/#configuration","title":"Configuration","text":"<p>Bamboo features can only be configured to have a specific probability of spawning a podzol disk under the bamboo.</p> Option Type Description <code>probability</code> A <code>float</code> in the range \\([0.0;1.0]\\). Determines the probability of spawning a podzol disk under the bamboo. <p>In code, the configuration is done via the <code>ProbabilityFeatureConfiguration</code> class.</p>"},{"location":"addon/worldgen/features/configurations/bamboo/#example","title":"Example","text":"<p>As an example, here's the configured and placed feature for the bamboo in the jungle.</p> KotlinJson ConfiguredFeatures.kt<pre><code>@OptIn(ExperimentalWorldGen::class)\n@Init(stage = InitStage.POST_PACK_PRE_WORLD)\nobject ConfiguredFeatures : FeatureRegistry by ExampleAddon.registry {\n\n    val BAMBOO_SOME_PODZOL = registerConfiguredFeature(\n        \"bamboo_some_podzol\",\n        Feature.BAMBOO,\n        ProbabilityFeatureConfiguration(0.2f) // (1)!\n    )\n\n}\n</code></pre> <ol> <li>Gives a \\(20\\%\\) chance of spawning a podzol disk under the bamboo.</li> </ol> PlacedFeatures.kt<pre><code>@OptIn(ExperimentalWorldGen::class)\n@Init(stage = InitStage.POST_PACK_PRE_WORLD)\nobject PlacedFeatures: FeatureRegistry by ExampleAddon.registry {\n\n    val BAMBOO_SOME_PODZOL = placedFeature(\"bamboo_some_podzol\", ConfiguredFeatures.BAMBOO_SOME_PODZOL)\n        .noiseBasedCount(170, 80.0, 0.3) // (1)!\n        .inSquareSpread() // (2)!\n        .moveToWorldSurface() // (3)!\n        .biomeFilter() // (4)!\n        .register()\n\n}\n</code></pre> <ol> <li>Use noise to determine bamboo amount.     See Noise-based count placement for more information.</li> <li>Spread the tries in a square.</li> <li>Make sure to place the bamboo on the world surface. This call is equivalent to     <pre><code>HeightmapPlacement.onHeightmap(Heightmap.Types.WORLD_SURFACE_WG)\n</code></pre></li> <li>Only place the bamboo in biomes that have bamboo.</li> </ol> configured_feature/bamboo_some_podzol.json<pre><code>  \"type\": \"minecraft:bamboo\",\n  \"config\": {\n    \"probability\": 0.2 // (1)!\n  }\n</code></pre> <ol> <li>Gives a \\(20\\%\\) chance of spawning a podzol disk under the bamboo.</li> </ol> placed_feature/bamboo.json<pre><code>{\n  \"feature\": \"minecraft:bamboo_some_podzol\",\n  \"placement\": [\n    {\n      \"type\": \"minecraft:noise_based_count\", // (1)!\n      \"noise_factor\": 80.0,\n      \"noise_offset\": 0.3,\n      \"noise_to_count_ratio\": 160\n    },\n    {\n      \"type\": \"minecraft:in_square\" // (2)!\n    },\n    {\n      \"type\": \"minecraft:heightmap\",\n      \"heightmap\": \"WORLD_SURFACE_WG\" // (3)!\n    },\n    {\n      \"type\": \"minecraft:biome\" // (4)!\n    }\n  ]\n}\n</code></pre> <ol> <li>Use noise to determine bamboo amount.     See Noise-based count placement for more information.</li> <li>Spread the tries in a square.</li> <li>Make sure to place the bamboo on the world surface.</li> <li>Only place the bamboo in biomes that have bamboo.</li> </ol>"},{"location":"addon/worldgen/features/configurations/bamboo/#result","title":"Result","text":""},{"location":"addon/worldgen/features/configurations/basalt-columns/","title":"Basalt columns feature","text":"<p>The <code>basalt_columns</code> feature allows you to add basalt columns to the world.</p>"},{"location":"addon/worldgen/features/configurations/basalt-columns/#configuration","title":"Configuration","text":"<p>The <code>basalt_columns</code> feature has the following configuration options:</p> Option Type Description <code>reach</code> An <code>IntProvider</code>. (Range limit in Json is \\([0;3]\\)) Determines the maximum radius from the center of the current column cluster. <code>height</code> An <code>IntProvider</code>. (Range limit in Json is \\([1;10]\\)) Determines the maximum height of the current column cluster. (Actual height is \\(\\text{height} + 1\\) <p>In code, the configuration is done via the <code>ColumnFeatureConfiguration</code> class.</p>"},{"location":"addon/worldgen/features/configurations/basalt-columns/#example","title":"Example","text":"<p>As an example, here's the configured and placed feature for the large basalt columns in the nether.</p> KotlinJson ConfiguredFeatures.kt<pre><code>@OptIn(ExperimentalWorldGen::class)\n@Init(stage = InitStage.POST_PACK_PRE_WORLD)\nobject ConfiguredFeatures : FeatureRegistry by ExampleAddon.registry {\n\n    val LARGE_BASALT_COLUMNS = registerConfiguredFeature(\n        \"large_basalt_columns\",\n        Feature.BASALT_COLUMNS,\n        ColumnFeatureConfiguration(UniformInt.of(2, 3), UniformInt.of(5, 10)) // (1)!\n    )\n\n}\n</code></pre> <ol> <li>Randomly chooses a radius between 2 and 3 and a height between 5 and 10.</li> </ol> PlacedFeatures.kt<pre><code>@OptIn(ExperimentalWorldGen::class)\n@Init(stage = InitStage.POST_PACK_PRE_WORLD)\nobject PlacedFeatures: FeatureRegistry by ExampleAddon.registry {\n\n    val LARGE_BASALT_COLUMNS = placedFeature(\"large_basalt_columns\", ConfiguredFeatures.LARGE_BASALT_COLUMNS)\n        .countOnEveryLayer(2) // (1)!\n        .biomeFilter() // (2)!\n        .register()\n\n}\n</code></pre> <ol> <li>Spreads the basalt columns to multiple layers.</li> <li>Only place the columns in biomes that have basalt.</li> </ol> configured_feature/large_basalt_columns.json<pre><code>{\n  \"type\": \"minecraft:basalt_columns\",\n  \"config\": {\n    \"reach\": { // (1)!\n      \"type\": \"minecraft:uniform\",\n      \"value\": {\n        \"max_inclusive\": 3,\n        \"min_inclusive\": 2\n      }\n    },\n    \"height\": { // (2)!\n      \"type\": \"minecraft:uniform\",\n      \"value\": {\n        \"max_inclusive\": 10,\n        \"min_inclusive\": 5\n      }\n    }\n  }\n}\n</code></pre> <ol> <li>Randomly chooses a radius between 2 and 3.</li> <li>Randomly chooses a height between 5 and 10.</li> </ol> placed_feature/large_basalt_columns.json<pre><code>{\n  \"feature\": \"minecraft:large_basalt_columns\",\n  \"placement\": [\n    {\n      \"type\": \"minecraft:count_on_every_layer\", // (1)!\n      \"count\": 2\n    },\n    {\n      \"type\": \"minecraft:biome\" // (2)!\n    }\n  ]\n}\n</code></pre> <ol> <li>Spreads the basalt columns to multiple layers.</li> <li>Only place the columns in biomes that have basalt.</li> </ol>"},{"location":"addon/worldgen/features/configurations/basalt-columns/#result","title":"Result","text":""},{"location":"addon/worldgen/features/configurations/block-column/","title":"Block column feature","text":"<p>The <code>block_column</code> feature allows you to add a column of blocks (e.g. sugar cane or cacti) to the world.</p>"},{"location":"addon/worldgen/features/configurations/block-column/#configuration","title":"Configuration","text":"<p>The following configuration options are available:</p> Option Type Description <code>layers</code> An array of <code>Layers</code>. See below for more information Defines which block states should be used at specific heights. <code>direction</code> <code>north</code>, <code>east</code>, <code>south</code>, <code>west</code>, <code>up</code> or <code>down</code> Determines the direction of the column. <code>allowed_placement</code> A BlockPredicate A predicate that has to match every block in the column before the block is placed. <code>prioritize_tip</code> A <code>boolean</code> When set to <code>true</code>, all underlying block will be removed if the current block doesn't match the provided BlockPredicate <p>In code, the <code>BlockColumnConfiguration</code> class is used to configure the feature.</p>"},{"location":"addon/worldgen/features/configurations/block-column/#layer","title":"Layer","text":"<p>Layers have 2 options: <code>height</code>, an <code>IntProvider</code> that determines the height of this  layer, and <code>block</code>, a <code>BlockStateProvider</code> that determines the block state to use for this layer.</p>"},{"location":"addon/worldgen/features/configurations/block-column/#examples","title":"Examples","text":"<p>As an example, here's the configured feature used to place cacti in the desert. Please note that Minecraft uses the <code>random_patch</code> feature to actually spread cacti and sugar cane.</p>"},{"location":"addon/worldgen/features/configurations/block-column/#cactus","title":"Cactus","text":"KotlinJson ConfiguredFeatures.kt<pre><code>@OptIn(ExperimentalWorldGen::class)\n@Init(stage = InitStage.POST_PACK_PRE_WORLD)\nobject ConfiguredFeatures : FeatureRegistry by ExampleAddon.registry {\n\n    val CACTUS = registerConfiguredFeature(\n        \"cactus\",\n        Feature.BLOCK_COLUMN,\n        BlockColumnConfiguration(\n            listOf(BlockColumnConfiguration.Layer(BiasedToBottomInt.of(1, 3), SimpleStateProvider.simple(Blocks.CACTUS))), // (1)!\n            Direction.UP, // (2)!\n            BlockPredicate.matchesBlocks(Blocks.AIR), // (3)!\n            false // (4)!\n        )\n    )\n\n}\n</code></pre> <ol> <li>The cactus only has a single layer of the <code>cactus</code> block which can be 1, 2 or 3 blocks high, biased towards a shorter height.</li> <li>The cactus grows upwards.</li> <li>Only place the cactus if the block above is air.</li> <li>Only the top of the cactus will be cut off if the block above is not air.</li> </ol> configured_feature/cactus.json<pre><code>{\n  \"type\": \"minecraft:block_column\",\n  \"config\": {\n    \"direction\": \"up\", // (1)!\n    \"allowed_placement\": {\n      \"type\": \"minecraft:matching_blocks\",\n      \"blocks\": \"minecraft:air\" // (2)!\n    },\n    \"prioritize_tip\": false, // (3)!\n    \"layers\": [\n      { // (4)!\n        \"height\": { // (5)!\n          \"type\": \"minecraft:biased_to_bottom\",\n          \"value\": {\n            \"max_inclusive\": 3,\n            \"min_inclusive\": 1\n          }\n        },\n        \"provider\": {\n          \"type\": \"minecraft:simple_state_provider\",\n          \"state\": {\n            \"Name\": \"minecraft:cactus\",\n            \"Properties\": {\n              \"age\": \"0\"\n            }\n          }\n        }\n      }\n    ]\n  }\n}\n</code></pre> <ol> <li>The cactus grows upwards.</li> <li>Only place the cactus if the block above is air.</li> <li>Only the top of the cactus will be cut off if the block above is not air.</li> <li>Since the cactus only needs the normal cactus block, we only need one layer.</li> <li>The cactus can be 1, 2 or 3 blocks high, biased towards a shorter height.</li> </ol>"},{"location":"addon/worldgen/features/configurations/block-column/#result","title":"Result","text":"AloneNaturally generated <p><p> </p></p> <p><p> </p></p>"},{"location":"addon/worldgen/features/configurations/block-column/#glow-berry-vines","title":"Glow berry vines","text":"<p>Or, as another example, here's the configured and placed feature for glow berries/cave vines.</p> KotlinJson ConfiguredFeatures.kt<pre><code>@OptIn(ExperimentalWorldGen::class)\n@Init(stage = InitStage.POST_PACK_PRE_WORLD)\nobject ConfiguredFeatures : FeatureRegistry by ExampleAddon.registry {\n\n    val CAVE_VINE: ConfiguredFeature&lt;BlockColumnConfiguration, Feature&lt;BlockColumnConfiguration&gt;&gt;\n\n    init {\n        val upperStateProvider = WeightedStateProvider( // (1)!\n            SimpleWeightedRandomList.builder&lt;BlockState&gt;()\n                .add(Blocks.CAVE_VINES_PLANT.defaultBlockState(), 4)\n                .add(Blocks.CAVE_VINES_PLANT.defaultBlockState().setValue(CaveVines.BERRIES, true), 1)\n        )\n\n        val bottomStateProvider = RandomizedIntStateProvider(WeightedStateProvider( // (2)!\n            SimpleWeightedRandomList.builder&lt;BlockState&gt;()\n                .add(Blocks.CAVE_VINES.defaultBlockState(), 4)\n                .add(Blocks.CAVE_VINES.defaultBlockState().setValue(CaveVines.BERRIES, true), 1)\n        ), CaveVinesBlock.AGE, UniformInt.of(23, 25))\n\n        val config = BlockColumnConfiguration(\n            listOf( // (3)!\n                BlockColumnConfiguration.Layer(\n                    WeightedListInt( // (4)!\n                        SimpleWeightedRandomList.builder&lt;IntProvider&gt;()\n                            .add(UniformInt.of(0, 19), 2)\n                            .add(UniformInt.of(0, 2), 3)\n                            .add(UniformInt.of(0, 6), 10)\n                            .build()\n                    ),\n                    upperStateProvider // (5)!\n                ),\n                BlockColumnConfiguration.Layer(\n                    ConstantInt.of(1), // (6)!\n                    bottomStateProvider // (7)!\n                )\n            ),\n            Direction.DOWN, // (8)!\n            BlockPredicate.ONLY_IN_AIR_PREDICATE, // (9)!\n            true // (10)!\n        )\n\n        CAVE_VINE = registerConfiguredFeature(\"cave_vine\", Feature.BLOCK_COLUMN, config)\n    }\n\n}\n</code></pre> <ol> <li>Each block of the upper layer of the vine can either be a normal or a vine with berries (biased towards normal).</li> <li>The bottom layer of the vine can either be a normal or a vine with berries (biased towards normal), and the age of the vine is randomized between 23 and 25.</li> <li>The vine has two layers, the upper layer (<code>upperStateProvider</code>) and the bottom layer (<code>bottomStateProvider</code>).</li> <li>The upper layer can be 0 to 19 blocks high, biased towards a medium height.</li> <li>The upper layer can be either a normal or a vine with berries (biased towards normal).</li> <li>The bottom layer is always 1 block high.</li> <li>The bottom layer can be either a normal or a vine with berries (biased towards normal), and the age of the vine is randomized between 23 and 25.</li> <li>The vine grows downwards.</li> <li>Only place the vine if the block below is air.</li> <li>If the predicate fails, the entire vine will be removed.</li> </ol> PlacedFeatures.kt<pre><code>@OptIn(ExperimentalWorldGen::class)\n@Init(stage = InitStage.POST_PACK_PRE_WORLD)\nobject PlacedFeatures: FeatureRegistry by ExampleAddon.registry {\n\n    val CAVE_VINE = placedFeature(\"cave_vine\", ConfiguredFeatures.CAVE_VINE)\n        .count(188) // (1)!\n        .inSquareSpread() // (2)!\n        .heightRangeUniform(VerticalAnchor.BOTTOM, VerticalAnchor.absolute(256)) // (3)!\n        .environmentScan( // (4)!\n            Direction.UP,\n            BlockPredicate.hasSturdyFace(Direction.DOWN),\n            BlockPredicate.ONLY_IN_AIR_PREDICATE,\n            12\n        )\n        .randomVerticalOffset(-1) // (5)!\n        .biomeFilter() // (6)!\n        .register()\n\n}\n</code></pre> <ol> <li>188 tries per chunk.</li> <li>Spread the locations in a square.</li> <li>Only place the vines in the y-range of bottom to 256.</li> <li>Search for the first block that has a solid face downwards (max 12 blocks away).</li> <li>Offset the location by \\((0,-1,0)\\).</li> <li>Only place the vines if the current biome has cave vines.</li> </ol> configured_feature/cave_vine.json<pre><code>{\n  \"type\": \"minecraft:block_column\",\n  \"config\": {\n    \"direction\": \"down\", // (1)!\n    \"allowed_placement\": {\n      \"type\": \"minecraft:matching_blocks\",\n      \"blocks\": \"minecraft:air\" // (2)!\n    },\n    \"prioritize_tip\": true, // (3)!\n    \"layers\": [\n      { // (4)!\n        \"height\": {\n          \"type\": \"minecraft:weighted_list\",\n          \"distribution\": [\n            {\n              \"data\": {\n                \"type\": \"minecraft:uniform\",\n                \"value\": {\n                  \"max_inclusive\": 19,\n                  \"min_inclusive\": 0\n                }\n              },\n              \"weight\": 2\n            },\n            {\n              \"data\": {\n                \"type\": \"minecraft:uniform\",\n                \"value\": {\n                  \"max_inclusive\": 2,\n                  \"min_inclusive\": 0\n                }\n              },\n              \"weight\": 3\n            },\n            {\n              \"data\": {\n                \"type\": \"minecraft:uniform\",\n                \"value\": {\n                  \"max_inclusive\": 6,\n                  \"min_inclusive\": 0\n                }\n              },\n              \"weight\": 10\n            }\n          ]\n        },\n        \"provider\": {\n          \"type\": \"minecraft:weighted_state_provider\",\n          \"entries\": [\n            {\n              \"data\": {\n                \"Name\": \"minecraft:cave_vines_plant\",\n                \"Properties\": {\n                  \"berries\": \"false\"\n                }\n              },\n              \"weight\": 4\n            },\n            {\n              \"data\": {\n                \"Name\": \"minecraft:cave_vines_plant\",\n                \"Properties\": {\n                  \"berries\": \"true\"\n                }\n              },\n              \"weight\": 1\n            }\n          ]\n        }\n      },\n      {\n        \"height\": 1,\n        \"provider\": {\n          \"type\": \"minecraft:randomized_int_state_provider\",\n          \"property\": \"age\",\n          \"source\": {\n            \"type\": \"minecraft:weighted_state_provider\",\n            \"entries\": [\n              {\n                \"data\": {\n                  \"Name\": \"minecraft:cave_vines\",\n                  \"Properties\": {\n                    \"age\": \"0\",\n                    \"berries\": \"false\"\n                  }\n                },\n                \"weight\": 4\n              },\n              {\n                \"data\": {\n                  \"Name\": \"minecraft:cave_vines\",\n                  \"Properties\": {\n                    \"age\": \"0\",\n                    \"berries\": \"true\"\n                  }\n                },\n                \"weight\": 1\n              }\n            ]\n          },\n          \"values\": {\n            \"type\": \"minecraft:uniform\",\n            \"value\": {\n              \"max_inclusive\": 25,\n              \"min_inclusive\": 23\n            }\n          }\n        }\n      }\n    ]\n  }\n}\n</code></pre> <ol> <li>The vines grow downwards.</li> <li>Only place the vines if the block below is air.</li> <li>Remove all vines if the block below is not air.</li> <li>Place multiple cave vine plants (glow berries) at the top and always add a single cave vine at the bottom.</li> </ol> placed_feature/cave_vines.json<pre><code>{\n  \"feature\": \"minecraft:cave_vine\",\n  \"placement\": [\n    {\n      \"type\": \"minecraft:count\",\n      \"count\": 188 // (1)!\n    },\n    {\n      \"type\": \"minecraft:in_square\" // (2)!\n    },\n    {\n      \"type\": \"minecraft:height_range\", // (3)!\n      \"height\": {\n        \"type\": \"minecraft:uniform\",\n        \"max_inclusive\": {\n          \"absolute\": 256\n        },\n        \"min_inclusive\": {\n          \"above_bottom\": 0\n        }\n      }\n    },\n    {\n      \"type\": \"minecraft:environment_scan\", // (4)!\n      \"allowed_search_condition\": {\n        \"type\": \"minecraft:matching_blocks\",\n        \"blocks\": \"minecraft:air\"\n      },\n      \"direction_of_search\": \"up\",\n      \"max_steps\": 12,\n      \"target_condition\": {\n        \"type\": \"minecraft:has_sturdy_face\",\n        \"direction\": \"down\"\n      }\n    },\n    {\n      \"type\": \"minecraft:random_offset\", // (5)!\n      \"xz_spread\": 0,\n      \"y_spread\": -1\n    },\n    {\n      \"type\": \"minecraft:biome\" // (6)!\n    }\n  ]\n}\n</code></pre> <ol> <li>188 tries per chunk.</li> <li>Spread the locations in a square.</li> <li>Only place the vines in the y-range of bottom to 256.</li> <li>Search for the first block that has a solid face downwards (max 12 blocks away).</li> <li>Offset the location by \\((0,-1,0)\\).</li> <li>Only place the vines if the current biome has cave vines.</li> </ol>"},{"location":"addon/worldgen/features/configurations/block-column/#result_1","title":"Result","text":"AloneNaturally generated <p><p> </p></p> <p><p> </p></p>"},{"location":"addon/worldgen/features/configurations/block-pile/","title":"Block pile feature","text":"<p>The <code>block_pile</code> can be used to place piles of blocks (for example hay/melons in villages) in the world.</p>"},{"location":"addon/worldgen/features/configurations/block-pile/#configuration","title":"Configuration","text":"<p>A block pile feature only has the <code>state_provider</code> option:</p> Option Type Description <code>state_provider</code> A  <code>BlockStateProvider</code> The block state to use for the pile. <p>In code, the <code>BlockPileConfiguration</code> class is used to configure the feature.</p>"},{"location":"addon/worldgen/features/configurations/block-pile/#example","title":"Example","text":"<p>As an example, here's the placed and configured feature used to place piles of hay bales in villages.</p> KotlinJson ConfiguredFeatures.kt<pre><code>@OptIn(ExperimentalWorldGen::class)\n@Init(stage = InitStage.POST_PACK_PRE_WORLD)\nobject ConfiguredFeatures : FeatureRegistry by ExampleAddon.registry {\n\n    val PILE_HAY = registerConfiguredFeature(\n        \"pile_hay\",\n        Feature.BLOCK_PILE,\n        BlockPileConfiguration(RotatedBlockProvider(Blocks.HAY_BLOCK)) // (1)!\n    )\n\n}\n</code></pre> <ol> <li>Randomly rotate the hay bales.</li> </ol> PlacedFeatures.kt<pre><code>@OptIn(ExperimentalWorldGen::class)\n@Init(stage = InitStage.POST_PACK_PRE_WORLD)\nobject PlacedFeatures: FeatureRegistry by ExampleAddon.registry {\n\n    val PILE_HAY = placedFeature(\"pile_hay\", ConfiguredFeatures.PILE_HAY).register() // (1)!\n\n}\n</code></pre> <ol> <li>The feature does all the location resolving itself, so no extra <code>PlacementModifiers</code> are needed.</li> </ol> configured_feature/pile_hay.json<pre><code>{\n  \"type\": \"minecraft:block_pile\",\n  \"config\": {\n    \"state_provider\": {\n      \"type\": \"minecraft:rotated_block_provider\",\n      \"state\": {\n        \"Name\": \"minecraft:hay_block\",\n        \"Properties\": {\n          \"axis\": \"y\" // (1)!\n        }\n      }\n    }\n  }\n}\n</code></pre> <ol> <li>Randomly rotate the hay bales.</li> </ol> placed_feature/pile_hay.json<pre><code>{\n  \"feature\": \"minecraft:pile_hay\",\n  \"placement\": [] // (1)!\n}\n</code></pre> <ol> <li>The feature does all the location resolving itself.</li> </ol>"},{"location":"addon/worldgen/features/configurations/block-pile/#result","title":"Result","text":"AloneNaturally generated <p><p> </p></p> <p><p> </p></p>"},{"location":"addon/worldgen/features/configurations/delta/","title":"Delta feature","text":"<p>The <code>delta_feature</code> is a 1-block deep sheet of a block randomly surrounded by a block (rim). It's normally used to generate the deltas in the basalt deltas biome.</p>"},{"location":"addon/worldgen/features/configurations/delta/#configuration","title":"Configuration","text":"<p>The following configuration options are available:</p> Option Type Description <code>contents</code> A <code>BlockState</code> The block state to use inside of the delta. <code>rim</code> A <code>BlockState</code> The block state to use for the rim. <code>size</code> An <code>IntProvider</code>. (Range limit in Json is \\([0;16]\\)) Determines the maximum radius from the center of the current delta. <code>rim_size</code> An <code>IntProvider</code>. (Range limit in Json is \\([0;16]\\)) Determines the size of the rim. <p>In code, the <code>DeltaFeatureConfiguration</code> class is used to configure the feature.</p>"},{"location":"addon/worldgen/features/configurations/delta/#example","title":"Example","text":"<p>As an example, here's the placed and configured feature used to place deltas in the basalt deltas biome.</p> KotlinJson ConfiguredFeatures.kt<pre><code>@OptIn(ExperimentalWorldGen::class)\n@Init(stage = InitStage.POST_PACK_PRE_WORLD)\nobject ConfiguredFeatures : FeatureRegistry by ExampleAddon.registry {\n\n    val DELTA = registerConfiguredFeature(\n        \"delta\",\n        Feature.DELTA_FEATURE,\n        DeltaFeatureConfiguration(\n            Blocks.LAVA.defaultBlockState(), // contents\n            Blocks.MAGMA_BLOCK.defaultBlockState(), // rim\n            UniformInt.of(3, 7), // size (1)\n            UniformInt.of(0, 2) // rim_size\n        )\n    )\n\n}\n</code></pre> <ol> <li>Random <code>int</code> in the range \\([3;7]\\).</li> </ol> PlacedFeatures.kt<pre><code>@OptIn(ExperimentalWorldGen::class)\n@Init(stage = InitStage.POST_PACK_PRE_WORLD)\nobject PlacedFeatures: FeatureRegistry by ExampleAddon.registry {\n\n    val DELTA = placedFeature(\"delta\", ConfiguredFeatures.DELTA)\n        .countOnEveryLayer(40) // (1)!\n        .biomeFilter() // (2)!\n        .register()\n\n}\n</code></pre> <ol> <li>Spreads the deltas to multiple layers.</li> <li>Only generate the feature if the center pos hasn't moved to another biome that doesn't have the configured feature.</li> </ol> configured_feature/delta.json<pre><code>{\n  \"type\": \"minecraft:delta_feature\",\n  \"config\": {\n    \"contents\": {\n      \"Name\": \"minecraft:lava\",\n      \"Properties\": {\n        \"level\": \"0\"\n      }\n    },\n    \"rim\": {\n      \"Name\": \"minecraft:magma_block\"\n    },\n    \"rim_size\": {\n      \"type\": \"minecraft:uniform\", // (1)!\n      \"value\": {\n        \"max_inclusive\": 2,\n        \"min_inclusive\": 0\n      }\n    },\n    \"size\": {\n      \"type\": \"minecraft:uniform\",\n      \"value\": {\n        \"max_inclusive\": 7,\n        \"min_inclusive\": 3\n      }\n    }\n  }\n}\n</code></pre> <ol> <li>Random <code>int</code> in the range \\([2;0]\\).</li> </ol> placed_feature/delta.json<pre><code>{\n  \"feature\": \"minecraft:delta\",\n  \"placement\": [\n    {\n      \"type\": \"minecraft:count_on_every_layer\", // (1)!\n      \"count\": 40\n    },\n    {\n      \"type\": \"minecraft:biome\" // (2)!\n    }\n  ]\n}\n</code></pre> <ol> <li>Spreads the deltas to multiple layers.</li> <li>Only generate the feature if the center pos hasn't moved to another biome that doesn't have the configured feature.</li> </ol>"},{"location":"addon/worldgen/features/configurations/delta/#result","title":"Result","text":""},{"location":"addon/worldgen/features/configurations/disk/","title":"Disk feature","text":"<p>The <code>disk</code> feature allows you to place disks of blocks in the world.</p>"},{"location":"addon/worldgen/features/configurations/disk/#configuration","title":"Configuration","text":"<p>The <code>disk</code> feature has the following configuration options:</p> Option Type Description <code>state_provider</code> See below. The block state to use for the disk. <code>target</code> A <code>BlockPredicate</code>. Must be passed in order to generate the disk. <code>radius</code> An <code>IntProvider</code> (Range limit in Json is \\([0;8]\\)). Determines the radius of the disk. <code>half_height</code> An <code>int</code>. (Range limit in Json is \\([0;8]\\)). Defines half of the height of the disk. <p>In code, the <code>DiskConfiguration</code> class is used to configure the feature.</p>"},{"location":"addon/worldgen/features/configurations/disk/#state-provider","title":"State provider","text":"<p>The state provider has 2 main options. <code>fallback</code>, a <code>BlockStateProvider</code> that is used if none of the rules apply, and <code>rules</code>, a list of <code>Rule</code>s. Each rule has a <code>BlockPredicate</code> via the <code>if_true</code> option, and a <code>BlockStateProvider</code> via the <code>then</code> option. In code, the class is called <code>RuleBasedBlockStateProvider</code>.</p>"},{"location":"addon/worldgen/features/configurations/disk/#examples","title":"Examples","text":"<p>As an example, here's the configured and placed feature for sand disks in lakes:</p> KotlinJson ConfiguredFeatures.kt<pre><code>@OptIn(ExperimentalWorldGen::class)\n@Init(stage = InitStage.POST_PACK_PRE_WORLD)\nobject ConfiguredFeatures : FeatureRegistry by ExampleAddon.registry {\n\n    val DISK_SAND = registerConfiguredFeature(\n        \"disk_sand\",\n        Feature.DISK,\n        DiskConfiguration(\n            RuleBasedBlockStateProvider(\n                BlockStateProvider.simple(Blocks.SAND), // (1)!\n                listOf(\n                    RuleBasedBlockStateProvider.Rule(BlockPredicate.matchesBlocks(Direction.DOWN.normal, Blocks.AIR), BlockStateProvider.simple(Blocks.SANDSTONE)), // (2)!\n                )\n            ),\n            BlockPredicate.matchesBlocks(Blocks.DIRT, Blocks.GRASS_BLOCK), // (3)!\n            UniformInt.of(2, 6), // (4)!\n            2 // (5)!\n        )\n    )\n\n}\n</code></pre> <ol> <li>This is the fallback block used if none of the rules listed below apply.    Here, we use sand as the fallback if the block below is not air.</li> <li>If the block below is air, use sandstone since sand would fall down.</li> <li>Only allow <code>dirt</code> or <code>grass_block</code> in the center.</li> <li>Randomly chooses a radius between 2 and 6.</li> <li>The <code>half_height</code> of the disk.    The actual height will be \\(2 \\times 2 + 1 = 5\\) blocks.</li> </ol> PlacedFeatures.kt<pre><code>@OptIn(ExperimentalWorldGen::class)\n@Init(stage = InitStage.POST_PACK_PRE_WORLD)\nobject PlacedFeatures: FeatureRegistry by ExampleAddon.registry {\n\n    val DISK_SAND = placedFeature(\"disk_sand\", ConfiguredFeatures.DISK_SAND)\n        .count(3) // (1)!\n        .inSquareSpread() // (2)!\n        .moveToTopSolid() // (3)!\n        .blockPredicateFilter(BlockPredicate.matchesFluids(Fluids.WATER)) // (4)!\n        .biomeFilter() // (5)!\n        .register()\n\n}\n</code></pre> <ol> <li>3 tries per chunk.</li> <li>Spread the disks in a square.</li> <li>Makes sure to move the y coordinate to one block above the first solid block. This call is equivalent to     <pre><code>HeightmapPlacement.onHeightmap(Heightmap.Types.OCEAN_FLOOR_WG)\n</code></pre></li> <li>Only place the disk if the block is water.</li> <li>Only place the disk if the current biome has sand disks.</li> </ol> configured_feature/disk_sand.json<pre><code>{\n  \"type\": \"minecraft:disk\",\n  \"config\": {\n    \"half_height\": 2,\n    \"radius\": { // (1)!\n      \"type\": \"minecraft:uniform\",\n      \"value\": {\n        \"max_inclusive\": 6,\n        \"min_inclusive\": 2\n      }\n    },\n    \"state_provider\": {\n      \"fallback\": { // (2)!\n        \"type\": \"minecraft:simple_state_provider\",\n        \"state\": {\n          \"Name\": \"minecraft:sand\"\n        }\n      },\n      \"rules\": [  // (3)!\n        {\n          \"if_true\": {\n            \"type\": \"minecraft:matching_blocks\",\n            \"blocks\": \"minecraft:air\",\n            \"offset\": [\n              0,\n              -1,\n              0\n            ]\n          },\n          \"then\": {\n            \"type\": \"minecraft:simple_state_provider\",\n            \"state\": {\n              \"Name\": \"minecraft:sandstone\"\n            }\n          }\n        }\n      ]\n    },\n    \"target\": { // (4)!\n      \"type\": \"minecraft:matching_blocks\",\n      \"blocks\": [\n        \"minecraft:dirt\",\n        \"minecraft:grass_block\"\n      ]\n    }\n  }\n}\n</code></pre> <ol> <li>Randomly chooses a radius between 2 and 6.</li> <li>If the block isn't air, use sand.</li> <li>Otherwise, if the block below is air, use sandstone.</li> <li>Only allow <code>dirt</code> or <code>grass_block</code> in the center.</li> </ol> placed_feature/disk_sand.json<pre><code>{\n  \"feature\": \"minecraft:disk_sand\",\n  \"placement\": [\n    {\n      \"type\": \"minecraft:count\",\n      \"count\": 3 // (1)!\n    },\n    {\n      \"type\": \"minecraft:in_square\" // (2)!\n    },\n    {\n      \"type\": \"minecraft:heightmap\", // (3)!\n      \"heightmap\": \"OCEAN_FLOOR_WG\"\n    },\n    {\n      \"type\": \"minecraft:block_predicate_filter\", // (4)!\n      \"predicate\": {\n        \"type\": \"minecraft:matching_fluids\",\n        \"fluids\": \"minecraft:water\"\n      }\n    },\n    {\n      \"type\": \"minecraft:biome\" // (5)!\n    }\n  ]\n}\n</code></pre> <ol> <li>3 tries per chunk.</li> <li>Spread the disks in a square.</li> <li>Makes sure to move the y coordinate to one block above the first solid block.</li> <li>Only place the disk if the block is water.</li> <li>Only place the disk if the current biome has sand disks.</li> </ol>"},{"location":"addon/worldgen/features/configurations/disk/#result","title":"Result","text":""},{"location":"addon/worldgen/features/configurations/dripstone-cluster/","title":"Dripstone cluster feature","text":"<p>Warning</p> <p>Advanced Knowledge Required - This documentation page is intended for users with in-depth knowledge of the world   generation system. Beginner users may find the content challenging to understand.</p> <p>The <code>dripstone_cluster</code> feature allows you to add dripstone clusters to the world.</p>"},{"location":"addon/worldgen/features/configurations/dripstone-cluster/#configuration","title":"Configuration","text":"<p>The <code>dripstone_cluster</code> feature has the following configuration options: Some of these options might be a bit hard to understand, We'd recommend just checking out the example below.</p> Option Type Description <code>floor_to_ceiling_search_range</code> An <code>int</code>. (Range limit in Json is \\([1;512]\\)) Determines the maximum distance from the base of the dripstone cluster to the ceiling. <code>height</code> An <code>IntProvider</code> (Range limit in Json is \\([1;128]\\)) The height of the cluster <code>radius</code> An <code>IntProvider</code>. (Range limit in Json is \\([1;128]\\)) The radius of the cluster <code>max_stalagmite_stalactite_height_diff</code> An <code>int</code>. (Range limit in Json is \\([0;64]\\)) The maximum difference in height between a stalagmite and a stalactite. <code>height_deviation</code> An <code>int</code>. (Range limit in Json is \\([1;64]\\)) The height deviation. <code>dripstone_block_layer_thickness</code> An <code>IntProvider</code>. (Range limit in Json is \\([1;64]\\)) The dripstone block layer thickness. <code>density</code> A <code>FloatProvider</code>. (Range limit in Json is \\([0.0;2.0]\\)) The density of the dripstone cluster. <code>wetness</code> A <code>FloatProvider</code>. (Range limit in Json is \\([0.0;2.0]\\)) The wetness of the dripstone cluster. A higher value will lead to more water blocks. <code>chance_of_dripstone_column_at_max_distance_from_center</code> A <code>float</code>. (Range limit in Json is \\([0.0;1.0]\\)) The chance of a dripstone column at the maximum distance from the center. <code>max_distance_from_edge_affecting_chance_of_dripstone_column</code> An <code>int</code>. (Range limit in Json is \\([1;64]\\)) The maximum distance from the edge affecting the chance of a dripstone column. <code>max_distance_from_center_affecting_height_bias</code> An <code>int</code>. (Range limit in Json is \\([1;64]\\)) The maximum distance from the center affecting the height bias. <p>In code, the <code>DripstoneClusterConfiguration</code> class is used to configure the feature.</p>"},{"location":"addon/worldgen/features/configurations/dripstone-cluster/#example","title":"Example","text":"KotlinJson ConfiguredFeatures.kt<pre><code>@OptIn(ExperimentalWorldGen::class)\n@Init(stage = InitStage.POST_PACK_PRE_WORLD)\nobject ConfiguredFeatures : FeatureRegistry by ExampleAddon.registry {\n\n    val DRIPSTONE_CLUSTER = registerConfiguredFeature(\n        \"dripstone_cluster\",\n        Feature.DRIPSTONE_CLUSTER,\n        DripstoneClusterConfiguration(\n            12, // floorToCeilingSearchRange\n            UniformInt.of(3, 6), // height\n            UniformInt.of(2, 8), // radius\n            1, // maxStalagmiteStalactiteHeightDiff\n            3, // heightDeviation\n            UniformInt.of(2, 4), // dripstoneBlockLayerThickness\n            UniformFloat.of(0.3f, 0.7f), // density\n            ClampedNormalFloat.of(0.1f, 0.3f, 0.1f, 0.9f), // wetness\n            0.1f, // chanceOfDripstoneColumnAtMaxDistanceFromCenter\n            3, // maxDistanceFromEdgeAffectingChanceOfDripstoneColumn\n            8 // maxDistanceFromCenterAffectingHeightBias\n        )\n    )\n\n}\n</code></pre> PlacedFeatures.kt<pre><code>@OptIn(ExperimentalWorldGen::class)\n@Init(stage = InitStage.POST_PACK_PRE_WORLD)\nobject PlacedFeatures: FeatureRegistry by ExampleAddon.registry {\n\n    val DRIPSTONE_CLUSTER = placedFeature(\"dripstone_cluster\", ConfiguredFeatures.DRIPSTONE_CLUSTER)\n        .count(UniformInt.of(48, 96))\n        .inSquareSpread()\n        .inYWorldBounds() // (1)!\n        .biomeFilter()\n        .register()\n\n}\n</code></pre> <ol> <li>Call is equivalent to:     <pre><code>HeightRangePlacement.uniform(VerticalAnchor.bottom(), VerticalAnchor.absolute(256))\n</code></pre></li> </ol> configured_feature/dripstone_cluster.json<pre><code>{\n  \"type\": \"minecraft:dripstone_cluster\",\n  \"config\": {\n    \"chance_of_dripstone_column_at_max_distance_from_center\": 0.1,\n    \"density\": {\n      \"type\": \"minecraft:uniform\",\n      \"value\": {\n        \"max_exclusive\": 0.7,\n        \"min_inclusive\": 0.3\n      }\n    },\n    \"dripstone_block_layer_thickness\": {\n      \"type\": \"minecraft:uniform\",\n      \"value\": {\n        \"max_inclusive\": 4,\n        \"min_inclusive\": 2\n      }\n    },\n    \"floor_to_ceiling_search_range\": 12,\n    \"height\": {\n      \"type\": \"minecraft:uniform\",\n      \"value\": {\n        \"max_inclusive\": 6,\n        \"min_inclusive\": 3\n      }\n    },\n    \"height_deviation\": 3,\n    \"max_distance_from_center_affecting_height_bias\": 8,\n    \"max_distance_from_edge_affecting_chance_of_dripstone_column\": 3,\n    \"max_stalagmite_stalactite_height_diff\": 1,\n    \"radius\": {\n      \"type\": \"minecraft:uniform\",\n      \"value\": {\n        \"max_inclusive\": 8,\n        \"min_inclusive\": 2\n      }\n    },\n    \"wetness\": {\n      \"type\": \"minecraft:clamped_normal\",\n      \"value\": {\n        \"deviation\": 0.3,\n        \"max\": 0.9,\n        \"mean\": 0.1,\n        \"min\": 0.1\n      }\n    }\n  }\n}\n</code></pre> placed_feature/dripstone_cluster.json<pre><code>{\n  \"feature\": \"minecraft:dripstone_cluster\",\n  \"placement\": [\n    {\n      \"type\": \"minecraft:count\",\n      \"count\": {\n        \"type\": \"minecraft:uniform\",\n        \"value\": {\n          \"max_inclusive\": 96,\n          \"min_inclusive\": 48\n        }\n      }\n    },\n    {\n      \"type\": \"minecraft:in_square\"\n    },\n    {\n      \"type\": \"minecraft:height_range\",\n      \"height\": {\n        \"type\": \"minecraft:uniform\",\n        \"max_inclusive\": {\n          \"absolute\": 256\n        },\n        \"min_inclusive\": {\n          \"above_bottom\": 0\n        }\n      }\n    },\n    {\n      \"type\": \"minecraft:biome\"\n    }\n  ]\n}\n</code></pre>"},{"location":"addon/worldgen/features/configurations/dripstone-cluster/#result","title":"Result","text":""},{"location":"addon/worldgen/features/configurations/end-gateway/","title":"End gateway feature","text":"<p>The <code>end_gateway</code> feature can be used to place end gateways in the world.</p>"},{"location":"addon/worldgen/features/configurations/end-gateway/#configuration","title":"Configuration","text":"<p>An end gateway feature has the following configuration options:</p> Option Type Description <code>exit</code> (optional) A <code>BlockPos</code> (In Json, the <code>BlockPos</code> is represented via an array of coordinates. First element is the x coordinate and so on.) The exit location of the end gateway. <code>exact</code> <code>boolean</code> Whether entities should be teleported to the exact exit location. <p>In code, the <code>EndGatewayConfiguration</code> class is used to configure the feature.</p>"},{"location":"addon/worldgen/features/configurations/end-gateway/#example","title":"Example","text":"<p>Here's the configured and placed feature for the vanilla return end gateway:</p> KotlinJson ConfiguredFeatures.kt<pre><code>@OptIn(ExperimentalWorldGen::class)\n@Init(stage = InitStage.POST_PACK_PRE_WORLD)\nobject ConfiguredFeatures : FeatureRegistry by ExampleAddon.registry {\n\n    val END_GATEWAY_RETURN = registerConfiguredFeature(\n        \"end_gateway_return\",\n        Feature.END_GATEWAY,\n        EndGatewayConfiguration.knownExit( // (1)!\n            ServerLevel.END_SPAWN_POINT, // (2)!\n            true // (3)!\n        )\n    )\n\n}\n</code></pre> <ol> <li>If the exit location is still unknown during registration (for example for random teleportation), use    <pre><code>EndGatewayConfiguration.delayedExitSearch()\n</code></pre></li> <li>Constant for the end spawn point at \\((100|50|0)\\).</li> <li>Entities should be teleported to the exact exit location.</li> </ol> PlacedFeatures.kt<pre><code>@OptIn(ExperimentalWorldGen::class)\n@Init(stage = InitStage.POST_PACK_PRE_WORLD)\nobject PlacedFeatures : FeatureRegistry by ExampleAddon.registry {\n\n    val END_GATEWAY_RETURN = placedFeature(\"end_gateway_return\", ConfiguredFeatures.END_GATEWAY_RETURN)\n        .rarityFilter(700) // (1)!\n        .inSquareSpread() // (2)!\n        .moveToMotionBlocking() // (3)!\n        .randomVerticalOffset(UniformInt.of(3, 9)) // (4)!\n        .biomeFilter() // (5)!\n        .register()\n\n}\n</code></pre> <ol> <li>Give the end gateway a chance of \\(^1/_{700}\\) to spawn. Or in other words, the end gateway will spawn in 1 out of 700 chunks.</li> <li>Randomly offset the gateways in a square.</li> <li>Move the gateways to the surface. The call is equivalent to    <pre><code>HeightmapPlacement.onHeightmap(Heightmap.Types.MOTION_BLOCKING)\n</code></pre></li> <li>Randomly offset the gateways in the y direction.</li> <li>Only place the gateways in biomes that have end gateways</li> </ol> configured_feature/end_gateway_return.json<pre><code>{\n  \"type\": \"minecraft:end_gateway\",\n  \"config\": {\n    \"exact\": true,\n    \"exit\": [ // (1)!\n      100,\n      50,\n      0\n    ]\n  }\n}\n</code></pre> <ol> <li>The end spawn point is always at \\((100|50|0)\\)</li> </ol> placed_feature/end_gateway_return.json<pre><code>{\n  \"feature\": \"minecraft:end_gateway_return\",\n  \"placement\": [\n    {\n      \"type\": \"minecraft:rarity_filter\", // (1)!\n      \"chance\": 700\n    },\n    {\n      \"type\": \"minecraft:in_square\" // (2)!\n    },\n    {\n      \"type\": \"minecraft:heightmap\", // (3)!\n      \"heightmap\": \"MOTION_BLOCKING\"\n    },\n    {\n      \"type\": \"minecraft:random_offset\", // (4)!\n      \"xz_spread\": 0,\n      \"y_spread\": {\n        \"type\": \"minecraft:uniform\",\n        \"value\": {\n          \"max_inclusive\": 9,\n          \"min_inclusive\": 3\n        }\n      }\n    },\n    {\n      \"type\": \"minecraft:biome\" // (5)!\n    }\n  ]\n}\n</code></pre> <ol> <li>Give the end gateway a chance of \\(^1/_{700}\\) to spawn. Or in other words, the end gateway will spawn in 1 out of 700 chunks.</li> <li>Randomly offset the gateways in a square.</li> <li>Move the gateways to the surface.</li> <li>Randomly offset the gateways in the y direction.</li> <li>Only place the gateways in biomes that have end gateways.</li> </ol>"},{"location":"addon/worldgen/features/configurations/end-gateway/#result","title":"Result","text":""},{"location":"addon/worldgen/features/configurations/end-spike/","title":"End spike feature","text":"<p>The <code>end_spike</code> feature can be used to place end spikes (also known as obsidian pillars) in the world.</p>"},{"location":"addon/worldgen/features/configurations/end-spike/#configuration","title":"Configuration","text":"<p>The following configuration options are available:</p> Option Type Description <code>crystal_invulnerable</code> (optional in Json, defaults to <code>false</code>) <code>boolean</code> Whether the crystals on top of the end spikes should be invulnerable. <code>spikes</code> A <code>List</code> of <code>EndSpikes</code>. See below for more information The spikes to place. If the array is empty, the default end spikes are placed <code>crystal_beam_target</code> (optional) A <code>BlockPos</code> (In Json, the <code>BlockPos</code> is represented via an array of coordinates. First element is the x coordinate and so on.) The target of the crystal beam. <p>In code, the <code>SpikeConfiguration</code> class is used to configure the feature.</p>"},{"location":"addon/worldgen/features/configurations/end-spike/#endspikes","title":"EndSpikes","text":"<p>The <code>EndSpikes</code> can be configured with the following options:</p> Option Type Description <code>centerX</code> (optional in Json, defaults to <code>0</code>) <code>int</code> The x coordinate of the center of the spike. <code>centerZ</code> (optional in Json, defaults to <code>0</code>) <code>int</code> The z coordinate of the center of the spike. <code>radius</code> (optional in Json, defaults to <code>0</code>) <code>int</code> The radius of the spike. <code>height</code> (optional in Json, defaults to <code>0</code>) <code>int</code> The height of the spike. <code>guarded</code> (optional in Json, defaults to <code>false</code>) <code>boolean</code> Whether iron bars should be placed around the end crystal <p>The <code>SpikeFeature.EndSpike</code> class is used to configure the spikes in code.</p>"},{"location":"addon/worldgen/features/configurations/end-spike/#examples","title":"Examples","text":"<p>As an example, here's the configured feature used to place the default end spikes on the main island:</p> KotlinJson ConfiguredFeatures.kt<pre><code>@OptIn(ExperimentalWorldGen::class)\n@Init(stage = InitStage.POST_PACK_PRE_WORLD)\nobject ConfiguredFeatures : FeatureRegistry by ExampleAddon.registry {\n\n    val END_SPIKE = registerConfiguredFeature(\n        \"end_spike\",\n        Feature.END_SPIKE,\n        SpikeConfiguration(false, emptyList(), null) // (1)!\n    )\n\n}\n</code></pre> <ol> <li>Since Minecraft only needs the default end spikes, we don't need to configure anything. <code>false</code> means that the     crystals on top of the end spikes should not be invulnerable and <code>null</code> is the crystal beam target.</li> </ol> configured_feature/end_spike.json<pre><code>{\n  \"type\": \"minecraft:end_spike\",\n  \"config\": {\n    \"crystal_invulnerable\": false,\n    \"spikes\": [] // (1)!\n  }\n}\n</code></pre> <ol> <li>Since Minecraft only needs the default end spikes, we don't need to configure anything.</li> </ol> Example with a filled array KotlinJson ConfiguredFeatures.kt<pre><code>val END_SPIKE = registerConfiguredFeature(\n    \"end_spike\",\n    Feature.END_SPIKE,\n    SpikeConfiguration(\n        false, // (1)!\n        listOf(\n            EndSpike(42, 0, 2, 82, true), // (2)!\n            EndSpike(33, 24, 4, 94, false),\n            EndSpike(12, 39, 5, 103, false),\n            EndSpike(-13, 39, 2, 79, true),\n            EndSpike(-34, 24, 4, 97, false),\n            EndSpike(-42, -1, 3, 88, false),\n            EndSpike(-34, -25, 3, 91, false),\n            EndSpike(-13, -40, 3, 85, false),\n            EndSpike(12, -40, 4, 100, false),\n            EndSpike(33, -25, 2, 76, false)\n        ),\n        null // (3)!\n    )\n)\n</code></pre> <ol> <li>Don't make the crystals invulnerable.</li> <li>The first spike is at the coordinates <code>42, 0</code> with a radius of <code>2</code> and a height of <code>82</code>. <code>true</code> specifies that     iron bars should be placed around the end crystal.</li> <li>Don't specify any specific target for the crystal beam.</li> </ol> configured_feature/end_spike.json<pre><code>{\n  \"type\": \"minecraft:end_spike\",\n  \"config\": {\n    \"crystal_invulnerable\": false,\n    \"spikes\": [\n      {\n        \"centerX\": 42,\n        \"centerZ\": 0,\n        \"radius\": 2,\n        \"height\": 82,\n        \"guarded\": true\n      },\n      {\n        \"centerX\": 33,\n        \"centerZ\": 24,\n        \"radius\": 4,\n        \"height\": 94,\n        \"guarded\": false\n      },\n      {\n        \"centerX\": 12,\n        \"centerZ\": 39,\n        \"radius\": 5,\n        \"height\": 103,\n        \"guarded\": false\n      },\n      {\n        \"centerX\": -13,\n        \"centerZ\": 39,\n        \"radius\": 2,\n        \"height\": 79,\n        \"guarded\": true\n      },\n      {\n        \"centerX\": -34,\n        \"centerZ\": 24,\n        \"radius\": 4,\n        \"height\": 97,\n        \"guarded\": false\n      },\n      {\n        \"centerX\": -42,\n        \"centerZ\": -1,\n        \"radius\": 3,\n        \"height\": 88,\n        \"guarded\": false\n      },\n      {\n        \"centerX\": -34,\n        \"centerZ\": -25,\n        \"radius\": 3,\n        \"height\": 91,\n        \"guarded\": false\n      },\n      {\n        \"centerX\": -13,\n        \"centerZ\": -40,\n        \"radius\": 3,\n        \"height\": 85,\n        \"guarded\": false\n      },\n      {\n        \"centerX\": 12,\n        \"centerZ\": -40,\n        \"radius\": 4,\n        \"height\": 100,\n        \"guarded\": false\n      },\n      {\n        \"centerX\": 33,\n        \"centerZ\": -25,\n        \"radius\": 2,\n        \"height\": 76,\n        \"guarded\": false\n      }\n    ]\n  }\n}\n</code></pre> KotlinJson PlacedFeatures.kt<pre><code>@OptIn(ExperimentalWorldGen::class)\nobject PlacedFeatures : FeatureRegistry by ExampleAddon.registry {\n\n    val END_SPIKE = placedFeature(\"end_spike\", ConfiguredFeatures.END_SPIKE)\n        .biomeFilter() // (1)!\n        .register()\n\n}\n</code></pre> <ol> <li>Most of the placement logic is handled by the feature itself. The only thing we need to do is to specify that the     feature should only be placed in biomes that have end spikes.</li> </ol> placed_feature/end_spike.json<pre><code>{\n  \"feature\": \"minecraft:end_spike\",\n  \"placement\": [\n    {\n      \"type\": \"minecraft:biome\" // (1)!\n    }\n  ]\n}\n</code></pre> <ol> <li>Most of the placement logic is handled by the feature itself. The only thing we need to do is to specify that the     feature should only be placed in biomes that have end spikes.</li> </ol>"},{"location":"addon/worldgen/features/configurations/end-spike/#result","title":"Result","text":""},{"location":"addon/worldgen/features/configurations/fill-layer/","title":"Fill layer feature","text":"<p>The <code>fill_layer</code> feature can be used to fill an entire 16x16 chunk area with a single block.</p>"},{"location":"addon/worldgen/features/configurations/fill-layer/#configuration","title":"Configuration","text":"<p>The following configuration options are available:</p> Option Type Description <code>height</code> An <code>int</code>. (Range limit in Json is \\([0;4064 ]\\)) The height of the layer to fill (starting at the min build height). <code>state</code> A <code>BlockState</code> The block state to use for the layer. <p>In code, the <code>LayerConfiguration</code> class is used to configure the feature.</p>"},{"location":"addon/worldgen/features/configurations/fill-layer/#example","title":"Example","text":"<p>As an example, here's a configured- and placed feature to add a layer of grass on top of a default flat world.</p> KotlinJson ConfiguredFeatures.kt<pre><code>@Init(stage = InitStage.POST_PACK_PRE_WORLD)\n@OptIn(ExperimentalWorldGen::class)\nobject ConfiguredFeatures : FeatureRegistry by ExampleAddon.registry {\n\n    val FILL_LAYER_GRASS = registerConfiguredFeature(\n        \"fill_layer_grass\",\n        Feature.FILL_LAYER,\n        LayerConfiguration(4, Blocks.GRASS.defaultBlockState()) // (1)!\n    )\n\n}\n</code></pre> <ol> <li>Add a layer of grass at height 4.</li> </ol> PlacedFeatures.kt<pre><code>@OptIn(ExperimentalWorldGen::class)\n@Init(stage = InitStage.POST_PACK_PRE_WORLD)\nobject PlacedFeatures : FeatureRegistry by ExampleAddon.registry {\n\n    val FILL_LAYER_GRASS = placedFeature(\"fill_layer_grass\", ConfiguredFeatures.FILL_LAYER_GRASS).register()\n\n}\n</code></pre> configured_feature/fill_layer_grass.json<pre><code>{\n  \"height\": 4,\n  \"state\": {\n    \"Name\": \"minecraft:grass\"\n  }\n}\n</code></pre> placed_feature/fill_layer_grass.json<pre><code>{\n  \"feature\": \"minecraft:fill_layer_grass\",\n  \"placement\": []\n}\n</code></pre>"},{"location":"addon/worldgen/features/configurations/forest-rock/","title":"Forest rock feature","text":"<p>The <code>forest_rock</code> feature can be used to generate small \\(3x3\\) rocks in the world.</p>"},{"location":"addon/worldgen/features/configurations/forest-rock/#configuration","title":"Configuration","text":"<p>Only the block state used for the rocks is configurable:</p> Option Type Description <code>state</code> A  <code>BlockState</code> The block state to use for the rock. <p>In code, the <code>BlockStateConfiguration</code> class is used to configure the feature.</p>"},{"location":"addon/worldgen/features/configurations/forest-rock/#example","title":"Example","text":"KotlinJson ConfiguredFeatures.kt<pre><code>@OptIn(ExperimentalWorldGen::class)\n@Init(stage = InitStage.POST_PACK_PRE_WORLD)\nobject ConfiguredFeatures : FeatureRegistry by ExampleAddon.registry {\n\n    val FOREST_ROCK = registerConfiguredFeature(\n        \"forest_rock\",\n        Feature.FOREST_ROCK,\n        BlockStateConfiguration(Blocks.MOSSY_COBBLESTONE.defaultBlockState())\n    )\n\n}\n</code></pre> PlacedFeatures.kt<pre><code>@OptIn(ExperimentalWorldGen::class)\n@Init(stage = InitStage.POST_PACK_PRE_WORLD)\nobject PlacedFeatures : FeatureRegistry by ExampleAddon.registry {\n\n    val FOREST_ROCK = placedFeature(\"forest_rock\", ConfiguredFeatures.FOREST_ROCK)\n        .count(2) // (1)!\n        .inSquareSpread() // (2)!\n        .moveToMotionBlocking() // (3)!\n        .biomeFilter() // (4)!\n        .register()\n\n}\n</code></pre> <ol> <li>Generate 2 rocks per chunk.</li> <li>Randomly offset the x- and z-coordinates of the rock.</li> <li>Set the y-coordinate of the rock to the highest motion-blocking block. The call is equivalent to    <pre><code>HeightmapPlacement.onHeightmap(Heightmap.Types.MOTION_BLOCKING)\n</code></pre></li> <li>Only generate the feature if the center pos hasn't moved to another biome that doesn't have the <code>forest_rock</code> feature.</li> </ol> configured_feature/forest_rock.json<pre><code>{\n  \"type\": \"minecraft:forest_rock\",\n  \"config\": {\n    \"state\": {\n      \"Name\": \"minecraft:mossy_cobblestone\"\n    }\n  }\n}\n</code></pre> placed_feature/forest_rock.json<pre><code>{\n  \"feature\": \"minecraft:forest_rock\",\n  \"placement\": [\n    {\n      \"type\": \"minecraft:count\",\n      \"count\": 2 // (1)!\n    },\n    {\n      \"type\": \"minecraft:in_square\" // (2)!\n    },\n    {\n      \"type\": \"minecraft:heightmap\",\n      \"heightmap\": \"MOTION_BLOCKING\" // (3)!\n    },\n    {\n      \"type\": \"minecraft:biome\" // (4)!\n    }\n  ]\n}\n</code></pre> <ol> <li>Generate 2 rocks per chunk.</li> <li>Randomly offset the x- and z-coordinates of the rock.</li> <li>Set the y-coordinate of the rock to the highest motion-blocking block.</li> <li>Only generate the feature if center pos hasn't moved to another biome that doesn't have the <code>forest_rock</code> feature.</li> </ol>"},{"location":"addon/worldgen/features/configurations/forest-rock/#result","title":"Result","text":"AloneNaturally generated <p><p> </p></p> <p><p> </p></p>"},{"location":"addon/worldgen/features/configurations/fossil/","title":"Fossils","text":"<p>TODO</p>"},{"location":"addon/worldgen/features/configurations/geode/","title":"Geode feature","text":"<p>Warning</p> <p>Advanced Knowledge Required - This documentation page is intended for users with in-depth knowledge of the world   generation system. Beginner users may find the content challenging to understand.</p> <p>The <code>geode</code> feature can be used to generate geode-like structures in the world.</p>"},{"location":"addon/worldgen/features/configurations/geode/#configuration","title":"Configuration","text":"<p>The <code>geode</code> feature allows a very wide range of configuration options. The more nested configuration options are explained below the main table.</p> Option Type Description Amethyst geode value <code>blocks</code> See below. Specifies which blocks to use for the geode. / <code>layers</code> See below. Specifies the radius of each layer. / <code>crack</code> See below. Specifies options about the crack in the geode. / <code>use_potential_placements_chance</code> (optional in Json, defaults to <code>0.35</code>) A <code>double</code> in the range \\([0.0;1.0]\\). The chance each inner block to get a inner placement. <code>0.35</code> <code>use_alternate_layer0_chance</code>  (optional in Json, defaults to <code>0.0</code>) A <code>double</code> in the range \\([0.0;1.0]\\). The chance for a inner layer block to use the specified alternative block. <code>0.083</code> <code>placements_require_layer0_alternate</code> (optional in Json, defaults to <code>true</code>) A <code>boolean</code> If <code>true</code>, the inner placement will only be placed on the specified alternative block. <code>true</code> <code>outer_wall_distance</code> (optional in Json, defaults to a random int. Either <code>4</code> or <code>5</code>) An <code>IntProvider</code>. (Range limit in Json is \\([1;20]\\)) The offset of each coordinate from the feature origin. Random <code>int</code> between <code>4</code> and <code>6</code> <code>distribution_points</code> (optional in Json, defaults to a random int. Either <code>3</code> or <code>4</code> ) An <code>IntProvider</code>. (Range limit in Json is \\([1;20]\\)) How often to check for invalid blocks near the center of the geode. Random <code>int</code>. Either <code>3</code> or <code>4</code> <code>point_offset</code> (optional in Json, defaults to a random int. Either <code>1</code> or <code>2</code>) An <code>IntProvider</code>. (Range limit in Json is \\([1;10]\\)) The offset of each point. Random <code>int</code>. Either <code>1</code> or <code>2</code> <code>min_gen_offset</code> (optional in Json, defaults to <code>-16</code>) An <code>int</code> The minimum Chebyshev distance of each block from the feature origin. <code>-16</code> <code>max_gen_offset</code> (optional in Json, defaults to <code>16</code>) An <code>int</code> The maximum Chebyshev distance of each block from the feature origin. <code>16</code> <code>noise_multiplier</code> (optional in Json, defaults to <code>0.05</code>) A <code>double</code> in the range \\([0.0;1.0]\\). The multiplier for the noise value. <code>0.05</code> <code>invalid_blocks_threshold</code> An <code>int</code> The max. amount of invalid blocks. If the threshold is exceeded, the feature won't be generated <code>1</code> <p>In code, the <code>GeodeConfiguration</code> class is used to configure the feature.</p>"},{"location":"addon/worldgen/features/configurations/geode/#blocks","title":"<code>blocks</code>","text":"<p>The blocks configuration of the geode. It has the following options:</p> Option Type Description Amethyst geode value <code>filling_provider</code> <code>BlockStateProvider</code> The block to use for the filling of the geode. Should be air in most cases. <code>minecraft:air</code> <code>inner_layer_provider</code> <code>BlockStateProvider</code> The block to use for the inner layer of the geode. <code>minecraft:amethyst_block</code> <code>alternate_inner_layer_provider</code> <code>BlockStateProvider</code> The block that is randomly spread inside the inner layer. <code>minecraft:budding_amethyst</code> <code>middle_layer_provider</code> <code>BlockStateProvider</code> The block to use for the middle layer of the geode. <code>minecraft:calcite</code> <code>outer_layer_provider</code> <code>BlockStateProvider</code> The block to use for the outer layer of the geode. <code>minecraft:smooth_basalt</code> <code>inner_placements</code> A list of <code>BlockStateProvider</code>s. A list of blocks to randomly place inside the geode. (cannot be empty!) <code>minecraft:small_amethyst_bud</code>, <code>minecraft:medium_amethyst_bud</code>, ... <code>cannot_replace</code> A block tag (Starting with <code>#</code> in Json). Defines which block shouldn't be replaced when placing the geode. <code>#minecraft:features_cannot_replace</code> <code>invalid_blocks</code> A block tag (Starting with <code>#</code> in Json). If the amount of blocks matching this tag exceeds the above defined threshold the geode won't be placed. Currently not usable because of a Minecraft bug <code>#minecraft:geode_invalid_blocks</code> <p>In code, the <code>GeodeBlockSettings</code> class is used to configure the blocks of the geode.</p>"},{"location":"addon/worldgen/features/configurations/geode/#layers","title":"<code>layers</code>","text":"<p>Defines the max radius of each layer of the geode. The higher the value the higher the max radius of the respective layer. The following options are all <code>double</code>s in the range \\([0.01;50.0]\\).</p> Option Description Amethyst geode value <code>filling</code> (optional in Json, defaults to <code>1.7</code>) The max radius of the filling layer. (Range limit in Json is \\([0.01;50.0]\\)) <code>1.7</code> <code>inner_layer</code> (optional in Json, defaults to <code>2.2</code>) The max radius of the inner layer. (Range limit in Json is \\([0.01;50.0]\\)) <code>2.2</code> <code>middle_layer</code> (optional in Json, defaults to <code>3.2</code>) The max radius of the middle layer. (Range limit in Json is \\([0.01;50.0]\\)) <code>3.2</code> <code>outer_layer</code> (optional in Json, defaults to <code>4.2</code>) The max radius of the outer layer. (Range limit in Json is \\([0.01;50.0]\\)) <code>4.2</code> <p>In code, the <code>GeodeLayerSettings</code> class is used to configure the layers of the geode.</p>"},{"location":"addon/worldgen/features/configurations/geode/#crack","title":"<code>crack</code>","text":"<p>The crack configuration of the geode. It has the following options:</p> Option Type Description Amethyst geode value <code>generate_crack_chance</code> (optional in Json, defaults to <code>1.0</code>) A <code>double</code> in the range \\([0.0;1.0]\\). The chance that a crack will be generated. <code>0.95</code> <code>base_crack_size</code> (optional in Json, defaults to <code>2.0</code>) A <code>double</code>. (Range limit in Json is \\([0.0;5.0]\\)) The base size of a crack. <code>2.0</code> <code>crack_point_offset</code> (optional in Json, defaults to <code>2</code>) An <code>int</code>. (Range limit in Json is \\([0;10]\\)) The offset of the crack point. <code>2</code> <p>In code, the <code>GeodeCrackSettings</code> class is used to configure the crack of the geode.</p>"},{"location":"addon/worldgen/features/configurations/geode/#example","title":"Example","text":"KotlinJson ConfiguredFeatures.kt<pre><code>@OptIn(ExperimentalWorldGen::class)\n@Init(stage = InitStage.POST_PACK_PRE_WORLD)\nobject ConfiguredFeatures : FeatureRegistry by ExampleAddon.registry {\n\n    val AMETHYST_GEODE = registerConfiguredFeature(\n        \"amethyst_geode\",\n        Feature.GEODE,\n        GeodeConfiguration(\n            GeodeBlockSettings(\n                BlockStateProvider.simple(Blocks.AIR), // fillingProvider\n                BlockStateProvider.simple(Blocks.AMETHYST_BLOCK), // innerLayerProvider\n                BlockStateProvider.simple(Blocks.BUDDING_AMETHYST), // alternateInnerLayerProvider\n                BlockStateProvider.simple(Blocks.CALCITE), // middleLayerProvider\n                BlockStateProvider.simple(Blocks.SMOOTH_BASALT), // outerLayerProvider\n                listOf( // innerPlacements\n                    Blocks.SMALL_AMETHYST_BUD.defaultBlockState(),\n                    Blocks.MEDIUM_AMETHYST_BUD.defaultBlockState(),\n                    Blocks.LARGE_AMETHYST_BUD.defaultBlockState(),\n                    Blocks.AMETHYST_CLUSTER.defaultBlockState()\n                ),\n                BlockTags.FEATURES_CANNOT_REPLACE, // cannotReplace\n                BlockTags.GEODE_INVALID_BLOCKS // invalidBlocks\n            ),\n            GeodeLayerSettings(\n                1.7, // filling\n                2.2, // innerLayer\n                3.2, // middleLayer\n                4.2 // outerLayer\n            ),\n            GeodeCrackSettings(\n                0.95, // generateCrackChance\n                2.0, // baseCrackSize\n                2 // crackPointOffset\n            ),\n            .35, // usePotentialPlacementsChance\n            .083, // useAlternateLayer0Chance\n            true, // placementsRequireLayer0Alternate\n            UniformInt.of(4, 6), // outerWallDistance\n            UniformInt.of(3, 4), // distributionPoints\n            UniformInt.of(1, 2), // pointOffset\n            -16, // minGenOffset\n            16, // maxGenOffset\n            0.05, // noiseMultiplier\n            1 // invalidBlocksThreshold\n        )\n    )\n\n}\n</code></pre> PlacedFeatures.kt<pre><code>@OptIn(ExperimentalWorldGen::class)\n@Init(stage = InitStage.POST_PACK_PRE_WORLD)\nobject PlacedFeatures : FeatureRegistry by ExampleAddon.registry {\n\n    val AMETHYST_GEODE = placedFeature(\"amethyst_geode\", ConfiguredFeatures.AMETHYST_GEODE)\n        .rarityFilter(24)\n        .inSquareSpread()\n        .heightRangeUniform(VerticalAnchor.aboveBottom(6), VerticalAnchor.absolute(30))\n        .biomeFilter()\n        .register()\n\n}\n</code></pre> configured_feature/amethyst_geode.json<pre><code>{\n  \"type\": \"minecraft:geode\",\n  \"config\": {\n    \"blocks\": {\n      \"alternate_inner_layer_provider\": {\n        \"type\": \"minecraft:simple_state_provider\",\n        \"state\": {\n          \"Name\": \"minecraft:budding_amethyst\"\n        }\n      },\n      \"cannot_replace\": \"#minecraft:features_cannot_replace\",\n      \"filling_provider\": {\n        \"type\": \"minecraft:simple_state_provider\",\n        \"state\": {\n          \"Name\": \"minecraft:air\"\n        }\n      },\n      \"inner_layer_provider\": {\n        \"type\": \"minecraft:simple_state_provider\",\n        \"state\": {\n          \"Name\": \"minecraft:amethyst_block\"\n        }\n      },\n      \"inner_placements\": [\n        {\n          \"Name\": \"minecraft:small_amethyst_bud\",\n          \"Properties\": {\n            \"facing\": \"up\",\n            \"waterlogged\": \"false\"\n          }\n        },\n        {\n          \"Name\": \"minecraft:medium_amethyst_bud\",\n          \"Properties\": {\n            \"facing\": \"up\",\n            \"waterlogged\": \"false\"\n          }\n        },\n        {\n          \"Name\": \"minecraft:large_amethyst_bud\",\n          \"Properties\": {\n            \"facing\": \"up\",\n            \"waterlogged\": \"false\"\n          }\n        },\n        {\n          \"Name\": \"minecraft:amethyst_cluster\",\n          \"Properties\": {\n            \"facing\": \"up\",\n            \"waterlogged\": \"false\"\n          }\n        }\n      ],\n      \"invalid_blocks\": \"#minecraft:geode_invalid_blocks\",\n      \"middle_layer_provider\": {\n        \"type\": \"minecraft:simple_state_provider\",\n        \"state\": {\n          \"Name\": \"minecraft:calcite\"\n        }\n      },\n      \"outer_layer_provider\": {\n        \"type\": \"minecraft:simple_state_provider\",\n        \"state\": {\n          \"Name\": \"minecraft:smooth_basalt\"\n        }\n      }\n    },\n    \"crack\": {\n      \"base_crack_size\": 2.0,\n      \"crack_point_offset\": 2,\n      \"generate_crack_chance\": 0.95\n    },\n    \"distribution_points\": {\n      \"type\": \"minecraft:uniform\",\n      \"value\": {\n        \"max_inclusive\": 4,\n        \"min_inclusive\": 3\n      }\n    },\n    \"invalid_blocks_threshold\": 1,\n    \"layers\": {\n      \"filling\": 1.7,\n      \"inner_layer\": 2.2,\n      \"middle_layer\": 3.2,\n      \"outer_layer\": 4.2\n    },\n    \"max_gen_offset\": 16,\n    \"min_gen_offset\": -16,\n    \"noise_multiplier\": 0.05,\n    \"outer_wall_distance\": {\n      \"type\": \"minecraft:uniform\",\n      \"value\": {\n        \"max_inclusive\": 6,\n        \"min_inclusive\": 4\n      }\n    },\n    \"placements_require_layer0_alternate\": true,\n    \"point_offset\": {\n      \"type\": \"minecraft:uniform\",\n      \"value\": {\n        \"max_inclusive\": 2,\n        \"min_inclusive\": 1\n      }\n    },\n    \"use_alternate_layer0_chance\": 0.083,\n    \"use_potential_placements_chance\": 0.35\n  }\n}\n</code></pre> placed_feature/amethyst_geode.json<pre><code>{\n  \"feature\": \"minecraft:amethyst_geode\",\n  \"placement\": [\n    {\n      \"type\": \"minecraft:rarity_filter\",\n      \"chance\": 24\n    },\n    {\n      \"type\": \"minecraft:in_square\"\n    },\n    {\n      \"type\": \"minecraft:height_range\",\n      \"height\": {\n        \"type\": \"minecraft:uniform\",\n        \"max_inclusive\": {\n          \"absolute\": 30\n        },\n        \"min_inclusive\": {\n          \"above_bottom\": 6\n        }\n      }\n    },\n    {\n      \"type\": \"minecraft:biome\"\n    }\n  ]\n}\n</code></pre>"},{"location":"addon/worldgen/features/configurations/geode/#result","title":"Result","text":""},{"location":"addon/worldgen/features/configurations/huge-fungus/","title":"Huge fungus feature","text":"<p>The <code>huge_fungus</code> feature can be used to place huge fungi in the world (used for warped and crimson forests in vanilla).</p>"},{"location":"addon/worldgen/features/configurations/huge-fungus/#configuration","title":"Configuration","text":"<p>The <code>huge_fungus</code> feature has the following configuration options:</p> Option Type Description <code>valid_base_block</code> A <code>BlockState</code> The block state that needs to be present below the fungus. <code>stem_state</code> A <code>BlockState</code> The block state to use for the stem of the fungus. <code>hat_state</code> A <code>BlockState</code> The block state to use for the hat of the fungus. <code>decor_state</code> A <code>BlockState</code> The block state to randomly place under the hat as decoration. (For example shroomlight) <code>planted</code> (optional in Json, defaults to <code>false</code>) A <code>boolean</code> If set to <code>false</code>, can only replace <code>PLANT</code> material blocks and doesn't drop items when replaced. <p>In code, the <code>HugeFungusConfiguration</code> class is used to configure the feature.</p>"},{"location":"addon/worldgen/features/configurations/huge-fungus/#example","title":"Example","text":"<p>As an example, here's the configured- and placed feature for the warped fungus:</p> KotlinJson ConfiguredFeatures.kt<pre><code>@OptIn(ExperimentalWorldGen::class)\n@Init(stage = InitStage.POST_PACK_PRE_WORLD)\nobject ConfiguredFeatures : FeatureRegistry by ExampleAddon.registry {\n\n    val WARPED_FUNGUS = registerConfiguredFeature(\n        \"warped_fungus\",\n        Feature.HUGE_FUNGUS,\n        HugeFungusConfiguration(\n            Blocks.WARPED_NYLIUM.defaultBlockState(), // (1)!\n            Blocks.WARPED_STEM.defaultBlockState(), // (2)!\n            Blocks.WARPED_WART_BLOCK.defaultBlockState(), // (3)!\n            Blocks.SHROOMLIGHT.defaultBlockState(), // (4)!\n            false // (5)!\n        )\n    )\n\n}\n</code></pre> <ol> <li>Only place the fungus on warped nylium.</li> <li>The stem of the fungus.</li> <li>The hat of the fungus.</li> <li>Randomly placed shroomlight under the hat.</li> <li>The fungus is automatically generated, so it shouldn't drop items when another fungus grows into it.</li> </ol> PlacedFeatures.kt<pre><code>@OptIn(ExperimentalWorldGen::class)\n@Init(stage = InitStage.POST_PACK_PRE_WORLD)\nobject PlacedFeatures : FeatureRegistry by ExampleAddon.registry {\n\n    val WARPED_FUNGUS = placedFeature(\"warped_fungus\", ConfiguredFeatures.WARPED_FUNGUS)\n        .countOnEveryLayer(8)\n        .biomeFilter()\n        .register()\n\n}\n</code></pre> configured_feature/warped_fungus.json<pre><code>{\n  \"type\": \"minecraft:huge_fungus\",\n  \"config\": {\n    \"decor_state\": {\n      \"Name\": \"minecraft:shroomlight\" // (1)!\n    },\n    \"hat_state\": {\n      \"Name\": \"minecraft:warped_wart_block\"\n    },\n    \"stem_state\": {\n      \"Name\": \"minecraft:warped_stem\",\n      \"Properties\": {\n        \"axis\": \"y\"\n      }\n    },\n    \"valid_base_block\": {\n      \"Name\": \"minecraft:warped_nylium\" // (2)!\n    },\n    \"planted\": false // (3)!\n  }\n}\n</code></pre> <ol> <li>Randomly placed shroomlight under the hat.</li> <li>Only place the fungus on warped nylium.</li> <li>The fungus is automatically generated, so it shouldn't drop items when another fungus grows into it.</li> </ol> placed_feature/warped_fungi.json<pre><code>{\n  \"feature\": \"minecraft:warped_fungus\",\n  \"placement\": [\n    {\n      \"type\": \"minecraft:count_on_every_layer\",\n      \"count\": 8\n    },\n    {\n      \"type\": \"minecraft:biome\"\n    }\n  ]\n}\n</code></pre>"},{"location":"addon/worldgen/features/configurations/huge-fungus/#result","title":"Result","text":"AloneNaturally generated <p><p> </p></p> <p><p> </p></p>"},{"location":"addon/worldgen/features/configurations/huge-mushrooms/","title":"Huge mushroom features","text":"<p>The <code>huge_brown_mushroom</code> and <code>huge_red_mushroom</code> features can be used to add huge mushrooms to a biome.</p>"},{"location":"addon/worldgen/features/configurations/huge-mushrooms/#configuration","title":"Configuration","text":"Option Type Description <code>cap_provider</code> A <code>BlockStateProvider</code> Determines the block to use for the cap of the mushroom. <code>stem_provider</code> A <code>BlockStateProvider</code> Determines the block to use for the stem of the mushroom. <code>foliage_radius</code> (optional in Json, defaults to 2) An <code>int</code> Determines the radius of the cap. <p>In code, the <code>HugeMushroomFeatureConfiguration</code> class is used to configure the feature.</p>"},{"location":"addon/worldgen/features/configurations/huge-mushrooms/#example","title":"Example","text":"<p>As an example, here's the configured- and placed feature for the default huge red mushroom</p> KotlinJson ConfiguredFeatures.kt<pre><code>@OptIn(ExperimentalWorldGen::class)\n@Init(stage = InitStage.POST_PACK_PRE_WORLD)\nobject ConfiguredFeatures : FeatureRegistry by ExampleAddon.registry {\n\n    val HUGE_RED_MUSHROOM = registerConfiguredFeature(\n        \"huge_red_mushroom\",\n        Feature.HUGE_RED_MUSHROOM,\n        HugeMushroomFeatureConfiguration(\n            BlockStateProvider.simple(Blocks.RED_MUSHROOM_BLOCK.defaultBlockState().setValue(HugeMushroomBlock.DOWN, false) as BlockState), // (1)!\n            BlockStateProvider.simple((Blocks.MUSHROOM_STEM.defaultBlockState().setValue(HugeMushroomBlock.UP, false) as BlockState).setValue(HugeMushroomBlock.DOWN, false) as BlockState), // (2)!\n            2 // (3)!\n        )\n    )\n\n}\n</code></pre> <ol> <li>Use a mushroom block with the <code>down</code> property set to <code>false</code> as the cap.</li> <li>Use a mushroom stem with the <code>up</code> and <code>down</code> properties set to <code>false</code> as the stem.</li> <li>Use a radius of 2 for the cap.</li> </ol> PlacedFeatures.kt<pre><code>@OptIn(ExperimentalWorldGen::class)\n@Init(stage = InitStage.POST_PACK_PRE_WORLD)\nobject PlacedFeatures : FeatureRegistry by ExampleAddon.registry {\n\n    val HUGE_RED_MUSHROOM = placedFeature(\"huge_red_mushroom\", ConfiguredFeatures.HUGE_RED_MUSHROOM).register()\n\n}\n</code></pre> configured_feature/huge_red_mushroom.json<pre><code>{\n  \"type\": \"minecraft:huge_red_mushroom\",\n  \"config\": {\n    \"cap_provider\": {\n      \"type\": \"minecraft:simple_state_provider\",\n      \"state\": {\n        \"Name\": \"minecraft:red_mushroom_block\",\n        \"Properties\": {\n          \"down\": \"false\",\n          \"east\": \"true\",\n          \"north\": \"true\",\n          \"south\": \"true\",\n          \"up\": \"true\",\n          \"west\": \"true\"\n        }\n      }\n    },\n    \"stem_provider\": {\n      \"type\": \"minecraft:simple_state_provider\",\n      \"state\": {\n        \"Name\": \"minecraft:mushroom_stem\",\n        \"Properties\": {\n          \"down\": \"false\",\n          \"east\": \"true\",\n          \"north\": \"true\",\n          \"south\": \"true\",\n          \"up\": \"false\",\n          \"west\": \"true\"\n        }\n      }\n    },  \n    \"foliage_radius\": 2\n  }\n}\n</code></pre> placed_feature/huge_red_mushroom.json<pre><code>{\n  \"feature\": {\n  \"feature\": \"minecraft:huge_red_mushroom\",\n  \"placement\": []\n}\n</code></pre>"},{"location":"addon/worldgen/features/configurations/huge-mushrooms/#result","title":"Result","text":"AloneNaturally generated <p><p> </p></p> <p><p> </p></p>"},{"location":"addon/worldgen/features/configurations/iceberg/","title":"Iceberg feature","text":"<p>The <code>iceberg</code> feature allows you to add icebergs to the world.</p>"},{"location":"addon/worldgen/features/configurations/iceberg/#configuration","title":"Configuration","text":"<p>The <code>iceberg</code> feature only has one configuration option:</p> Option Type Description <code>state</code> A <code>BlockState</code> The block state to use for the icebergs. <p>In code, the <code>BlockStateConfiguration</code> class is used to configure the feature.</p>"},{"location":"addon/worldgen/features/configurations/iceberg/#example","title":"Example","text":"<p>As an example, here's the configured and placed feature for the blue icebergs in the deep frozen ocean.</p> KotlinJson ConfiguredFeatures.kt<pre><code>@OptIn(ExperimentalWorldGen::class)\n@Init(stage = InitStage.POST_PACK_PRE_WORLD)\nobject ConfiguredFeatures : FeatureRegistry by ExampleAddon.registry {\n\n    val ICEBERG_BLUE = registerConfiguredFeature(\n        \"iceberg_blue\",\n        Feature.ICEBERG,\n        BlockStateConfiguration(Blocks.BLUE_ICE.defaultBlockState())\n    )\n\n}\n</code></pre> PlacedFeatures.kt<pre><code>@OptIn(ExperimentalWorldGen::class)\n@Init(stage = InitStage.POST_PACK_PRE_WORLD)\nobject PlacedFeatures : FeatureRegistry by ExampleAddon.registry {\n\n    val ICEBERG_BLUE = placedFeature(\"iceberg_blue\", ConfiguredFeatures.ICEBERG_BLUE)\n        .rarityFilter(200) // (1)!\n        .inSquareSpread() // (2)!\n        .biomeFilter() // (3)!\n        .register()\n\n}\n</code></pre> <ol> <li>Only place an iceberg every 200 chunks.</li> <li>Randomly offset the iceberg horizontally.</li> <li>Only place the iceberg if the location hasn't moved to a biome without icebergs.</li> </ol> configured_feature/iceberg_blue.json<pre><code>{\n  \"type\": \"minecraft:iceberg\",\n  \"config\": {\n    \"state\": {\n      \"Name\": \"minecraft:blue_ice\"\n    }\n  }\n}\n</code></pre> placed_feature/iceberg_blue.json<pre><code>{\n  \"feature\": \"minecraft:iceberg_blue\",\n  \"placement\": [\n    {\n      \"type\": \"minecraft:rarity_filter\",\n      \"chance\": 200 // (1)!\n    },\n    {\n      \"type\": \"minecraft:in_square\" // (2)!\n    },\n    {\n      \"type\": \"minecraft:biome\" // (3)!\n    }\n  ]\n}\n</code></pre> <ol> <li>Only place an iceberg every 200 chunks.</li> <li>Randomly offset the iceberg horizontally.</li> <li>Only place the iceberg if the location hasn't moved to a biome without icebergs.</li> </ol>"},{"location":"addon/worldgen/features/configurations/iceberg/#result","title":"Result","text":""},{"location":"addon/worldgen/features/configurations/lake/","title":"Lake feature","text":"<p>Deprecated</p> <p>This feature is marked as deprecated in Minecraft's internal code. It might be removed in a future update.</p> <p>The <code>lake</code> feature can be used to add lakes to a biome (for example the underground lava lakes).</p>"},{"location":"addon/worldgen/features/configurations/lake/#configuration","title":"Configuration","text":"<p>The <code>lake</code> feature has the following configuration options:</p> Option Type Description <code>fluid</code> A <code>BlockState</code> The fluid block to use for the lake. <code>barrier</code> A <code>BlockState</code> The block to use for the lake's edge. <p>In code, the <code>LakeFeature.Configuration</code> class is used to configure the feature.</p>"},{"location":"addon/worldgen/features/configurations/lake/#example","title":"Example","text":"<p>As an example, here's the configured- and placed feature for the underground lava lakes that can be found in most biomes.</p> KotlinJson ConfiguredFeatures.kt<pre><code>@OptIn(ExperimentalWorldGen::class)\n@Init(stage = InitStage.POST_PACK_PRE_WORLD)\nobject ConfiguredFeatures : FeatureRegistry by ExampleAddon.registry {\n\n    val LAKE_LAVA = registerConfiguredFeature(\n        \"lake_lava\",\n        Feature.LAKE,\n        LakeFeature.Configuration(\n            BlockStateProvider.simple(Blocks.LAVA.defaultBlockState()), // (1)!\n            BlockStateProvider.simple(Blocks.STONE.defaultBlockState()) // (2)!\n        )\n    )\n\n}\n</code></pre> <ol> <li>Used as the fluid of the lake.</li> <li>Used as the barrier of the lake.</li> </ol> PlacedFeatures.kt<pre><code>@OptIn(ExperimentalWorldGen::class)\n@Init(stage = InitStage.POST_PACK_PRE_WORLD)\nobject PlacedFeatures : FeatureRegistry by ExampleAddon.registry {\n\n    val LAKE_LAVA_UNDERGROUND = placedFeature(\"lake_lava_underground\", ConfiguredFeatures.LAKE_LAVA)\n        .rarityFilter(9) // (1)!\n        .inSquareSpread() // (2)!\n        .heightRangeUniform(VerticalAnchor.absolute(0), VerticalAnchor.top()) // (3)!\n        .environmentScan( // (4)!\n            Direction.DOWN,\n            BlockPredicate.allOf(BlockPredicate.not(BlockPredicate.ONLY_IN_AIR_PREDICATE), BlockPredicate.insideWorld(BlockPos(0, -5, 0))),\n            32\n        )\n        .surfaceRelativeThresholdFilter(Heightmap.Types.OCEAN_FLOOR_WG, Int.MIN_VALUE, -5) // (5)!\n        .biomeFilter() // (6)!\n        .register()\n\n}\n</code></pre> <ol> <li>Only place a lake every 9 chunks.</li> <li>Randomly offset the lake horizontally.</li> <li>Set the y-coordinate of the lake to a random value above 0.</li> <li>Search for a block that isn't air and is 5 blocks above the minimum build height.</li> <li>Only place the lake if it's at least 5 blocks below the ocean floor.</li> <li>Only place the lake if the location hasn't moved to a biome without lava lakes.</li> </ol> configured_feature/lake_lava.json<pre><code>{\n  \"type\": \"minecraft:lake\",\n  \"config\": {\n    \"fluid\": {\n      \"type\": \"minecraft:simple_state_provider\",\n      \"state\": {\n        \"Name\": \"minecraft:lava\",\n        \"Properties\": {\n          \"level\": \"0\"\n        }\n      }\n    },\n    \"barrier\": {\n      \"type\": \"minecraft:simple_state_provider\",\n      \"state\": {\n        \"Name\": \"minecraft:stone\"\n      }\n    }\n  }\n}\n</code></pre> placed_feature/lake_lava_underground.json<pre><code>{\n  \"feature\": \"minecraft:lake_lava\",\n  \"placement\": [\n    {\n      \"type\": \"minecraft:rarity_filter\",\n      \"chance\": 9 // (1)!\n    },\n    {\n      \"type\": \"minecraft:in_square\" // (2)!\n    },\n    {\n      \"type\": \"minecraft:height_range\", // (3)!\n      \"height\": {\n        \"type\": \"minecraft:uniform\",\n        \"max_inclusive\": {\n          \"below_top\": 0\n        },\n        \"min_inclusive\": {\n          \"absolute\": 0\n        }\n      }\n    },\n    {\n      \"type\": \"minecraft:environment_scan\", // (4)!\n      \"direction_of_search\": \"down\",\n      \"max_steps\": 32,\n      \"target_condition\": {\n        \"type\": \"minecraft:all_of\",\n        \"predicates\": [\n          {\n            \"type\": \"minecraft:not\",\n            \"predicate\": {\n              \"type\": \"minecraft:matching_blocks\",\n              \"blocks\": \"minecraft:air\"\n            }\n          },\n          {\n            \"type\": \"minecraft:inside_world_bounds\",\n            \"offset\": [\n              0,\n              -5,\n              0\n            ]\n          }\n        ]\n      }\n    },\n    {\n      \"type\": \"minecraft:surface_relative_threshold_filter\", // (5)!\n      \"heightmap\": \"OCEAN_FLOOR_WG\",\n      \"max_inclusive\": -5\n    },\n    {\n      \"type\": \"minecraft:biome\" // (6)!\n    }\n  ]\n}\n</code></pre> <ol> <li>Only place a lake every 9 chunks.</li> <li>Randomly offset the lake horizontally.</li> <li>Set the y-coordinate of the lake to a random value above 0.</li> <li>Search for a block that isn't air and is 5 blocks above the minimum build height.</li> <li>Only place the lake if it's at least 5 blocks below the ocean floor.</li> <li>Only place the lake if the location hasn't moved to a biome without lava lakes.</li> </ol>"},{"location":"addon/worldgen/features/configurations/lake/#result","title":"Result","text":""},{"location":"addon/worldgen/features/configurations/large-dripstone/","title":"Large dripstone feature","text":"<p>Warning</p> <p>Advanced Knowledge Required - This documentation page is intended for users with in-depth knowledge of the world   generation system. Beginner users may find the content challenging to understand.</p> <p>The <code>large_dripstone</code> feature generates large dripstone formations in the world.</p>"},{"location":"addon/worldgen/features/configurations/large-dripstone/#configuration","title":"Configuration","text":"<p>The <code>large_dripstone</code> feature has the following configuration options. Some of these options are pretty hard to understand. Make sure to check out this graph to play around with the values.</p> Option Type Description <code>floor_to_ceiling_search_range</code> (optional in Json, defaults to <code>30</code>) An <code>int</code>. (Range limit in Json is \\([1;512]\\)) Determines the maximum distance from the base of the dripstone cluster to the ceiling. <code>column_radius</code> An <code>IntProvider</code>. (Range limit in Json is \\([1;60]\\)) Sampled twice to get the min and max radius of the dripstone column. <code>height_scale</code> A <code>FloatProvider</code>. (Range limit in Json is \\([0.0;20.0]\\)) The height scale of the dripstone column. <code>max_column_radius_to_cave_height_ratio</code> A <code>float</code>. (Range limit in Json is \\([0.0;1.0]\\)) The ratio of the max radius to the cave height. <code>stalactite_bluntness</code> A <code>FloatProvider</code>. (Range limit in Json is \\([0.0;10.0]\\)) Determines the height of the stalactite tip. <code>stalagmite_bluntness</code> A <code>FloatProvider</code>. (Range limit in Json is \\([0.0;10.0]\\)) Determines the height of the stalagmite tip. <code>wind_speed</code> A <code>FloatProvider</code>. (Range limit in Json is \\([0.0;2.0]\\)) Higher values lead to a bigger inclination of the dripstone. <code>min_radius_for_wind</code> An <code>int</code>. (Range limit in Json is \\([1;100]\\)) The minimum column radius for the wind to have an effect. <code>min_bluntness_for_wind</code> A <code>float</code>. (Range limit in Json is \\([0.0;5.0]\\)) The minimum bluntness for the wind to have an effect. <p>In code, the <code>LargeDripstoneConfiguration</code> class is used to configure the feature.</p>"},{"location":"addon/worldgen/features/configurations/large-dripstone/#example","title":"Example","text":"<p>As an example, here's the configured and placed feature for the vanilla large dripstone formations.</p> KotlinJson ConfiguredFeatures.kt<pre><code>@OptIn(ExperimentalWorldGen::class)\n@Init(stage = InitStage.POST_PACK_PRE_WORLD)\nobject ConfiguredFeatures : FeatureRegistry by ExampleAddon.registry {\n\n    val LARGE_DRIPSTONE = registerConfiguredFeature(\n        \"large_dripstone\",\n        Feature.LARGE_DRIPSTONE,\n        LargeDripstoneConfiguration(\n            30, // floorToCeilingSearchRange\n            UniformInt.of(3, 19), // columnRadius\n            UniformFloat.of(0.4f, 2.0f), // heightScale\n            0.33f, // maxColumnRadiusToCaveHeightRatio\n            UniformFloat.of(0.3f, 0.9f), // stalactiteBluntness\n            UniformFloat.of(0.4f, 1.0f), // stalagmiteBluntness\n            UniformFloat.of(0.0f, 0.3f), // windSpeed\n            4, // minRadiusForWind\n            0.6f // minBluntnessForWind\n        )\n    )\n\n}\n</code></pre> PlacedFeatures.kt<pre><code>@OptIn(ExperimentalWorldGen::class)\n@Init(stage = InitStage.POST_PACK_PRE_WORLD)\nobject PlacedFeatures : FeatureRegistry by ExampleAddon.registry {\n\n    val LARGE_DRIPSTONE = placedFeature(\"large_dripstone\", ConfiguredFeatures.LARGE_DRIPSTONE)\n        .count(UniformInt.of(10, 48))\n        .inSquareSpread()\n        .inYWorldBounds() // (1)!\n        .biomeFilter()\n        .register()\n\n}\n</code></pre> <ol> <li>Call is equivalent to:     <pre><code>HeightRangePlacement.uniform(VerticalAnchor.bottom(), VerticalAnchor.absolute(256))\n</code></pre></li> </ol> configured_feature/large_dripstone.json<pre><code>{\n  \"type\": \"minecraft:large_dripstone\",\n  \"config\": {\n    \"column_radius\": {\n      \"type\": \"minecraft:uniform\",\n      \"value\": {\n        \"max_inclusive\": 19,\n        \"min_inclusive\": 3\n      }\n    },\n    \"floor_to_ceiling_search_range\": 30,\n    \"height_scale\": {\n      \"type\": \"minecraft:uniform\",\n      \"value\": {\n        \"max_exclusive\": 2.0,\n        \"min_inclusive\": 0.4\n      }\n    },\n    \"max_column_radius_to_cave_height_ratio\": 0.33,\n    \"min_bluntness_for_wind\": 0.6,\n    \"min_radius_for_wind\": 4,\n    \"stalactite_bluntness\": {\n      \"type\": \"minecraft:uniform\",\n      \"value\": {\n        \"max_exclusive\": 0.9,\n        \"min_inclusive\": 0.3\n      }\n    },\n    \"stalagmite_bluntness\": {\n      \"type\": \"minecraft:uniform\",\n      \"value\": {\n        \"max_exclusive\": 1.0,\n        \"min_inclusive\": 0.4\n      }\n    },\n    \"wind_speed\": {\n      \"type\": \"minecraft:uniform\",\n      \"value\": {\n        \"max_exclusive\": 0.3,\n        \"min_inclusive\": 0.0\n      }\n    }\n  }\n}\n</code></pre> placed_feature/large_dripstone.json<pre><code>{\n  \"feature\": \"minecraft:large_dripstone\",\n  \"placement\": [\n    {\n      \"type\": \"minecraft:count\",\n      \"count\": {\n        \"type\": \"minecraft:uniform\",\n        \"value\": {\n          \"max_inclusive\": 48,\n          \"min_inclusive\": 10\n        }\n      }\n    },\n    {\n      \"type\": \"minecraft:in_square\"\n    },\n    {\n      \"type\": \"minecraft:height_range\",\n      \"height\": {\n        \"type\": \"minecraft:uniform\",\n        \"max_inclusive\": {\n          \"absolute\": 256\n        },\n        \"min_inclusive\": {\n          \"above_bottom\": 0\n        }\n      }\n    },\n    {\n      \"type\": \"minecraft:biome\"\n    }\n  ]\n}\n</code></pre>"},{"location":"addon/worldgen/features/configurations/large-dripstone/#result","title":"Result","text":"AloneNaturally generated <p><p> </p></p> <p><p> </p></p>"},{"location":"addon/worldgen/features/configurations/multiface-growth/","title":"Multiface growth feature","text":"<p>The <code>multiface_growth</code> feature is used to generate plants that grow on multiple faces of a block (for example sculk or glow lichen).</p>"},{"location":"addon/worldgen/features/configurations/multiface-growth/#configuration","title":"Configuration","text":"<p>The <code>multiface_growth</code> feature has the following configuration options:</p> Option Type Description <code>block</code> (optional in Json, defaults to <code>glow_lichen</code> A <code>String</code>. Either <code>glow_lichen</code> or <code>sculk_vein</code>. The block to generate. <code>search_range</code> (optional in Json, defaults to <code>10</code>) An <code>int</code>. (Range limit in Json is \\([1;64]\\)) The search range for the next block to grow on. <code>can_place_on_floor</code> (optional in Json, defaults to <code>false</code>) A <code>boolean</code>. Whether the plant can grow on the floor. <code>can_place_on_ceiling</code> (optional in Json, defaults to <code>true</code>) A <code>boolean</code>. Whether the plant can grow on the ceiling. <code>can_place_on_wall</code> (optional in Json, defaults to <code>true</code>) A <code>boolean</code>. Whether the plant can grow on the wall. <code>can_be_placed_on</code> A list of blocks. (Also supports a single block id, block tag or a list of them in Json) The blocks the plant can grow on. <code>chance_of_spreading</code> (optional in Json, defaults to <code>0.5</code>) A <code>float</code>. (Range limit in Json is \\([0.0;1.0]\\)) The chance that the plant will spread to a new block. <p>In code, the <code>MultifaceGrowthConfiguration</code> class is used to configure the feature.</p>"},{"location":"addon/worldgen/features/configurations/multiface-growth/#example","title":"Example","text":"<p>As an example, here's the configured- and placed feature for sculk veins.</p> KotlinJson ConfiguredFeatures.kt<pre><code>@OptIn(ExperimentalWorldGen::class)\n@Init(stage = InitStage.POST_PACK_PRE_WORLD)\nobject ConfiguredFeatures : FeatureRegistry by ExampleAddon.registry {\n\n    val SCULK_VEIN = registerConfiguredFeature(\n        \"sculk_vein\",\n        Feature.MULTIFACE_GROWTH,\n        MultifaceGrowthConfiguration(\n            Blocks.SCULK_VEIN as MultifaceBlock, // block to use\n            20, // search range\n            true, // canPlaceOnFloor\n            true, // canPlaceOnCeiling\n            true, // canPlaceOnWall\n            1.0F, // chanceOfSpreading // (1)!\n            HolderSet.direct( // (2)!\n                Block::builtInRegistryHolder,\n                Blocks.STONE, Blocks.ANDESITE, Blocks.DIORITE, Blocks.GRANITE, Blocks.DRIPSTONE_BLOCK, Blocks.CALCITE, Blocks.TUFF, Blocks.DEEPSLATE\n            )\n        )\n    )\n\n}\n</code></pre> <ol> <li>Combined with the search range of 20, this ensures that every block in a 20 block radius will have a sculk vein.</li> <li>Only grow on typical cave blocks.</li> </ol> PlacedFeatures.kt<pre><code>@OptIn(ExperimentalWorldGen::class)\n@Init(stage = InitStage.POST_PACK_PRE_WORLD)\nobject PlacedFeatures : FeatureRegistry by ExampleAddon.registry {\n\n    val SCULK_VEIN = placedFeature(\"sculk_vein\", ConfiguredFeatures.SCULK_VEIN)\n        .count(UniformInt.of(204, 250)) // (1)!\n        .inSquareSpread() // (2)!\n        .inYWorldBounds() // (3)!\n        .biomeFilter() // (4)!\n        .register()\n\n}\n</code></pre> <ol> <li>Generate 204-250 attempts per chunk.</li> <li>Randomly offset the attempts horizontally.</li> <li>Set the y-level to a random int up to 256. The call is equivalent to    <pre><code>HeightRangePlacement.uniform(VerticalAnchor.bottom(), VerticalAnchor.absolute(256));\n</code></pre></li> <li>Only generate in biomes that have sculk growth.</li> </ol> configured_feature/sculk_vein.json<pre><code>{\n  \"type\": \"minecraft:multiface_growth\",\n  \"config\": {\n    \"block\": \"minecraft:sculk_vein\",\n    \"search_range\": 20,\n    \"chance_of_spreading\": 1.0, // (1)! \n    \"can_place_on_floor\": true,\n    \"can_place_on_ceiling\": true,\n    \"can_place_on_wall\": true,\n    \"can_be_placed_on\": [ // (2)!\n      \"minecraft:stone\",\n      \"minecraft:andesite\",\n      \"minecraft:diorite\",\n      \"minecraft:granite\",\n      \"minecraft:dripstone_block\",\n      \"minecraft:calcite\",\n      \"minecraft:tuff\",\n      \"minecraft:deepslate\"\n    ]\n  }\n}\n</code></pre> <ol> <li>Grow on every block in a 20 block radius.</li> <li>Only grow on typical cave blocks.</li> </ol> placed_feature/sculk_vein.json<pre><code>{\n  \"feature\": \"minecraft:sculk_vein\",\n  \"placement\": [\n    {\n      \"type\": \"minecraft:count\", // (1)!\n      \"count\": {\n        \"type\": \"minecraft:uniform\",\n        \"value\": {\n          \"max_inclusive\": 250,\n          \"min_inclusive\": 204\n        }\n      }\n    },\n    {\n      \"type\": \"minecraft:in_square\" // (2)!\n    },\n    {\n      \"type\": \"minecraft:height_range\", // (3)!\n      \"height\": {\n        \"type\": \"minecraft:uniform\",\n        \"max_inclusive\": {\n          \"absolute\": 256\n        },\n        \"min_inclusive\": {\n          \"above_bottom\": 0\n        }\n      }\n    },\n    {\n      \"type\": \"minecraft:biome\" // (4)!\n    }\n  ]\n}\n</code></pre> <ol> <li>Generate 204-250 attempts per chunk.</li> <li>Randomly offset the attempts horizontally.</li> <li>Set the y-level to a random int up to 256.</li> <li>Only generate in biomes that have sculk growth.</li> </ol>"},{"location":"addon/worldgen/features/configurations/multiface-growth/#result","title":"Result","text":""},{"location":"addon/worldgen/features/configurations/nether-forest-vegetation/","title":"Nether forest vegetation feature","text":"<p>Hardcoded block check</p> <p>This feature has a hardcoded check for the surface block being <code>nylium</code> and will not work on other blocks</p> <p>The <code>nether_forest_vegetation</code> feature is a feature that randomly spreads a specific block on the surface.</p>"},{"location":"addon/worldgen/features/configurations/nether-forest-vegetation/#configuration","title":"Configuration","text":"<p>The nether forest vegetation feature has the following configuration options:</p> Option Type Description <code>state_provider</code> A <code>BlockStateProvider</code>. The block state to use for the vegetation. <code>spread_width</code> A positive <code>int</code>. The width of the area to spread the vegetation in. <code>spread_height</code> A positive <code>int</code>. The height of the area to spread the vegetation in. <p>In code, the <code>NetherForestVegetationConfig</code> class is used to configure the feature.</p>"},{"location":"addon/worldgen/features/configurations/nether-forest-vegetation/#example","title":"Example","text":"<p>As an example, here's the configured- and placed feature to spread nether sprouts in the nether forest biomes.</p> KotlinJson ConfiguredFeatures.kt<pre><code>@OptIn(ExperimentalWorldGen::class)\n@Init(stage = InitStage.POST_PACK_PRE_WORLD)\nobject ConfiguredFeatures : FeatureRegistry by ExampleAddon.registry {\n\n    val NETHER_SPROUTS = registerConfiguredFeature(\n        \"nether_sprouts\",\n        Feature.NETHER_FOREST_VEGETATION,\n        NetherForestVegetationConfig(\n            BlockStateProvider.simple(Blocks.NETHER_SPROUTS), // block used for the vegetation\n            8, // spreadWidth\n            4 // spreadHeight\n        )\n    )\n\n}\n</code></pre> PlacedFeatures.kt<pre><code>@OptIn(ExperimentalWorldGen::class)\n@Init(stage = InitStage.POST_PACK_PRE_WORLD)\nobject PlacedFeatures : FeatureRegistry by ExampleAddon.registry {\n\n    val NETHER_SPROUTS = placedFeature(\"nether_sprouts\", ConfiguredFeatures.NETHER_SPROUTS)\n        .countOnEveryLayer(4) // (1)!\n        .biomeFilter() // (2)!\n        .register()\n\n}\n</code></pre> <ol> <li>Make sure to place the nether sprouts on every layer if multiple exist in the biome.</li> <li>Only place the sprouts in the nether forest biomes.</li> </ol> configured_feature/nether_sprouts.json<pre><code>{\n  \"type\": \"minecraft:nether_forest_vegetation\",\n  \"config\": {\n    \"state_provider\": {\n      \"type\": \"minecraft:simple_state_provider\",\n      \"state\": {\n        \"Name\": \"minecraft:nether_sprouts\"\n      }\n    },\n    \"spread_height\": 4,\n    \"spread_width\": 8\n  }\n}\n</code></pre> placed_feature/nether_sprouts.json<pre><code>{\n  \"feature\": \"minecraft:nether_sprouts\",\n  \"placement\": [\n    {\n      \"type\": \"minecraft:count_on_every_layer\", // (1)!\n      \"count\": 4\n    },\n    {\n      \"type\": \"minecraft:biome\" // (2)!\n    }\n  ]\n}\n</code></pre> <ol> <li>Make sure to place the nether sprouts on every layer if multiple exist in the biome.</li> <li>Only place the sprouts in the nether forest biomes.</li> </ol>"},{"location":"addon/worldgen/features/configurations/ores/","title":"Ore features","text":"<p>Ore features are used to generate ores in the world. They are configured using the <code>ore</code> or <code>scattered_ore</code> feature types (<code>ore</code> is recommended for most cases).</p>"},{"location":"addon/worldgen/features/configurations/ores/#configuration","title":"Configuration","text":"<p>The following options are available for ore configurations:</p> Option Type Description <code>targets</code> A list of <code>TargetBlockState</code>s A list which determines what block to use for specific targets. Needs a <code>target</code> and a <code>state</code> option. See below for more details. <code>size</code> An <code>int</code>. (Range limit in Json is \\([0;64]\\)) Determines the volume size of the ore. <code>discard_chance_on_air_exposure</code> A <code>float</code>. (Range limit in Json is \\([0;1]\\)) Determines the chance that the ore will be discarded if it is exposed to air. <code>1</code> means that the ore will never be exposed to air. <p>In code, the <code>OreConfiguration</code> class is used to configure the feature.</p>"},{"location":"addon/worldgen/features/configurations/ores/#targets","title":"Targets","text":"<p>As mentioned above, the <code>targets</code> option is a list of targets. The <code>target</code> option is a so called<code>RuleTest</code>. A <code>RuleTest</code> is  pretty much the same thing as <code>Predicate&lt;BlockState&gt;</code> in Java. The <code>state</code> option is a <code>BlockStateProvider</code> which determines what block to use for the specific target. The following <code>RuleTests</code> are available:</p> Name Description Example <code>minecraft:always_true</code> Matches every block <pre><code>AlwaysTrueTest.INSTANCE\n</code></pre> <pre><code>\"target\": {\n  \"predicate_type\": \"minecraft:always_true\"\n}\n</code></pre> <code>minecraft:block_match</code> Matches a specific block <pre><code>BlockMatchTest(Blocks.STONE)\n</code></pre> <pre><code>\"target\": {\n  \"predicate_type\": \"minecraft:block_match\",\n  \"block\": \"minecraft:stone\"\n}\n</code></pre> <code>minecraft:blockstate_match</code> Matches a specific blockstate <pre><code>BlockStateMatchTest(\n    Blocks.GLASS_PANE.defaultBlockState()\n        .setValue(IronBarsBlock.EAST, true)\n        .setValue(IronBarsBlock.WEST, true)\n)\n</code></pre> <pre><code>\"target\": {\n  \"predicate_type\": \"minecraft:blockstate_match\",\n  \"block_state\": {\n    \"Name\": \"minecraft:glass_pane\",\n    \"Properties\": {\n      \"east\": \"true\",\n      \"north\": \"false\",\n      \"south\": \"false\",\n      \"waterlogged\": \"false\",\n      \"west\": \"true\"\n    }\n  }\n}\n</code></pre> <code>minecraft:tag_match</code> Matches a specific block tag <pre><code>TagMatchTest(BlockTags.STONE_ORE_REPLACEABLES)\n</code></pre> <pre><code>\"target\": {\n  \"predicate_type\": \"minecraft:tag_match\",\n  \"tag\": \"minecraft:stone_ore_replaceables\"\n}\n</code></pre> <code>minecraft:random_block_match</code> Matches the given block with a probability. The probability should be a value between 0.0 and 1.0. <pre><code>RandomBlockMatchTest(Blocks.COBBLESTONE, 0.5f)\n</code></pre> <pre><code>\"target\": {\n  \"predicate_type\": \"minecraft:random_block_match\",\n  \"block\": \"minecraft:cobblestone\",\n  \"probability\": 0.5\n}\n</code></pre> <code>minecraft:random_blockstate_match</code> Matches the given blockstate with a probability. The probability should be a value between 0.0 and 1.0. <pre><code>RandomBlockStateMatchTest(\n    Blocks.GLASS_PANE.defaultBlockState()\n        .setValue(IronBarsBlock.EAST, true)\n        .setValue(IronBarsBlock.WEST, true),\n    0.5f\n)\n</code></pre> <pre><code>\"target\": {\n  \"predicate_type\": \"minecraft:random_blockstate_match\",\n  \"block_state\": {\n    \"Name\": \"minecraft:glass_pane\",\n    \"Properties\": {\n      \"east\": \"true\",\n      \"north\": \"false\",\n      \"south\": \"false\",\n      \"waterlogged\": \"false\",\n      \"west\": \"true\"\n    }\n  }\n  \"probability\": 0.5\n}\n</code></pre> <code>nova:material_match</code> Matches a specific nova material <pre><code>MaterialMatchTest(Blocks.STAR_SHARDS_ORE)\n</code></pre> <pre><code>\"target\": {\n  \"predicate_type\": \"nova:material_match\",\n  \"material\": \"machines:star_shards_ore\"\n}\n</code></pre> Custom <code>RuleTests</code> <p>You can also implement your own custom <code>RuleTests</code> by implementing the Minecraft <code>RuleTest</code> interface or extending Nova's <code>NovaRuleTest</code>/<code>NovaMaterialTest</code> classes. Nova's classes provide a bit more parameters such as the <code>Level</code> and <code>BlockPos</code> (or even the <code>NovaMaterial</code> via <code>NovaMaterialTest</code>).  You will also need to provide a <code>RuleTestType</code>, which  specifies how your RuleTest implementation is (de)serialized. This can either be done by implementing the <code>RuleTestType</code> interface or creating it inline by just registering the <code>Codec</code> in the <code>FeatureRegistry</code>. Check out the Codecs page for more information on Mojang's serialization system. Here's the code for Nova's <code>MaterialMatchTest</code> implementation as an example:</p> Inline RuleTestTypeRuleTestType object RuleTests.kt<pre><code>object RuleTests : MinecraftUtilTypeRegistry by ExampleAddon.registry {\n\n    @OptIn(ExperimentalWorldGen::class)\n    val MATERIAL_MATCH_TEST_TYPE = registerRuleTestType(\"material_match\", MaterialMatchTest.CODEC)\n\n}\n</code></pre> MaterialMatchTest.kt<pre><code>class MaterialMatchTest(val material: BlockNovaMaterial) : NovaMaterialTest() {\n\n    override fun test(material: BlockNovaMaterial, level: Level, pos: BlockPos, state: BlockState, random: RandomSource): Boolean {\n        return material == this.material\n    }\n\n    override fun getType(): RuleTestType&lt;*&gt; = RuleTests.MATERIAL_MATCH_TEST_TYPE\n\n    companion object {\n\n        @JvmField // (1)!\n        val CODEC: Codec&lt;MaterialMatchTest&gt; =\n            BlockNovaMaterial.CODEC\n                .fieldOf(\"material\")\n                .xmap(::MaterialMatchTest, MaterialMatchTest::material)\n                .codec()\n                .stable()\n    }\n\n}\n</code></pre> <ol> <li>This allows <code>CODEC</code> to be accessed as a field from Java code instead of having to call <code>getCODEC()</code></li> </ol> MaterialMatchTest.kt<pre><code>object MaterialMatchTestType : RuleTestType&lt;MaterialMatchTest&gt; {\n\n    private val CODEC: Codec&lt;MaterialMatchTest&gt; =\n        BlockNovaMaterial.CODEC\n            .fieldOf(\"material\")\n            .xmap(::MaterialMatchTest, MaterialMatchTest::material)\n            .codec()\n            .stable()\n\n    override fun codec() = CODEC\n\n}\n</code></pre> RuleTests.kt<pre><code>object RuleTests : MinecraftUtilTypeRegistry by ExampleAddon.registry {\n\n    @OptIn(ExperimentalWorldGen::class)\n    val MATERIAL_MATCH_TEST_TYPE = registerRuleTestType(\"material_match\", MaterialMatchTestType)\n\n}\n</code></pre> MaterialMatchTest.kt<pre><code>class MaterialMatchTest(val material: BlockNovaMaterial) : NovaMaterialTest() {\n\n    override fun test(material: BlockNovaMaterial, level: Level, pos: BlockPos, state: BlockState, random: RandomSource): Boolean {\n        return material == this.material\n    }\n\n    override fun getType(): RuleTestType&lt;*&gt; = MaterialMatchTestType\n\n}\n</code></pre>"},{"location":"addon/worldgen/features/configurations/ores/#example","title":"Example","text":"<p>As an example, here's the configured- and placed feature of star shards ore from the machines addon.</p> KotlinJson ConfiguredFeatures.kt<pre><code>@OptIn(ExperimentalWorldGen::class)\n@Init(stage = InitStage.POST_PACK_PRE_WORLD)\nobject ConfiguredFeatures : FeatureRegistry by ExampleAddon.registry {\n\n    val ORE_STAR_SHARDS = registerConfiguredFeature(\n        \"ore_star_shards\",\n        Feature.ORE,\n        OreConfiguration(\n            listOf( // (1)!\n                OreConfiguration.target(\n                    TagMatchTest(BlockTags.STONE_ORE_REPLACEABLES),\n                    WrapperBlockState(Blocks.STAR_SHARDS_ORE) // (2)!\n                ),\n                OreConfiguration.target(\n                    TagMatchTest(BlockTags.DEEPSLATE_ORE_REPLACEABLES),\n                    WrapperBlockState(Blocks.DEEPSLATE_STAR_SHARDS_ORE)\n                )\n            ),\n            4, // (3)!\n            0.0f // (4)!\n        )\n    )\n\n}\n</code></pre> <ol> <li>Specify that <code>star_shards_ore</code> should be used to replace normal stone and <code>deepslate_star_shards_ore</code> should be used to replace deepslate.</li> <li>Since blocks registered via Nova aren't registered in the vanilla blocks registry and thus don't have a blockstate, we need to wrap an block material in a <code>WrapperBlockState</code>.    These objects are later detected before the block is placed and are passed to Nova for correct placement.</li> <li>The size of the ore vein.</li> <li>The chance that the ore will be discarded if it's exposed to air.</li> </ol> <p>For placements, it's pretty useful to define a few util functions to create the <code>PlacementModifier</code> list.</p> PlacedFeatures.kt<pre><code>private fun orePlacement(firstModifier: PlacementModifier, lastModifier: PlacementModifier) =\n    listOf(firstModifier, InSquarePlacement.spread(), lastModifier, BiomeFilter.biome())\n\n/**\n * @param count The amount of ores per chunk\n */\nprivate fun commonOrePlacement(count: Int, lastModifier: PlacementModifier) =\n    orePlacement(CountPlacement.of(count), lastModifier)\n\n/**\n * @param chance The chance of an ore to spawn per chunk. 7 = 1 in 7 chunks\n */\nprivate fun rareOrePlacement(chance: Int, lastModifier: PlacementModifier) =\n    orePlacement(RarityFilter.onAverageOnceEvery(chance), lastModifier)\n</code></pre> Vanilla ore placement examples <pre><code>// ore_iron_upper\ncommonOrePlacement(90, HeightRangePlacement.triangle(VerticalAnchor.absolute(80), VerticalAnchor.absolute(384)))\n// ore_iron_middle\ncommonOrePlacement(10, HeightRangePlacement.triangle(VerticalAnchor.absolute(-24), VerticalAnchor.absolute(56)))\n// ore_iron_small\ncommonOrePlacement(10, HeightRangePlacement.uniform(VerticalAnchor.bottom(), VerticalAnchor.absolute(72)))\n\n// ore_diamond\ncommonOrePlacement(7, HeightRangePlacement.triangle(VerticalAnchor.aboveBottom(-80), VerticalAnchor.aboveBottom(80)))\n// ore_diamond_large\nrareOrePlacement(9, HeightRangePlacement.triangle(VerticalAnchor.aboveBottom(-80), VerticalAnchor.aboveBottom(80)))\n// ore_diamond_buried\ncommonOrePlacement(4, HeightRangePlacement.triangle(VerticalAnchor.aboveBottom(-80), VerticalAnchor.aboveBottom(80)))\n</code></pre> PlacedFeatures.kt<pre><code>@OptIn(ExperimentalWorldGen::class)\n@Init(stage = InitStage.POST_PACK_PRE_WORLD)\nobject PlacedFeatures : FeatureRegistry by ExampleAddon.registry {\n\n    val ORE_STAR_SHARDS = placedFeature(\"ore_star_shards\", ConfiguredFeatures.ORE_STAR_SHARDS)\n        .modifiers(commonOrePlacement(30, HeightRangePlacement.uniform(VerticalAnchor.absolute(120), VerticalAnchor.top()))) // (1)!\n        .register()\n\n    /* ... util placement functions ... */\n\n}\n</code></pre> <ol> <li>30 tries per chunk and only place the ore at a high altitude (y&gt;120).</li> </ol> configured_feature/ore_star_shards.json<pre><code>{\n  \"type\": \"minecraft:ore\",\n  \"config\": {\n    \"discard_chance_on_air_exposure\": 0.0,\n    \"size\": 4,\n    \"targets\": [ // (1)!\n      {\n        \"state\": {\n          \"Name\": \"machines:star_shards_ore\"\n        },\n        \"target\": {\n          \"predicate_type\": \"minecraft:tag_match\",\n          \"tag\": \"minecraft:stone_ore_replaceables\"\n        }\n      },\n      {\n        \"state\": {\n          \"Name\": \"machines:deepslate_star_shards_ore\"\n        },\n        \"target\": {\n          \"predicate_type\": \"minecraft:tag_match\",\n          \"tag\": \"minecraft:deepslate_ore_replaceables\"\n        }\n      }\n    ]\n  }\n</code></pre> <ol> <li>Specify that <code>star_shards_ore</code> should be used to replace normal stone and <code>deepslate_star_shards_ore</code> should be used to replace deepslate.</li> </ol> placed_feature/ore_star_shards.json<pre><code>{\n  \"feature\": \"machines:ore_star_shards\",\n  \"placement\": [\n    {\n      \"type\": \"minecraft:count\",\n      \"count\": 30 // (1)!\n    },\n    {\n      \"type\": \"minecraft:in_square\" // (2)!\n    },\n    {\n      \"type\": \"minecraft:height_range\", // (3)!\n      \"height\": {\n        \"type\": \"minecraft:uniform\",\n        \"max_inclusive\": {\n          \"below_top\": 0\n        },\n        \"min_inclusive\": {\n          \"absolute\": 120\n        }\n      }\n    },\n    {\n      \"type\": \"minecraft:biome\" // (4)!\n    }\n  ]\n}\n</code></pre> <ol> <li>30 tries per chunk.</li> <li>Spread the tries in a square.</li> <li>Place the ore above y-level 119.</li> <li>Discard the try if we moved into a biome that doesn't generate star shards.</li> </ol>"},{"location":"addon/worldgen/features/configurations/pointed-dripstone/","title":"Pointed dripstone feature","text":"<p>The <code>pointed_dripstone</code> feature can be used to add pointed dripstone to the world.</p>"},{"location":"addon/worldgen/features/configurations/pointed-dripstone/#configuration","title":"Configuration","text":"<p>The <code>pointed_dripstone</code> feature has the following configuration options:</p> Option Type Description <code>chance_of_taller_dripstone</code> (optional in Json, defaults to <code>0.2</code>) A <code>float</code> in the range \\([0.0;1.0]\\). Determines the chance of a dripstone being taller than 1 block. <code>chance_of_directional_spread</code> (optional in Json, defaults to <code>0.7</code>) A <code>float</code> in the range \\([0.0;1.0]\\). Determines the chance of a dripstone spreading horizontally. <code>chance_of_spread_radius2</code> (optional in Json, defaults to <code>0.5</code>) A <code>float</code> in the range \\([0.0;1.0]\\). Determines the chance of a dripstone spreading 2 blocks away. <code>chance_of_spread_radius3</code> (optional in Json, defaults to <code>0.5</code>) A <code>float</code> in the range \\([0.0;1.0]\\). Determines the chance of a dripstone spreading 3 blocks away. <p>In code, the <code>PointedDripstoneConfiguration</code> class is used to configure the feature.</p>"},{"location":"addon/worldgen/features/configurations/pointed-dripstone/#example","title":"Example","text":"<p>Minecraft uses a <code>simple_random_selector</code> feature to actually place pointed dripstone. Here's  one of the features used to place upwards pointing dripstone.</p> KotlinJson ConfiguredFeatures.kt<pre><code>@OptIn(ExperimentalWorldGen::class)\n@Init(stage = InitStage.POST_PACK_PRE_WORLD)\nobject ConfiguredFeatures : FeatureRegistry by ExampleAddon.registry {\n\n    val POINTED_DRIPSTONE = registerConfiguredFeature(\n        \"pointed_dripstone\",\n        Feature.POINTED_DRIPSTONE,\n        PointedDripstoneConfiguration(\n            0.2F, // chance_of_taller_dripstone\n            0.7F, // chance_of_directional_spread\n            0.5F, // chance_of_spread_radius2\n            0.5F  // chance_of_spread_radius3\n        )\n    )\n\n}\n</code></pre> PlacedFeatures.kt<pre><code>@OptIn(ExperimentalWorldGen::class)\n@Init(stage = InitStage.POST_PACK_PRE_WORLD)\nobject PlacedFeatures : FeatureRegistry by ExampleAddon.registry {\n\n    val POINTED_DRIPSTONE = placedFeature(\"pointed_dripstone\", ConfiguredFeatures.POINTED_DRIPSTONE)\n        .environmentScan( // (1)!\n            Direction.DOWN,\n            BlockPredicate.solid(),\n            BlockPredicate.ONLY_IN_AIR_OR_WATER_PREDICATE, // (2)!\n            12 // max_steps\n        )\n        .randomVerticalOffset(1) // (3)!\n        .register()\n\n}\n</code></pre> <ol> <li>Searches downwards for a solid block.</li> <li>Only place the dripstone if the block below is air or water. The static constant is equivalent to    <pre><code>BlockPredicate.matchesBlocks(Blocks.AIR, Blocks.WATER) \n</code></pre></li> <li>Makes sure to place the dripstone on top of the solid block.</li> </ol> configured_feature/pointed_dripstone.json<pre><code>{\n  \"type\": \"minecraft:pointed_dripstone\",\n  \"config\": {\n    \"chance_of_taller_dripstone\": 0.2,\n    \"chance_of_directional_spread\": 0.7,\n    \"chance_of_spread_radius2\": 0.5,\n    \"chance_of_spread_radius3\": 0.5\n  }\n}\n</code></pre> <p>The placed feature is also located in the random selector:</p> placed_feature/pointed_dripstone.json<pre><code>{\n  \"feature\": \"minecraft:pointed_dripstone\",\n  \"placement\": [\n    {\n      \"type\": \"minecraft:environment_scan\", // (1)!\n      \"allowed_search_condition\": {\n        \"type\": \"minecraft:matching_blocks\",\n        \"blocks\": [\n          \"minecraft:air\",\n          \"minecraft:water\"\n        ]\n      },\n      \"direction_of_search\": \"down\",\n      \"max_steps\": 12,\n      \"target_condition\": {\n        \"type\": \"minecraft:solid\" \n      }\n    },\n    {\n      \"type\": \"minecraft:random_offset\", // (2)!\n      \"xz_spread\": 0,\n      \"y_spread\": 1\n    }\n  ]\n}\n</code></pre> <ol> <li>Searches downwards for a solid block.</li> <li>Makes sure to place the dripstone on top of the solid block.</li> </ol>"},{"location":"addon/worldgen/features/configurations/pointed-dripstone/#result","title":"Result","text":""},{"location":"addon/worldgen/features/configurations/random-patch/","title":"Random patch feature","text":"<p>The <code>random_patch</code> feature can be used to place a feature in a random pattern multiple times. It's mostly used for vegetation and even has 2 more features for flowers: <code>flower</code> and <code>no_bonemeal_flower</code>. Their configuration is the same as the<code>random_patch</code> feature, but <code>flower</code> features will also be used when applying bonemeal to grass blocks. <code>no_bonemeal_flower</code> only exists to make distinguishing it from other <code>random_patch</code> features easier.</p>"},{"location":"addon/worldgen/features/configurations/random-patch/#configuration","title":"Configuration","text":"<p>The following configuration options are available:</p> Option Type Description <code>tries</code> (optional in Json, defaults to <code>128</code>) A positive <code>int</code>. The amount of times the feature will try to generate. <code>xz_spread</code> (optional in Json, defaults to <code>7</code>) A positive <code>int</code>. The maximum horizontal distance from the center of the feature. <code>y_spread</code> (optional in Json, defaults to <code>3</code>) A positive <code>int</code>. The maximum vertical distance from the center of the feature. <code>feature</code> The placed feature (in Json, this can also be the id of the placed feature if registered elsewhere) The placed feature to generate. <p>In code, the <code>RandomPatchConfiguration</code> class is used to configure the feature.</p>"},{"location":"addon/worldgen/features/configurations/random-patch/#example","title":"Example","text":"<p>As an example, here's the random patch used to generate dead bushes in the badlands biome:</p> KotlinJson <p>Minecraft offers a few util functions in the <code>FeatureUtils</code> class to make the creation of the <code>RandomPatchConfiguration</code> easier.</p> ConfiguredFeatures.kt<pre><code>@OptIn(ExperimentalWorldGen::class)\n@Init(stage = InitStage.POST_PACK_PRE_WORLD)\nobject ConfiguredFeatures : FeatureRegistry by ExampleAddon.registry {\n\n    val PATCH_DEAD_BUSH = registerConfiguredFeature(\n        \"patch_dead_bush\",\n        Feature.RANDOM_PATCH,\n        FeatureUtils.simpleRandomPatchConfiguration( // (1)!\n            4, // tries\n            PlacementUtils.onlyWhenEmpty( // (2)!\n                Feature.SIMPLE_BLOCK,\n                SimpleBlockConfiguration(BlockStateProvider.simple(Blocks.DEAD_BUSH)) // (3)!\n            )\n        )\n    )\n\n}\n</code></pre> <ol> <li>The <code>simpleRandomPatchConfiguration</code> function creates a <code>RandomPatchConfiguration</code> with the given tries and placed feature.    <code>xz_spread</code> and <code>y_spread</code> are set to <code>7</code> and <code>3</code> respectively.</li> <li>The <code>onlyWhenEmpty</code> function creates an inlined <code>PlacedFeature</code> that only places the feature when the block at the position is air.</li> <li>Place single dead bushes.</li> </ol> PlacedFeatures.kt<pre><code>@OptIn(ExperimentalWorldGen::class)\n@Init(stage = InitStage.POST_PACK_PRE_WORLD)\nobject PlacedFeatures : FeatureRegistry by ExampleAddon.registry {\n\n    val PATCH_DEAD_BUSH = placedFeature(\"patch_dead_bush\", ConfiguredFeatures.PATCH_DEAD_BUSH)\n        .count(20) // (1)!\n        .inSquareSpread() // (2)!\n        .moveToWorldSurface() // (3)!\n        .biomeFilter() // (4)!\n        .register()\n\n}\n</code></pre> <ol> <li>20 tries to generate the feature.</li> <li>Spread the feature horizontally.</li> <li>Set the y-coordinate to the world surface. This call is equivalent to    <pre><code>HeightmapPlacement.onHeightmap(Heightmap.Types.WORLD_SURFACE_WG)\n</code></pre></li> <li>Make sure that the feature only generates if the position hasn't moved outside the biome that contains dead bushes.</li> </ol> configured_feature/patch_dead_bush.json<pre><code>{\n  \"type\": \"minecraft:random_patch\",\n  \"config\": {\n    \"feature\": { // (1)!\n      \"feature\": { // (2)!\n        \"type\": \"minecraft:simple_block\",\n        \"config\": {\n          \"to_place\": {\n            \"type\": \"minecraft:simple_state_provider\",\n            \"state\": {\n              \"Name\": \"minecraft:dead_bush\"\n            }\n          }\n        }\n      },\n      \"placement\": [\n        {\n          \"type\": \"minecraft:block_predicate_filter\",\n          \"predicate\": {\n            \"type\": \"minecraft:matching_blocks\",\n            \"blocks\": \"minecraft:air\"\n          }\n        }\n      ]\n    },\n    \"tries\": 4,\n    \"xz_spread\": 7,\n    \"y_spread\": 3\n  }\n}\n</code></pre> <ol> <li>The placed feature to generate. Can also be the id of a placed feature that was configured elsewhere.</li> <li>The feature's configuration. Can also be the id of a configured feature.</li> </ol> placed_feature/patch_dead_bush_badlands.json<pre><code>{\n  \"feature\": \"minecraft:patch_dead_bush\",\n  \"placement\": [\n    {\n      \"type\": \"minecraft:count\",\n      \"count\": 20 // (1)!\n    },\n    {\n      \"type\": \"minecraft:in_square\" // (2)!\n    },\n    {\n      \"type\": \"minecraft:heightmap\",\n      \"heightmap\": \"WORLD_SURFACE_WG\" // (3)!\n    },\n    {\n      \"type\": \"minecraft:biome\" // (4)!\n    }\n  ]\n}\n</code></pre> <ol> <li>20 tries to generate the feature.</li> <li>Spread the feature horizontally.</li> <li>Set the y-coordinate to the world surface.</li> <li>Make sure that the feature only generates if the position hasn't moved outside the biome that contains dead bushes.</li> </ol>"},{"location":"addon/worldgen/features/configurations/random-patch/#result","title":"Result","text":""},{"location":"addon/worldgen/features/configurations/random-selector/","title":"Random selector feature","text":"<p>The <code>random_selector</code> feature can be used to randomly choose from a provided list of features to place.</p>"},{"location":"addon/worldgen/features/configurations/random-selector/#configuration","title":"Configuration","text":"<p>The <code>random_selector</code> feature has the following configuration options:</p> Option Type Description <code>features</code> A list of placed features objects (or id's inside the <code>feature</code> option in Json) and their corresponding chance. The list of features to choose from. <code>default</code> A placed feature The default feature to place if none of the provided features got picked <p>In code, the <code>RandomFeatureConfiguration</code> class is used to configure the feature.</p>"},{"location":"addon/worldgen/features/configurations/random-selector/#example","title":"Example","text":"<p>As an example, here's the random selector used to generate tree in the old growth taiga biome</p> KotlinJson ConfiguredFeatures.kt<pre><code>@OptIn(ExperimentalWorldGen::class)\n@Init(stage = InitStage.POST_PACK_PRE_WORLD)(stage = InitStage.POST_PACK_PRE_WORLD)\nobject ConfiguredFeatures : FeatureRegistry by ExampleAddon.registry {\n\n    val TREES_OLD_GROWTH_SPRUCE_TAIGA = registerConfiguredFeature(\n        \"trees_old_growth_spruce_taiga\",\n        Feature.RANDOM_SELECTOR,\n        RandomFeatureConfiguration(\n            listOf(\n                WeightedPlacedFeature(\n                    VanillaRegistryAccess.getHolder(TreePlacements.MEGA_SPRUCE_CHECKED), // (1)!\n                    1f / 3f // (2)!\n                ),\n                WeightedPlacedFeature(\n                    VanillaRegistryAccess.getHolder(TreePlacements.PINE_CHECKED),\n                    1f / 3f // (3)!\n                )\n            ),\n            VanillaRegistryAccess.getHolder(TreePlacements.SPRUCE_CHECKED) // (4)!\n        )\n    )\n\n}\n</code></pre> <ol> <li>Get the registry holder for the mega spruce tree placed feature. (Also support inlined placed features</li> <li>The chance of the mega spruce tree is \\(^1/_{3}\\).</li> <li>The chance of the pine tree is \\(^1/_{3}\\).</li> <li>The default tree is a spruce tree (with a \\(^1/_{3}\\) chance).</li> </ol> configured_feature/trees_old_growth_spruce_taiga.json<pre><code>{\n  \"type\": \"minecraft:random_selector\",\n  \"config\": {\n    \"features\": [\n      { // (1)!\n        \"chance\": 0.33333334,\n        \"feature\": \"minecraft:mega_spruce_checked\" // (2)!\n      },\n      { // (3)!\n        \"chance\": 0.33333334,\n        \"feature\": \"minecraft:pine_checked\"\n      }\n    ],\n    \"default\": \"minecraft:spruce_checked\" // (4)!\n  }\n}\n</code></pre> <ol> <li>A mega spruce tree with a \\(^1/_{3}\\) chance.</li> <li>As previously mentioned, this could also be an entire placed feature object. </li> <li>A pine tree with a \\(^1/_{3}\\) chance.</li> <li>A spruce tree with a \\(^1/_{3}\\) chance.</li> </ol> <p></p>"},{"location":"addon/worldgen/features/configurations/replace-blobs/","title":"Replace blobs feature","text":"<p>The <code>replace_blobs</code> feature can be used to replace specific blobs with a blob of a different block. Although the name suggests that it only works with netherrack, it can be used with any block.</p>"},{"location":"addon/worldgen/features/configurations/replace-blobs/#configuration","title":"Configuration","text":"<p>The <code>replace_blobs</code> feature has the following configuration options:</p> Option Type Description <code>target</code> A <code>BlockState</code>. The block state to replace. <code>state</code> A <code>BlockState</code>. The block state to replace the target with. <code>radius</code> An <code>IntProvider</code>. (Range limit in Json is \\([0;12]\\)) The radius of the blob. <p>In code, the <code>ReplaceSphereConfiguration</code> class is used to configure the feature.</p>"},{"location":"addon/worldgen/features/configurations/replace-blobs/#example","title":"Example","text":"<p>As an example, here's the configured- and placed feature for blackstone blobs in the nether.</p> KotlinJson ConfiguredFeatures.kt<pre><code>@OptIn(ExperimentalWorldGen::class)\n@Init(stage = InitStage.POST_PACK_PRE_WORLD)\nobject ConfiguredFeatures : FeatureRegistry by ExampleAddon.registry {\n\n    val BLACKSTONE_BLOBS = registerConfiguredFeature(\n        \"blackstone_blobs\",\n        Feature.REPLACE_BLOBS,\n        ReplaceSphereConfiguration(\n            Blocks.NETHERRACK.defaultBlockState(), // targetState\n            Blocks.BLACKSTONE.defaultBlockState(), // replaceState\n            UniformInt.of(3, 7) // radius // (1)!\n        )\n    )\n\n}\n</code></pre> <ol> <li>Random radius between 3 and 7.</li> </ol> PlacedFeatures.kt<pre><code>@OptIn(ExperimentalWorldGen::class)\n@Init(stage = InitStage.POST_PACK_PRE_WORLD)\nobject PlacedFeatures : FeatureRegistry by ExampleAddon.registry {\n\n    val BLACKSTONE_BLOBS = placedFeature(\"blackstone_blobs\", ConfiguredFeatures.BLACKSTONE_BLOBS)\n        .count(25) // (1)!\n        .inSquareSpread() // (2)!\n        .modifier(PlacementUtils.FULL_RANGE) // (3)!\n        .biomeFilter() // (4)!\n        .register()\n\n}\n</code></pre> <ol> <li>25 tries to place the blobs per chunk.</li> <li>Randomly spread the blobs horizontally.</li> <li>Set the y-coordinate to a random value. The static constant is equivalent to    <pre><code>HeightRangePlacement.uniform(VerticalAnchor.bottom(), VerticalAnchor.top());\n</code></pre></li> <li>Only place the blobs in biomes that have blackstone blobs.</li> </ol> configured_feature/blackstone_blobs.json<pre><code>{\n  \"type\": \"minecraft:replace_blobs\",\n  \"config\": {\n    \"target\": {\n      \"Name\": \"minecraft:netherrack\"\n    },\n    \"state\": {\n      \"Name\": \"minecraft:blackstone\"\n    },\n    \"radius\": {\n      \"type\": \"minecraft:uniform\", // (1)!\n      \"value\": {\n        \"max_inclusive\": 7,\n        \"min_inclusive\": 3\n      }\n    }\n  }\n}\n</code></pre> <ol> <li>Random radius between 3 and 7.</li> </ol> placed_feature/blackstone_blobs.json<pre><code>{\n  \"feature\": \"minecraft:blackstone_blobs\",\n  \"placement\": [\n    {\n      \"type\": \"minecraft:count\",\n      \"count\": 25 // (1)!\n    },\n    {\n      \"type\": \"minecraft:in_square\" // (2)!\n    },\n    {\n      \"type\": \"minecraft:height_range\", // (3)!\n      \"height\": {\n        \"type\": \"minecraft:uniform\",\n        \"max_inclusive\": {\n          \"below_top\": 0\n        },\n        \"min_inclusive\": {\n          \"above_bottom\": 0\n        }\n      }\n    },\n    {\n      \"type\": \"minecraft:biome\" // (4)!\n    }\n  ]\n}\n</code></pre> <ol> <li>25 tries to place the blobs per chunk.</li> <li>Randomly spread the blobs horizontally.</li> <li>Set the y-coordinate to a random value.</li> <li>Only place the blobs in biomes that have blackstone blobs.</li> </ol>"},{"location":"addon/worldgen/features/configurations/replace-blobs/#result","title":"Result","text":""},{"location":"addon/worldgen/features/configurations/replace-single-block/","title":"Replace single block feature","text":"<p>The <code>replace_single_block</code> feature allows you to randomly replace blocks with another block.</p>"},{"location":"addon/worldgen/features/configurations/replace-single-block/#configuration","title":"Configuration","text":"<p>The <code>replace_single_block</code> feature has a single option, <code>targets</code> which similar to the <code>targets</code> option in the ore feature, allows you to specify which block states should be replaced with which other block states. Each <code>Target</code> has the following options:</p> Option Type Description <code>target</code> A <code>RuleTest</code>. Check out the <code>ores</code> page for more information. The test to check if the block should be replaced. <code>state</code> A <code>BlockState</code> The block state to replace the target with. <p>In code, the <code>ReplaceBlockConfiguration</code> class is used to configure the feature.</p>"},{"location":"addon/worldgen/features/configurations/replace-single-block/#example","title":"Example","text":"<p>As an example, here's a feature to randomly replace acacia logs with stone.</p> KotlinJson ConfiguredFeatures.kt<pre><code>@OptIn(ExperimentalWorldGen::class)\n@Init(stage = InitStage.POST_PACK_PRE_WORLD)\nobject ConfiguredFeatures : FeatureRegistry by ExampleAddon.registry {\n\n    val ACACIA_LOGS_TO_STONE = registerConfiguredFeature(\n        \"acacia_logs_to_stone\",\n        Feature.REPLACE_SINGLE_BLOCK,\n        ReplaceBlockConfiguration(\n            listOf(\n                OreConfiguration.target(TagMatchTest(BlockTags.ACACIA_LOGS), Blocks.STONE.defaultBlockState())\n            )\n        )\n    )\n\n}\n</code></pre> <p>Or, if you only want to replace one specific block state</p> ConfiguredFeatures.kt<pre><code>@OptIn(ExperimentalWorldGen::class)\n@Init(stage = InitStage.POST_PACK_PRE_WORLD)\nobject ConfiguredFeatures : FeatureRegistry by ExampleAddon.registry {\n\n    val ACACIA_LOGS_TO_STONE = registerConfiguredFeature(\n        \"acacia_logs_to_stone\",\n        Feature.REPLACE_SINGLE_BLOCK,\n        ReplaceBlockConfiguration(\n            Blocks.ACACIA_LOG.defaultBlockState(),\n            Blocks.STONE.defaultBlockState(),\n        )\n    )\n\n}\n</code></pre> configured_feature/acacia_logs_to_stone.json<pre><code>{\n  \"type\": \"minecraft:replace_single_block\",\n  \"config\": {\n    \"targets\": [\n      {\n        \"target\": {\n          \"predicate_type\": \"minecraft:tag_match\",\n          \"tag\": \"minecraft:acacia_logs\"\n        },\n        \"state\": {\n          \"Name\": \"minecraft:stone\"\n        }\n      }\n    ]\n  }\n}\n</code></pre>"},{"location":"addon/worldgen/features/configurations/root-system/","title":"Root system feature","text":"<p>Warning</p> <p>Advanced Knowledge Required - This documentation page is intended for users with in-depth knowledge of the world   generation system. Beginner users may find the content challenging to understand.</p> <p>The <code>root_system</code> feature can be used to generate trees with roots.</p>"},{"location":"addon/worldgen/features/configurations/root-system/#configuration","title":"Configuration","text":"<p>A root system feature has the following configuration options:</p> Option Type Description <code>feature</code> A <code>PlacedFeature</code> (or id in Json) The feature to place at the tree position. <code>required_vertical_space_for_tree</code> An <code>int</code>. (Range limit in Json is \\([1;64]\\)) The amount of vertical space required for the tree to grow. <code>root_radius</code> An <code>int</code>. (Range limit in Json is \\([1;64]\\)) The radius of the root system. <code>root_replaceable</code> A block tag (prefixed with <code>#</code> in Json) The blocks that can be replaced by roots. <code>root_state_provider</code> A <code>BlockStateProvider</code> The block state to use for the root. <code>root_placement_attempts</code> An <code>int</code>. (Range limit in Json is \\([1;256]\\)) The amount of attempts to place a root. <code>root_column_max_height</code> An <code>int</code>. (Range limit in Json is \\([1;4096]\\)) The maximum height of a root column. <code>hanging_root_radius</code> An <code>int</code>. (Range limit in Json is \\([1;64]\\)) The radius of hanging roots. <code>hanging_roots_vertical_span</code> An <code>int</code>. (Range limit in Json is \\([0;16]\\)) The vertical span of hanging roots. <code>hanging_root_state_provider</code> A <code>BlockStateProvider</code> The block state to use for the hanging root. <code>hanging_root_placement_attempts</code> An <code>int</code>. (Range limit in Json is \\([1;256]\\)) The amount of attempts to place a hanging root. <code>allowed_vertical_water_for_tree</code> An <code>int</code>. (Range limit in Json is \\([0;64]\\)) The amount of vertical water allowed for the tree to grow. <code>allowed_tree_position</code> A <code>BlockPredicate</code> A predicate to check if the tree position is valid. <p>In code, the <code>RootSystemConfiguration</code> class is used to configure the feature.</p>"},{"location":"addon/worldgen/features/configurations/root-system/#example","title":"Example","text":"<p>As an example, here's the configured- and placed feature for the azalea tree</p> KotlinJson ConfiguredFeatures.kt<pre><code>@OptIn(ExperimentalWorldGen::class)\n@Init(stage = InitStage.POST_PACK_PRE_WORLD)\nobject ConfiguredFeatures : FeatureRegistry by ExampleAddon.registry {\n\n    val ROOTED_AZALEA_TREE = registerConfiguredFeature(\n        \"rooted_azalea_tree\",\n        Feature.ROOT_SYSTEM,\n        RootSystemConfiguration(\n            PlacementUtils.inlinePlaced(VanillaRegistryAccess.getHolder(TreeFeatures.AZALEA_TREE)), // feature\n            3, // required_vertical_space_for_tree\n            3, // root_radius\n            BlockTags.AZALEA_ROOT_REPLACEABLE, // root_replaceable\n            BlockStateProvider.simple(Blocks.ROOTED_DIRT), // root_state_provider\n            20, // root_placement_attempts\n            100, // root_column_max_height\n            3, // hanging_root_radius\n            2, // hanging_roots_vertical_span\n            BlockStateProvider.simple(Blocks.HANGING_ROOTS), // hanging_root_state_provider\n            20, // hanging_root_placement_attempts\n            2, // allowed_vertical_water_for_tree\n            BlockPredicate.allOf( // allowed_tree_position\n                BlockPredicate.anyOf(\n                    BlockPredicate.matchesBlocks(Blocks.AIR, Blocks.CAVE_AIR, Blocks.VOID_AIR, Blocks.WATER),\n                    BlockPredicate.matchesTag(BlockTags.LEAVES),\n                    BlockPredicate.matchesTag(BlockTags.REPLACEABLE_PLANTS)\n                ),\n                BlockPredicate.matchesTag(Direction.DOWN.normal, BlockTags.AZALEA_GROWS_ON)\n            )\n        )\n    )\n\n}\n</code></pre> PlacedFeatures.kt<pre><code>@OptIn(ExperimentalWorldGen::class)\n@Init(stage = InitStage.POST_PACK_PRE_WORLD)\nobject PlacedFeatures : FeatureRegistry by ExampleAddon.registry {\n\n    val ROOTED_AZALEA_TREE = placedFeature(\"rooted_azalea_tree\", ConfiguredFeatures.ROOTED_AZALEA_TREE)\n        .count(UniformInt.of(1, 2))\n        .inSquareSpread()\n        .inYWorldBounds() // (1)!\n        .environmentScan(Direction.UP, BlockPredicate.solid(), BlockPredicate.ONLY_IN_AIR_PREDICATE, 12)\n        .randomVerticalOffset(-1)\n        .biomeFilter()\n        .register()\n\n}\n</code></pre> <ol> <li>Set the y-level to a random int up to 256. The call is equivalent to    <pre><code>HeightRangePlacement.uniform(VerticalAnchor.bottom(), VerticalAnchor.absolute(256));\n</code></pre></li> <li>Search for the first solid block upwards.</li> </ol> configured_feature/rooted_azalea_tree.json<pre><code>{\n  \"type\": \"minecraft:root_system\",\n  \"config\": {\n    \"allowed_tree_position\": {\n      \"type\": \"minecraft:all_of\",\n      \"predicates\": [\n        {\n          \"type\": \"minecraft:any_of\",\n          \"predicates\": [\n            {\n              \"type\": \"minecraft:matching_blocks\",\n              \"blocks\": [\n                \"minecraft:air\",\n                \"minecraft:cave_air\",\n                \"minecraft:void_air\",\n                \"minecraft:water\"\n              ]\n            },\n            {\n              \"type\": \"minecraft:matching_block_tag\",\n              \"tag\": \"minecraft:leaves\"\n            },\n            {\n              \"type\": \"minecraft:matching_block_tag\",\n              \"tag\": \"minecraft:replaceable_plants\"\n            }\n          ]\n        },\n        {\n          \"type\": \"minecraft:matching_block_tag\",\n          \"offset\": [\n            0,\n            -1,\n            0\n          ],\n          \"tag\": \"minecraft:azalea_grows_on\"\n        }\n      ]\n    },\n    \"allowed_vertical_water_for_tree\": 2,\n    \"feature\": {\n      \"feature\": \"minecraft:azalea_tree\",\n      \"placement\": []\n    },\n    \"hanging_root_placement_attempts\": 20,\n    \"hanging_root_radius\": 3,\n    \"hanging_root_state_provider\": {\n      \"type\": \"minecraft:simple_state_provider\",\n      \"state\": {\n        \"Name\": \"minecraft:hanging_roots\",\n        \"Properties\": {\n          \"waterlogged\": \"false\"\n        }\n      }\n    },\n    \"hanging_roots_vertical_span\": 2,\n    \"required_vertical_space_for_tree\": 3,\n    \"root_column_max_height\": 100,\n    \"root_placement_attempts\": 20,\n    \"root_radius\": 3,\n    \"root_replaceable\": \"#minecraft:azalea_root_replaceable\",\n    \"root_state_provider\": {\n      \"type\": \"minecraft:simple_state_provider\",\n      \"state\": {\n        \"Name\": \"minecraft:rooted_dirt\"\n      }\n    }\n  }\n}\n</code></pre> placed_feature/rooted_azalea_tree.json<pre><code>{\n  \"feature\": \"minecraft:rooted_azalea_tree\",\n  \"placement\": [\n    {\n      \"type\": \"minecraft:count\",\n      \"count\": {\n        \"type\": \"minecraft:uniform\",\n        \"value\": {\n          \"max_inclusive\": 2,\n          \"min_inclusive\": 1\n        }\n      }\n    },\n    {\n      \"type\": \"minecraft:in_square\"\n    },\n    {\n      \"type\": \"minecraft:height_range\",\n      \"height\": {\n        \"type\": \"minecraft:uniform\",\n        \"max_inclusive\": {\n          \"absolute\": 256\n        },\n        \"min_inclusive\": {\n          \"above_bottom\": 0\n        }\n      }\n    },\n    {\n      \"type\": \"minecraft:environment_scan\",\n      \"allowed_search_condition\": {\n        \"type\": \"minecraft:matching_blocks\",\n        \"blocks\": \"minecraft:air\"\n      },\n      \"direction_of_search\": \"up\",\n      \"max_steps\": 12,\n      \"target_condition\": {\n        \"type\": \"minecraft:solid\"\n      }\n    },\n    {\n      \"type\": \"minecraft:random_offset\",\n      \"xz_spread\": 0,\n      \"y_spread\": -1\n    },\n    {\n      \"type\": \"minecraft:biome\"\n    }\n  ]\n}\n</code></pre>"},{"location":"addon/worldgen/features/configurations/root-system/#result","title":"Result","text":""},{"location":"addon/worldgen/features/configurations/sculk-patch/","title":"Sculk patch feature","text":"<p>The <code>sculk_patch</code> feature allows you to generate sculk patches in the world.</p>"},{"location":"addon/worldgen/features/configurations/sculk-patch/#configuration","title":"Configuration","text":"<p>The <code>sculk_patch</code> feature has the following configuration options:</p> Option Type Description <code>charge_count</code> An <code>int</code>. (Range limit in Json is \\([1;32]\\)) The amount of charges the sculk patch should have. <code>amount_per_charge</code> An <code>int</code>. (Range limit in Json is \\([1;500]\\)) The initial value of each charge. <code>spread_attempts</code> An <code>int</code>. (Range limit in Json is \\([1;64]\\)) The amount of attempts to spread the sculk patch. <code>growth_rounds</code> An <code>int</code>. (Range limit in Json is \\([0;8]\\)) The amount of times to generate the patch. <code>spread_rounds</code> An <code>int</code>. (Range limit in Json is \\([0;8]\\)) The amount of times to spread the patch. <code>extra_rare_growths</code> An <code>IntProvider</code>. (Range limit in Json is \\([0;8]\\)) The amount of extra sculk shriekers to generate. <code>catalyst_chance</code> A <code>float</code> in the range \\([0.0;1.0]\\) The chance for a sculk catalyst to generate. <p>In code, the <code>SculkPatchConfiguration</code> class is used to configure the feature.</p>"},{"location":"addon/worldgen/features/configurations/sculk-patch/#example","title":"Example","text":"<p>As an example, here's the default sculk patch configured- and placed feature used for the deep dark biome</p> KotlinJson ConfiguredFeatures.kt<pre><code>@OptIn(ExperimentalWorldGen::class)\n@Init(stage = InitStage.POST_PACK_PRE_WORLD)\nobject ConfiguredFeatures : FeatureRegistry by ExampleAddon.registry {\n\n    val SCULK_PATCH_DEEP_DARK = registerConfiguredFeature(\n        \"sculk_patch_deep_dark\",\n        Feature.SCULK_PATCH,\n        SculkPatchConfiguration(\n            10, // charge_count\n            32, // amount_per_charge\n            64, // spread_attempts\n            0, // growth_rounds\n            1, // spread_rounds\n            ConstantInt.of(0), // extra_rare_growths\n            0.5f // catalyst_chance\n        )\n    )\n\n}\n</code></pre> PlacedFeatures.kt<pre><code>@OptIn(ExperimentalWorldGen::class)\n@Init(stage = InitStage.POST_PACK_PRE_WORLD)\nobject PlacedFeatures : FeatureRegistry by ExampleAddon.registry {\n\n    val SCULK_PATCH_DEEP_DARK = placedFeature(\"sculk_patch_deep_dark\", ConfiguredFeatures.SCULK_PATCH_DEEP_DARK)\n        .count(256) // (1)!\n        .inSquareSpread() // (2)!\n        .inYWorldBounds() // (3)!\n        .biomeFilter() // (4)!\n        .register()\n\n}\n</code></pre> <ol> <li>256 attempts to generate sculk patches per chunk.</li> <li>Randomly offset the attempts horizontally.</li> <li>Set the y-coordinate to a random value up to 256. The call is equivalent to    <pre><code>HeightRangePlacement.uniform(VerticalAnchor.bottom(), VerticalAnchor.absolute(256));\n</code></pre></li> <li>Only generate in the deep dark biome.</li> </ol> configured_feature/sculk_patch_deep_dark.json<pre><code>{\n  \"type\": \"minecraft:sculk_patch\",\n  \"config\": {\n    \"amount_per_charge\": 32,\n    \"catalyst_chance\": 0.5,\n    \"charge_count\": 10,\n    \"extra_rare_growths\": 0,\n    \"growth_rounds\": 0,\n    \"spread_attempts\": 64,\n    \"spread_rounds\": 1\n  }\n}\n</code></pre> placed_feature/sculk_patch_deep_dark.json<pre><code>{\n  \"feature\": \"minecraft:sculk_patch_deep_dark\",\n  \"placement\": [\n    {\n      \"type\": \"minecraft:count\",\n      \"count\": 256 // (1)!\n    },\n    {\n      \"type\": \"minecraft:in_square\" // (2)!\n    },\n    {\n      \"type\": \"minecraft:height_range\", // (3)!\n      \"height\": {\n        \"type\": \"minecraft:uniform\",\n        \"max_inclusive\": {\n          \"absolute\": 256\n        },\n        \"min_inclusive\": {\n          \"above_bottom\": 0\n        }\n      }\n    },\n    {\n      \"type\": \"minecraft:biome\" // (4)!\n    }\n  ]\n}\n</code></pre> <ol> <li>256 attempts to generate sculk patches per chunk.</li> <li>Randomly offset the attempts horizontally.</li> <li>Set the y-coordinate to a random value up to 256.</li> <li>Only generate in the deep dark biome.</li> </ol> <p></p>"},{"location":"addon/worldgen/features/configurations/sea-pickle/","title":"Sea pickle feature","text":"<p>As the name suggests, the <code>sea_pickle</code> feature generates sea pickles in the ocean.</p>"},{"location":"addon/worldgen/features/configurations/sea-pickle/#configuration","title":"Configuration","text":"<p>The <code>sea_pickle</code> feature only has a <code>count</code> <code>IntProvider</code> option. It determines the max amount of sea pickles per placement.</p> <p>In code, the <code>CountConfiguration</code> class is used to configure the feature.</p>"},{"location":"addon/worldgen/features/configurations/sea-pickle/#example","title":"Example","text":"KotlinJson ConfiguredFeatures.kt<pre><code>@OptIn(ExperimentalWorldGen::class)\n@Init(stage = InitStage.POST_PACK_PRE_WORLD)\nobject ConfiguredFeatures : FeatureRegistry by ExampleAddon.registry {\n\n    val SEA_PICKLE = registerConfiguredFeature(\n        \"sea_pickle\",\n        Feature.SEA_PICKLE,\n        CountConfiguration(20)\n    )\n\n}\n</code></pre> PlacedFeatures.kt<pre><code>@OptIn(ExperimentalWorldGen::class)\n@Init(stage = InitStage.POST_PACK_PRE_WORLD)\nobject PlacedFeatures : FeatureRegistry by ExampleAddon.registry {\n\n    val SEA_PICKLE = placedFeature(\"sea_pickle\", ConfiguredFeatures.SEA_PICKLE)\n        .rarityFilter(16) // (1)!\n        .inSquareSpread() // (2)!\n        .moveToTopSolid() // (3)!\n        .biomeFilter() // (4)!\n        .register()\n\n}\n</code></pre> <ol> <li>Place sea pickles in every 16th chunk.</li> <li>Randomly offset the placement horizontally.</li> <li>Set y-coordinate to the ocean floor. This call is equivalent to    <pre><code>HeightmapPlacement.onHeightmap(Heightmap.Types.OCEAN_FLOOR_WG)\n</code></pre></li> <li>Only place in the warm ocean biome.</li> </ol> configured_feature/sea_pickle.json<pre><code>{\n  \"type\": \"minecraft:sea_pickle\",\n  \"config\": {\n    \"count\": 20\n  }\n}\n</code></pre> placed_feature/sea_pickle.json<pre><code>{\n  \"feature\": \"minecraft:sea_pickle\",\n  \"placement\": [\n    {\n      \"type\": \"minecraft:rarity_filter\",\n      \"chance\": 16 // (1)!\n    },\n    {\n      \"type\": \"minecraft:in_square\" // (2)!\n    },\n    {\n      \"type\": \"minecraft:heightmap\",\n      \"heightmap\": \"OCEAN_FLOOR_WG\" // (3)!\n    },\n    {\n      \"type\": \"minecraft:biome\" // (4)!\n    }\n  ]\n}\n</code></pre> <ol> <li>Place sea pickles in every 16th chunk.</li> <li>Randomly offset the placement horizontally.</li> <li>Set y-coordinate to the ocean floor.</li> <li>Only place in the warm ocean biome.</li> </ol>"},{"location":"addon/worldgen/features/configurations/seagrass/","title":"Seagrass feature","text":"<p>The <code>seagrass</code> feature allows you to generate seagrass in water.</p>"},{"location":"addon/worldgen/features/configurations/seagrass/#configuration","title":"Configuration","text":"<p>The <code>seagrass</code> feature only has the <code>probability</code> option (<code>float</code> in the range \\([0.0;1.0)\\)), which determines the chance of seagrass being generated.</p> <p>In code, the <code>ProbabilityFeatureConfiguration</code> class is used to configure the feature.</p>"},{"location":"addon/worldgen/features/configurations/seagrass/#example","title":"Example","text":"<p>As an example, here's the configured- and placed feature of seagrass in the warm ocean biome.</p> KotlinJson ConfiguredFeatures.kt<pre><code>@OptIn(ExperimentalWorldGen::class)\n@Init(stage = InitStage.POST_PACK_PRE_WORLD)\nobject ConfiguredFeatures : FeatureRegistry by ExampleAddon.registry {\n\n    val SEAGRASS_TALL = registerConfiguredFeature(\n        \"seagrass_tall\",\n        Feature.SEAGRASS,\n        ProbabilityFeatureConfiguration(0.3f)\n    )\n\n}\n</code></pre> PlacedFeatures.kt<pre><code>@OptIn(ExperimentalWorldGen::class)\n@Init(stage = InitStage.POST_PACK_PRE_WORLD)\nobject PlacedFeatures : FeatureRegistry by ExampleAddon.registry {\n\n    val SEAGRASS_TALL = placedFeature(\"seagrass_tall\", ConfiguredFeatures.SEAGRASS_TALL)\n        .inSquareSpread() // (1)!\n        .moveToTopSolid() // (2)!\n        .count(80) // (3)!\n        .biomeFilter() // (4)!\n        .register()\n\n}\n</code></pre> <ol> <li>Randomly offset the placement horizontally.</li> <li>Set y-coordinate to the ocean floor. This call is equivalent to    <pre><code>HeightmapPlacement.onHeightmap(Heightmap.Types.OCEAN_FLOOR_WG)\n</code></pre></li> <li>Place 80 seagrass per chunk.</li> <li>Only place in the warm ocean biome.</li> </ol> configured_feature/seagrass_tall.json<pre><code>{\n  \"type\": \"minecraft:seagrass\",\n  \"config\": {\n    \"probability\": 0.8\n  }\n}\n</code></pre> placed_feature/seagrass_deep_warm.json<pre><code>{\n  \"feature\": \"minecraft:seagrass_tall\",\n  \"placement\": [\n    {\n      \"type\": \"minecraft:in_square\" // (1)!\n    },\n    {\n      \"type\": \"minecraft:heightmap\",\n      \"heightmap\": \"OCEAN_FLOOR_WG\" // (2)!\n    },\n    {\n      \"type\": \"minecraft:count\", // (3)!\n      \"count\": 80\n    },\n    {\n      \"type\": \"minecraft:biome\" // (4)!\n    }\n  ]\n}\n</code></pre> <ol> <li>Randomly offset the placement horizontally.</li> <li>Set y-coordinate to the ocean floor.</li> <li>Place 80 seagrass per chunk.</li> <li>Only place in the warm ocean biome.</li> </ol>"},{"location":"addon/worldgen/features/configurations/simple-block/","title":"Simple block feature","text":"<p>The <code>simple_block</code> feature allows you to randomly place blocks in the world.</p>"},{"location":"addon/worldgen/features/configurations/simple-block/#configuration","title":"Configuration","text":"<p>The <code>simple_block</code> feature has a single option, <code>to_place</code> which is a <code>BlockStateProvider</code> that specifies which block states should be placed.</p> <p>In code, the <code>SimpleBlockConfiguration</code> class is used to configure the feature.</p>"},{"location":"addon/worldgen/features/configurations/simple-block/#example","title":"Example","text":"<p>As an example, here's the feature used to randomly place spore blossoms.</p> KotlinJson ConfiguredFeatures.kt<pre><code>@OptIn(ExperimentalWorldGen::class)\n@Init(stage = InitStage.POST_PACK_PRE_WORLD)\nobject ConfiguredFeatures : FeatureRegistry by ExampleAddon.registry {\n\n    val SPORE_BLOSSOM = registerConfiguredFeature(\n        \"spore_blossom\",\n        Feature.SIMPLE_BLOCK,\n        SimpleBlockConfiguration(BlockStateProvider.simple(Blocks.SPORE_BLOSSOM))\n    )\n\n}\n</code></pre> PlacedFeatures.kt<pre><code>@OptIn(ExperimentalWorldGen::class)\n@Init(stage = InitStage.POST_PACK_PRE_WORLD)\nobject PlacedFeatures : FeatureRegistry by ExampleAddon.registry {\n\n    val SPORE_BLOSSOM = placedFeature(\"spore_blossom\", ConfiguredFeatures.SPORE_BLOSSOM)\n        .count(25) // (1)!\n        .inSquareSpread() // (2)!\n        .inYWorldBounds() // (3)!\n        .environmentScan(Direction.UP, BlockPredicate.solid(), BlockPredicate.ONLY_IN_AIR_PREDICATE, 12) // (4)!\n        .randomVerticalOffset(-1) // (5)!\n        .biomeFilter() // (6)!\n        .register()\n\n}\n</code></pre> <ol> <li>25 attempts to place a spore blossom per chunk.</li> <li>Randomly offset the location horizontally.</li> <li>Set the y-coordinate to a random value up to 256. The call is equivalent to    <pre><code>HeightRangePlacement.uniform(VerticalAnchor.bottom(), VerticalAnchor.absolute(256));\n</code></pre></li> <li>Search up to 12 blocks above the randomly selected location for a solid block.</li> <li>Offset the location by -1 vertically.</li> <li>Only place spore blossoms in biomes that have the <code>minecraft:spore_blossom</code> feature.</li> </ol> configured_feature/spore_blossom.json<pre><code>{\n  \"type\": \"minecraft:simple_block\",\n  \"config\": {\n    \"to_place\": {\n      \"type\": \"minecraft:simple_state_provider\",\n      \"state\": {\n        \"Name\": \"minecraft:spore_blossom\"\n      }\n    }\n  }\n}\n</code></pre> placed_feature/spore_blossom.json<pre><code>{\n  \"feature\": \"minecraft:spore_blossom\",\n  \"placement\": [\n    {\n      \"type\": \"minecraft:count\",\n      \"count\": 25 // (1)!\n    },\n    {\n      \"type\": \"minecraft:in_square\" // (2)!\n    },\n    {\n      \"type\": \"minecraft:height_range\", // (3)!\n      \"height\": {\n        \"type\": \"minecraft:uniform\",\n        \"max_inclusive\": {\n          \"absolute\": 256\n        },\n        \"min_inclusive\": {\n          \"above_bottom\": 0\n        }\n      }\n    },\n    {\n      \"type\": \"minecraft:environment_scan\", // (4)!\n      \"allowed_search_condition\": {\n        \"type\": \"minecraft:matching_blocks\",\n        \"blocks\": \"minecraft:air\"\n      },\n      \"direction_of_search\": \"up\",\n      \"max_steps\": 12,\n      \"target_condition\": {\n        \"type\": \"minecraft:solid\"\n      }\n    },\n    {\n      \"type\": \"minecraft:random_offset\", // (5)!\n      \"xz_spread\": 0,\n      \"y_spread\": -1\n    },\n    {\n      \"type\": \"minecraft:biome\" // (6)!\n    }\n  ]\n}\n</code></pre> <ol> <li>25 attempts to place a spore blossom per chunk.</li> <li>Randomly offset the location horizontally.</li> <li>Set the y-coordinate to a random value up to 256.</li> <li>Search up to 12 blocks above the randomly selected location for a solid block.</li> <li>Offset the location by -1 vertically.</li> <li>Only place spore blossoms in biomes that have the <code>minecraft:spore_blossom</code> feature.</li> </ol> <p></p>"},{"location":"addon/worldgen/features/configurations/simple-random-selector/","title":"Simple random selector feature","text":"<p>Similar to the random selector feature, the <code>simple_random_selector</code> feature can be used to randomly choose from a provided list of features to place. The only difference being the absence of the <code>default</code> and <code>probability</code> options since all features have an equal chance of being picked.</p>"},{"location":"addon/worldgen/features/configurations/simple-random-selector/#configuration","title":"Configuration","text":"<p>The <code>simple_random_selector</code> feature only has the <code>features</code> option:</p> Option Type Description <code>features</code> Either a single placed feature object or a list of them (Ids are supported in Json). The list of features to choose from. <p>In code, the <code>SimpleRandomFeatureConfiguration</code> class is used to configure the feature.</p>"},{"location":"addon/worldgen/features/configurations/simple-random-selector/#example","title":"Example","text":"<p>As mentioned on the Pointed Dripstone page, the <code>simple_random_selector</code> feature is used to randomly choose between a stalactite and a stalagmite. Si here's the full configured- and placed feature.</p> KotlinJson ConfiguredFeatures.kt<pre><code>@OptIn(ExperimentalWorldGen::class)\n@Init(stage = InitStage.POST_PACK_PRE_WORLD)\nobject ConfiguredFeatures : FeatureRegistry by ExampleAddon.registry {\n\n    val POINTED_DRIPSTONE = registerConfiguredFeature(\n        \"pointed_dripstone\",\n        Feature.SIMPLE_RANDOM_SELECTOR,\n        SimpleRandomFeatureConfiguration(HolderSet.direct(\n            PlacementUtils.inlinePlaced(\n                Feature.POINTED_DRIPSTONE,\n                PointedDripstoneConfiguration(0.2f, 0.7f, 0.5f, 0.5f),\n                EnvironmentScanPlacement.scanningFor(Direction.DOWN, BlockPredicate.solid(), BlockPredicate.ONLY_IN_AIR_OR_WATER_PREDICATE, 12),\n                RandomOffsetPlacement.vertical(ConstantInt.of(1))\n            ),\n            PlacementUtils.inlinePlaced(\n                Feature.POINTED_DRIPSTONE,\n                PointedDripstoneConfiguration(0.2f, 0.7f, 0.5f, 0.5f),\n                EnvironmentScanPlacement.scanningFor(Direction.UP, BlockPredicate.solid(), BlockPredicate.ONLY_IN_AIR_OR_WATER_PREDICATE, 12),\n                RandomOffsetPlacement.vertical(ConstantInt.of(-1)))\n        ))\n    )\n\n}\n</code></pre> PlacedFeatures.kt<pre><code>@OptIn(ExperimentalWorldGen::class)\n@Init(stage = InitStage.POST_PACK_PRE_WORLD)\nobject PlacedFeatures : FeatureRegistry by ExampleAddon.registry {\n\n    val POINTED_DRIPSTONE = placedFeature(\"pointed_dripstone\", ConfiguredFeatures.POINTED_DRIPSTONE)\n        .count(UniformInt.of(192, 256))\n        .inSquareSpread()\n        .inYWorldBounds()\n        .count(UniformInt.of(1, 5))\n        .randomOffset(ClampedNormalInt.of(0.0f, 3.0f, -10, 10), ClampedNormalInt.of(0.0f, 0.6f, -2, 2))\n        .biomeFilter()\n        .register()\n\n}\n</code></pre> configured_feature/pointed_dripstone.json<pre><code>{\n  \"type\": \"minecraft:simple_random_selector\",\n  \"config\": {\n    \"features\": [\n      {\n        \"feature\": {\n          \"type\": \"minecraft:pointed_dripstone\",\n          \"config\": {\n            \"chance_of_directional_spread\": 0.7,\n            \"chance_of_spread_radius2\": 0.5,\n            \"chance_of_spread_radius3\": 0.5,\n            \"chance_of_taller_dripstone\": 0.2\n          }\n        },\n        \"placement\": [\n          {\n            \"type\": \"minecraft:environment_scan\",\n            \"allowed_search_condition\": {\n              \"type\": \"minecraft:matching_blocks\",\n              \"blocks\": [\n                \"minecraft:air\",\n                \"minecraft:water\"\n              ]\n            },\n            \"direction_of_search\": \"down\",\n            \"max_steps\": 12,\n            \"target_condition\": {\n              \"type\": \"minecraft:solid\"\n            }\n          },\n          {\n            \"type\": \"minecraft:random_offset\",\n            \"xz_spread\": 0,\n            \"y_spread\": 1\n          }\n        ]\n      },\n      {\n        \"feature\": {\n          \"type\": \"minecraft:pointed_dripstone\",\n          \"config\": {\n            \"chance_of_directional_spread\": 0.7,\n            \"chance_of_spread_radius2\": 0.5,\n            \"chance_of_spread_radius3\": 0.5,\n            \"chance_of_taller_dripstone\": 0.2\n          }\n        },\n        \"placement\": [\n          {\n            \"type\": \"minecraft:environment_scan\",\n            \"allowed_search_condition\": {\n              \"type\": \"minecraft:matching_blocks\",\n              \"blocks\": [\n                \"minecraft:air\",\n                \"minecraft:water\"\n              ]\n            },\n            \"direction_of_search\": \"up\",\n            \"max_steps\": 12,\n            \"target_condition\": {\n              \"type\": \"minecraft:solid\"\n            }\n          },\n          {\n            \"type\": \"minecraft:random_offset\",\n            \"xz_spread\": 0,\n            \"y_spread\": -1\n          }\n        ]\n      }\n    ]\n  }\n}\n</code></pre> placed_feature/pointed_dripstone.json<pre><code>{\n  \"feature\": \"minecraft:pointed_dripstone\",\n  \"placement\": [\n    {\n      \"type\": \"minecraft:count\",\n      \"count\": {\n        \"type\": \"minecraft:uniform\",\n        \"value\": {\n          \"max_inclusive\": 256,\n          \"min_inclusive\": 192\n        }\n      }\n    },\n    {\n      \"type\": \"minecraft:in_square\"\n    },\n    {\n      \"type\": \"minecraft:height_range\",\n      \"height\": {\n        \"type\": \"minecraft:uniform\",\n        \"max_inclusive\": {\n          \"absolute\": 256\n        },\n        \"min_inclusive\": {\n          \"above_bottom\": 0\n        }\n      }\n    },\n    {\n      \"type\": \"minecraft:count\",\n      \"count\": {\n        \"type\": \"minecraft:uniform\",\n        \"value\": {\n          \"max_inclusive\": 5,\n          \"min_inclusive\": 1\n        }\n      }\n    },\n    {\n      \"type\": \"minecraft:random_offset\",\n      \"xz_spread\": {\n        \"type\": \"minecraft:clamped_normal\",\n        \"value\": {\n          \"deviation\": 3.0,\n          \"max_inclusive\": 10,\n          \"mean\": 0.0,\n          \"min_inclusive\": -10\n        }\n      },\n      \"y_spread\": {\n        \"type\": \"minecraft:clamped_normal\",\n        \"value\": {\n          \"deviation\": 0.6,\n          \"max_inclusive\": 2,\n          \"mean\": 0.0,\n          \"min_inclusive\": -2\n        }\n      }\n    },\n    {\n      \"type\": \"minecraft:biome\"\n    }\n  ]\n}\n</code></pre> <p></p>"},{"location":"addon/worldgen/features/configurations/spring-feature/","title":"Spring feature","text":"<p>The <code>spring_feature</code> allows you to single-block fluid springs in the world.</p>"},{"location":"addon/worldgen/features/configurations/spring-feature/#configuration","title":"Configuration","text":"<p>The <code>spring_feature</code> has the following configuration options:</p> Option Type Description <code>state</code> A <code>BlockState</code> (Has to be a fluid) The fluid state to use for the spring. <code>requires_block_below</code> (optional in Json, defaults to <code>true</code>) A <code>boolean</code> Whether the spring requires a block in <code>valid_blocks</code> below. <code>rock_count</code> (optional in Json, defaults to 4) An <code>int</code> The required amount of blocks in <code>valid_blocks</code> around the spring. <code>hole_count</code> (optional in Json, defaults to 1) An <code>int</code> The required amount of air blocks around the spring. <code>valid_blocks</code> A list of <code>BlockStates</code> The blocks that are valid for the spring to spawn in. <p>In code, the <code>SpringConfiguration</code> class is used to configure the feature.</p>"},{"location":"addon/worldgen/features/configurations/spring-feature/#example","title":"Example","text":"<p>As an example, here's the placed and configured feature used to place water springs in caves.</p> KotlinJson ConfiguredFeatures.kt<pre><code>@OptIn(ExperimentalWorldGen::class)\n@Init(stage = InitStage.POST_PACK_PRE_WORLD)\nobject ConfiguredFeatures : FeatureRegistry by ExampleAddon.registry {\n\n    val SPRING_WATER = registerConfiguredFeature(\n        \"spring_water\",\n        Feature.SPRING,\n        SpringConfiguration(\n            Fluids.WATER.defaultFluidState(), // state\n            true, // requires_block_below\n            4, // rock_count\n            1, // hole_count\n            HolderSet.direct( // valid_blocks\n                Block::builtInRegistryHolder,\n                Blocks.STONE, Blocks.GRANITE, Blocks.DIORITE, Blocks.ANDESITE, Blocks.DEEPSLATE, Blocks.TUFF, Blocks.CALCITE, Blocks.DIRT, Blocks.SNOW_BLOCK, Blocks.POWDER_SNOW, Blocks.PACKED_ICE\n            )\n        )\n    )\n\n}\n</code></pre> PlacedFeatures.kt<pre><code>@OptIn(ExperimentalWorldGen::class)\n@Init(stage = InitStage.POST_PACK_PRE_WORLD)\nobject PlacedFeatures : FeatureRegistry by ExampleAddon.registry {\n\n    val SPRING_WATER = placedFeature(\"spring_water\", ConfiguredFeatures.SPRING_WATER)\n        .count(25) // (1)!\n        .inSquareSpread() // (2)!\n        .heightRangeUniform(VerticalAnchor.bottom(), VerticalAnchor.absolute(192)) // (3)!\n        .biomeFilter() // (4)!\n        .register()\n\n}\n</code></pre> <ol> <li>25 attempts per chunk.</li> <li>Spread the springs out.</li> <li>Set the y-coordinate to a random value between the minimum y-level and 192.</li> <li>Only place the springs in biomes that have the configured feature.</li> </ol> configured_feature/spring_water.json<pre><code>{\n  \"type\": \"minecraft:spring_feature\",\n  \"config\": {\n    \"hole_count\": 1,\n    \"requires_block_below\": true,\n    \"rock_count\": 4,\n    \"state\": {\n      \"Name\": \"minecraft:water\",\n      \"Properties\": {\n        \"falling\": \"true\"\n      }\n    },\n    \"valid_blocks\": [\n      \"minecraft:stone\",\n      \"minecraft:granite\",\n      \"minecraft:diorite\",\n      \"minecraft:andesite\",\n      \"minecraft:deepslate\",\n      \"minecraft:tuff\",\n      \"minecraft:calcite\",\n      \"minecraft:dirt\",\n      \"minecraft:snow_block\",\n      \"minecraft:powder_snow\",\n      \"minecraft:packed_ice\"\n    ]\n  }\n}\n</code></pre> placed_feature/spring_water.json<pre><code>{\n  \"feature\": \"minecraft:spring_water\",\n  \"placement\": [\n    {\n      \"type\": \"minecraft:count\", // (1)!\n      \"count\": 25\n    },\n    {\n      \"type\": \"minecraft:in_square\" // (2)!\n    },\n    {\n      \"type\": \"minecraft:height_range\", // (3)!\n      \"height\": {\n        \"type\": \"minecraft:uniform\",\n        \"max_inclusive\": {\n          \"absolute\": 192\n        },\n        \"min_inclusive\": {\n          \"above_bottom\": 0\n        }\n      }\n    },\n    {\n      \"type\": \"minecraft:biome\" // (4)!\n    }\n  ]\n}\n</code></pre> <ol> <li>25 attempts per chunk.</li> <li>Spread the springs out.</li> <li>Set the y-coordinate to a random value between 0 and 192.</li> <li>Only place the springs in biomes that have the configured feature.</li> </ol>"},{"location":"addon/worldgen/features/configurations/spring-feature/#result","title":"Result","text":""},{"location":"addon/worldgen/features/configurations/tree/","title":"Trees","text":"<p>TODO</p>"},{"location":"addon/worldgen/features/configurations/twisting-vines/","title":"Twisting vines Feature","text":"<p>Hardcoded block check</p> <p>This feature has a hardcoded check for the block below the feature being <code>netherrack</code>, <code>warped_nylium</code> or <code>warped_wart_block</code> and will not work on other blocks</p> <p>The <code>twisting_vines</code> can be used to generate twisting vines in the world.</p>"},{"location":"addon/worldgen/features/configurations/twisting-vines/#configuration","title":"Configuration","text":"<p>The <code>twisting_vines</code> feature has the following configuration options:</p> Option Type Description <code>spread_width</code> A positive <code>int</code> Specifies the spread width of the twisting vines. Max width is <code>spread_width * 2 + 1</code> <code>spread_height</code> A positive <code>int</code> Specifies the spread height of the twisting vines. Max height is <code>spread_height * 2 + 1</code> <code>max_height</code> A positive <code>int</code> Specifies the maximum height of the twisting vines. Actual height is <code>max_height * 2</code> <p>In code, the <code>TwistingVinesConfig</code> class is used to configure the feature.</p>"},{"location":"addon/worldgen/features/configurations/twisting-vines/#example","title":"Example","text":"<p>As an example, here's the configured- and placed feature to generate twisting vines in the nether:</p> KotlinJson ConfiguredFeatures.kt<pre><code>@OptIn(ExperimentalWorldGen::class)\n@Init(stage = InitStage.POST_PACK_PRE_WORLD)\nobject ConfiguredFeatures : FeatureRegistry by ExampleAddon.registry {\n\n    val TWISTING_VINES = registerConfiguredFeature(\n        \"twisting_vines\",\n        Feature.TWISTING_VINES,\n        TwistingVinesConfig(\n            8, // spreadWidth\n            4, // spreadHeight\n            8 // maxHeight\n        )\n    )\n\n}\n</code></pre> PlacedFeatures.kt<pre><code>@OptIn(ExperimentalWorldGen::class)\n@Init(stage = InitStage.POST_PACK_PRE_WORLD)\nobject PlacedFeatures : FeatureRegistry by ExampleAddon.registry {\n\n    val TWISTING_VINES = placedFeature(\"twisting_vines\", ConfiguredFeatures.TWISTING_VINES)\n        .count(10) // (1)!\n        .inSquareSpread() // (2)!\n        .modifier(PlacementUtils.FULL_RANGE) // (3)!\n        .biomeFilter() // (4)!\n        .register()\n\n}\n</code></pre> <ol> <li>10 twisting vines per chunk.</li> <li>Spread the vines horizontally.</li> <li>Set the y-coordinate to a random value. The static constant is equivalent to    <pre><code>HeightRangePlacement.uniform(VerticalAnchor.bottom(), VerticalAnchor.top());\n</code></pre></li> <li>Only place the vines if the location hasn't moved outside the warped forest biome.</li> </ol> configured_features/twisting_vines.json<pre><code>{\n   \"type\": \"minecraft:twisting_vines\",\n   \"config\": {\n      \"spread_width\": 8,\n      \"spread_height\": 4,\n      \"max_height\": 8\n   }\n}\n</code></pre> placed_features/twisting_vines.json<pre><code>{\n   \"feature\": \"minecraft:twisting_vines\",\n   \"placement\": [\n      {\n         \"type\": \"minecraft:count\", // (1)!\n         \"count\": 10\n      },\n      {\n         \"type\": \"minecraft:in_square\" // (2)!\n      },\n      {\n         \"type\": \"minecraft:height_range\", // (3)!\n         \"height\": {\n            \"type\": \"minecraft:uniform\",\n            \"max_inclusive\": {\n               \"below_top\": 0\n            },\n            \"min_inclusive\": {\n               \"above_bottom\": 0\n            }\n         }\n      },\n      {\n         \"type\": \"minecraft:biome\" // (4)!\n      }\n   ]\n}\n</code></pre> <ol> <li>10 twisting vines per chunk.</li> <li>Spread the vines horizontally.</li> <li>Set the y-coordinate to a random value. The static constant is equivalent to    <pre><code>HeightRangePlacement.uniform(VerticalAnchor.bottom(), VerticalAnchor.top());\n</code></pre></li> <li>Only place the vines if the location hasn't moved outside the warped forest biome.</li> </ol>"},{"location":"addon/worldgen/features/configurations/twisting-vines/#result","title":"Result","text":"AloneNaturally generated <p><p> </p></p> <p><p> </p></p>"},{"location":"addon/worldgen/features/configurations/underwater-magma/","title":"Underwater magma feature","text":"<p>The <code>underwater_magma</code> feature can be used to generate magma blocks underwater.</p>"},{"location":"addon/worldgen/features/configurations/underwater-magma/#configuration","title":"Configuration","text":"<p>The <code>underwater_magma</code> feature has the following configuration options:</p> Option Type Description <code>floor_search_range</code> An <code>int</code>. (Range limit in Json is \\([0;512]\\)) The maximum y-distance from the origin <code>Blockpos</code> of the feature to search for a floor. <code>placement_radius_around_floor</code> An <code>int</code>. (Range limit in Json is \\([0;64]\\)) The radius around the floor to place magma blocks. <code>placement_probability_per_valid_position</code> A <code>float</code>. (Range limit in Json is \\([0.0;1.0]\\)) The probability that a magma block will be placed at a valid position. <p>In code, the <code>UnderwaterMagmaConfiguration</code> class is used to configure the feature.</p>"},{"location":"addon/worldgen/features/configurations/underwater-magma/#example","title":"Example","text":"<p>As an example, here's the placed and configured feature used to place magma blocks in underwater caves:</p> KotlinJson ConfiguredFeatures.kt<pre><code>@OptIn(ExperimentalWorldGen::class)\n@Init(stage = InitStage.POST_PACK_PRE_WORLD)\nobject ConfiguredFeatures : FeatureRegistry by ExampleAddon.registry {\n\n    val UNDERWATER_MAGMA = registerConfiguredFeature(\n        \"underwater_magma\",\n        Feature.UNDERWATER_MAGMA,\n        UnderwaterMagmaConfiguration(\n            5, // floor_search_range\n            1, // placement_radius_around_floor\n            0.5F // placement_probability_per_valid_position\n        )\n    )\n\n}\n</code></pre> <pre><code>@OptIn(ExperimentalWorldGen::class)\n@Init(stage = InitStage.POST_PACK_PRE_WORLD)\nobject PlacedFeatures : FeatureRegistry by ExampleAddon.registry {\n\n    val UNDERWATER_MAGMA = placedFeature(\"underwater_magma\", ConfiguredFeatures.UNDERWATER_MAGMA)\n        .count(UniformInt.of(44, 52)) // (1)!\n        .inSquareSpread() // (2)!\n        .inYWorldBounds() // (3)!\n        .surfaceRelativeThresholdFilter(Heightmap.Types.OCEAN_FLOOR_WG, Int.MIN_VALUE, -2) // (4)!\n        .biomeFilter() // (5)!\n        .register()\n\n}\n</code></pre> <ol> <li>Random amount between 44 and 52.</li> <li>Randomly spread the blocks horizontally.</li> <li>Constant for    <pre><code>HeightRangePlacement.uniform(VerticalAnchor.bottom(), VerticalAnchor.absolute(256))\n</code></pre></li> <li>Only place the feature if it's at least 2 blocks below the ocean floor.</li> <li>Only place the feature in biomes that have underwater magma.</li> </ol> configured_feature/underwater_magma.json<pre><code>{\n   \"type\": \"minecraft:underwater_magma\",\n   \"config\": {\n      \"floor_search_range\": 5,\n      \"placement_probability_per_valid_position\": 0.5,\n      \"placement_radius_around_floor\": 1\n   }\n}\n</code></pre> placed_feature/underwater_magma.json<pre><code>{\n   \"feature\": \"minecraft:underwater_magma\",\n   \"placement\": [\n      {\n         \"type\": \"minecraft:count\", // (1)!\n         \"count\": {\n            \"type\": \"minecraft:uniform\",\n            \"value\": {\n               \"max_inclusive\": 52,\n               \"min_inclusive\": 44\n            }\n         }\n      },\n      {\n         \"type\": \"minecraft:in_square\" // (2)!\n      },\n      {\n         \"type\": \"minecraft:height_range\", // (3)!\n         \"height\": {\n            \"type\": \"minecraft:uniform\",\n            \"max_inclusive\": {\n               \"absolute\": 256\n            },\n            \"min_inclusive\": {\n               \"above_bottom\": 0\n            }\n         }\n      },\n      {\n         \"type\": \"minecraft:surface_relative_threshold_filter\", // (4)!\n         \"heightmap\": \"OCEAN_FLOOR_WG\",\n         \"max_inclusive\": -2\n      },\n      {\n         \"type\": \"minecraft:biome\" // (5)!\n      }\n   ]\n}\n</code></pre> <ol> <li>Random amount between 44 and 52.</li> <li>Randomly spread the blocks horizontally.</li> <li>Constant for    <pre><code>HeightRangePlacement.uniform(VerticalAnchor.bottom(), VerticalAnchor.absolute(256))\n</code></pre></li> <li>Only place the feature if it's at least 2 blocks below the ocean floor.</li> <li>Only place the feature in biomes that have underwater magma.</li> </ol>"},{"location":"addon/worldgen/features/configurations/underwater-magma/#result","title":"Result","text":""},{"location":"addon/worldgen/features/configurations/vegetation-patch/","title":"Vegetation patch feature","text":"<p>The <code>vegetation_patch</code> and <code>waterlogged_vegetation_patch</code> features can be used to randomly spread vegetation in the world.</p>"},{"location":"addon/worldgen/features/configurations/vegetation-patch/#configuration","title":"Configuration","text":"<p>The vegetation patch feature has the following configuration options:</p> Option Type Description <code>replaceable</code> A block tag (Starting with <code>#</code> in Json). The blocks that can be replaced by the vegetation. <code>ground_state</code> A <code>BlockStateProvider</code> The block state of the vegetation. <code>vegetation_feature</code> A <code>PlacedFeature</code> (or id in Json). The vegetation to place. <code>surface</code> Enum constants of <code>CaveSurface</code> (<code>ceiling</code> or <code>floor</code>). The surface to place the vegetation on. <code>depth</code> An <code>IntProvider</code> (Range limit in Json is \\([0;128]\\)). The search depth. <code>extra_bottom_block_chance</code> A <code>float</code> (Range limit in Json is \\([0.0;1.0]\\)). The chance that an extra block is placed at the bottom of the vegetation. <code>vertical_range</code> An <code>int</code> (Range limit in Json is \\([1;256]\\)). The vertical range of the vegetation. <code>vegetation_chance</code> A <code>float</code> (Range limit in Json is \\([0.0;1.0]\\)). The chance that the vegetation is placed. <code>xz_radius</code> An <code>IntProvider</code> (Range limit in Json is \\([0;128]\\)). The horizontal radius of the vegetation. <code>extra_edge_column_chance</code> A <code>float</code> (Range limit in Json is \\([0.0;1.0]\\)). The chance that an extra column is placed at the edge of the vegetation. <p>In code, the <code>VegetationPatchConfiguration</code> class is used to configure the feature.</p>"},{"location":"addon/worldgen/features/configurations/vegetation-patch/#example","title":"Example","text":"<p>As an example, here's the configured- and placed feature for placing moss in caves.</p> KotlinJson ConfiguredFeatures.kt<pre><code>@OptIn(ExperimentalWorldGen::class)\n@Init(stage = InitStage.POST_PACK_PRE_WORLD)\nobject ConfiguredFeatures : FeatureRegistry by ExampleAddon.registry {\n\n    val MOSS_PATCH = registerConfiguredFeature(\n        \"moss_patch\",\n        Feature.VEGETATION_PATCH,\n        VegetationPatchConfiguration(\n            BlockTags.MOSS_REPLACEABLE, // replaceable\n            BlockStateProvider.simple(Blocks.MOSS_BLOCK), // ground_state\n            PlacementUtils.inlinePlaced(VanillaRegistryAccess.getHolder(CaveFeatures.MOSS_VEGETATION)), // vegetation_feature (1)\n            CaveSurface.FLOOR, // surface\n            ConstantInt.of(1), // depth\n            0.0F, // extra_bottom_block_chance\n            5, // vertical_range\n            0.8F, // vegetation_chance\n            UniformInt.of(4, 7), // xz_radius\n            0.3F // extra_edge_column_chance\n        )\n    )\n\n}\n</code></pre> <ol> <li>Check out inlined placed features for more information.</li> </ol> PlacedFeatures.kt<pre><code>@OptIn(ExperimentalWorldGen::class)\n@Init(stage = InitStage.POST_PACK_PRE_WORLD)\nobject PlacedFeatures : FeatureRegistry by ExampleAddon.registry {\n\n    val MOSS_PATCH = placedFeature(\"lush_caves_vegetation\", ConfiguredFeatures.MOSS_PATCH)\n        .count(125) // (1)!\n        .inSquareSpread() // (2)!\n        .inYWorldBounds() // (3)!\n        .environmentScan( // (4)!\n            Direction.DOWN,\n            BlockPredicate.solid(),\n            BlockPredicate.ONLY_IN_AIR_PREDICATE,\n            12\n        )\n        .randomVerticalOffset(1) // (5)!\n        .biomeFilter() // (6)!\n        .register()\n\n}\n</code></pre> <ol> <li>125 attempts per chunk.</li> <li>Spread the vegetation in horizontally.</li> <li>Set the y-level to a random int up to 256. The static constant is equivalent to    <pre><code>HeightRangePlacement.uniform(VerticalAnchor.bottom(), VerticalAnchor.absolute(256));\n</code></pre></li> <li>Search for the first solid block below the current position for 12 blocks.</li> <li>Add a y-offset of 1 block.</li> <li>Only place the vegetation in lush caves.</li> </ol> configured_feature/moss_patch.json<pre><code>{\n  \"type\": \"minecraft:vegetation_patch\",\n  \"config\": {\n    \"depth\": 1,\n    \"extra_bottom_block_chance\": 0.0,\n    \"extra_edge_column_chance\": 0.3,\n    \"ground_state\": {\n      \"type\": \"minecraft:simple_state_provider\",\n      \"state\": {\n        \"Name\": \"minecraft:moss_block\"\n      }\n    },\n    \"replaceable\": \"#minecraft:moss_replaceable\",\n    \"surface\": \"floor\",\n    \"vegetation_chance\": 0.8,\n    \"vegetation_feature\": {\n      \"feature\": \"minecraft:moss_vegetation\",\n      \"placement\": []\n    },\n    \"vertical_range\": 5,\n    \"xz_radius\": {\n      \"type\": \"minecraft:uniform\",\n      \"value\": {\n        \"max_inclusive\": 7,\n        \"min_inclusive\": 4\n      }\n    }\n  }\n}\n</code></pre> placed_feature/lush_caves_vegetation.json<pre><code>{\n  \"feature\": \"minecraft:moss_patch\",\n  \"placement\": [\n    {\n      \"type\": \"minecraft:count\", // (1)!\n      \"count\": 125\n    },\n    {\n      \"type\": \"minecraft:in_square\" // (2)!\n    },\n    {\n      \"type\": \"minecraft:height_range\", // (3)!\n      \"height\": {\n        \"type\": \"minecraft:uniform\",\n        \"max_inclusive\": {\n          \"absolute\": 256\n        },\n        \"min_inclusive\": {\n          \"above_bottom\": 0\n        }\n      }\n    },\n    {\n      \"type\": \"minecraft:environment_scan\", // (4)!\n      \"allowed_search_condition\": {\n        \"type\": \"minecraft:matching_blocks\",\n        \"blocks\": \"minecraft:air\"\n      },\n      \"direction_of_search\": \"down\",\n      \"max_steps\": 12,\n      \"target_condition\": {\n        \"type\": \"minecraft:solid\"\n      }\n    },\n    {\n      \"type\": \"minecraft:random_offset\", // (5)!\n      \"xz_spread\": 0,\n      \"y_spread\": 1\n    },\n    {\n      \"type\": \"minecraft:biome\" // (6)!\n    }\n  ]\n}\n</code></pre> <ol> <li>125 attempts per chunk.</li> <li>Spread the vegetation in horizontally.</li> <li>Set the y-level to a random int up to 256. The static constant is equivalent to    <pre><code>HeightRangePlacement.uniform(VerticalAnchor.bottom(), VerticalAnchor.absolute(256));\n</code></pre></li> <li>Search for the first solid block below the current position for 12 blocks.</li> <li>Add a y-offset of 1 block.</li> <li>Only place the vegetation in lush caves.</li> </ol>"},{"location":"addon/worldgen/features/configurations/vegetation-patch/#result","title":"Result","text":""},{"location":"addon/worldgen/inject/biome/","title":"Biome injections","text":"<p>Warning</p> <p>This worldgen page is still a work in progress. Some Json formats/code examples/features might be missing and will be added in the future.</p> <p><code>BiomeInjections</code> allow you to add <code>PlacedFeatures</code> to an already existing biome. In the future, this will also allow you to modify any other biome property.</p>"},{"location":"addon/worldgen/inject/biome/#example-usage","title":"Example usage","text":"<p>Here's how you could inject the <code>star_shards_ore</code> <code>PlacedFeature</code> from Machines into all overworld biomes:</p> KotlinJson BiomeInjections.kt<pre><code>@OptIn(ExperimentalWorldGen::class)\n@Init(stage = InitStage.POST_PACK_PRE_WORLD)\nobject BiomeInjections : BiomeRegistry by ExampleAddon.registry {\n\n    private val OVERWORLD = biomeInjection(\"overworld\")\n        .biomes(BiomeTags.IS_OVERWORLD)\n        .feature(Decoration.UNDERGROUND_ORES, PlacedFeatures.ORE_STAR_SHARDS)\n        .register()\n\n}\n</code></pre> data/worldgen/inject/biome/overworld.json<pre><code>{\n  \"biomes\": \"#minecraft:is_overworld\",\n  \"features\": [\n    [],\n    [],\n    [],\n    [],\n    [],\n    [],\n    [\n      \"machines:ore_star_shards\"\n    ],\n    [],\n    [],\n    [],\n    []\n  ]\n}\n</code></pre>"},{"location":"addon/worldgen/types/block-predicate/","title":"BlockPredicates","text":"<p>Warning</p> <p>This worldgen page is still a work in progress. Some Json formats/code examples/features might be missing and will be added in the future.</p> <p>TODO - Check out the Minecraft Wiki in the meantime.</p>"},{"location":"addon/worldgen/types/block-state-provider/","title":"BlockState Providers","text":"<p>Warning</p> <p>This worldgen page is still a work in progress. Some Json formats/code examples/features might be missing and will be added in the future.</p> <p>TODO - Check out the Minecraft Wiki in the meantime.</p>"},{"location":"addon/worldgen/types/block-state/","title":"BlockState","text":"<p>Warning</p> <p>This worldgen page is still a work in progress. Some Json formats/code examples/features might be missing and will be added in the future.</p> <p>TODO - Check out the Minecraft Wiki in the meantime.</p>"},{"location":"addon/worldgen/types/height-provider/","title":"Height Providers","text":"<p>Height providers are used to get a height value for a given position. Before we can get into the details however, we first need to take a look at <code>VerticalAnchors</code>.</p>"},{"location":"addon/worldgen/types/height-provider/#vertical-anchors","title":"Vertical Anchors","text":"<p>Vertical anchors are used to get a fixed height value depending on factors like the min and max build height. There is  of course also a constant implementation that always returns the same value. Please note that the type doesn't have to  be specified in Json. It's automatically inferred via the key name.</p> <p>Warning</p> <p>All specified values need to be within the the min and max build height of the world.</p>"},{"location":"addon/worldgen/types/height-provider/#absolute","title":"<code>absolute</code>","text":"<p>Always returns the same y-value.</p> KotlinJson Example<pre><code>VerticalAnchor.absolute(10)\n</code></pre> Example<pre><code>{\n  \"absolute\": 10\n}\n</code></pre>"},{"location":"addon/worldgen/types/height-provider/#above_bottom","title":"<code>above_bottom</code>","text":"<p>Returns a y-value above the min build height of the world by <code>above_bottom</code> blocks.</p> KotlinJson Example<pre><code>VerticalAnchor.aboveBottom(5)\n</code></pre> <p>Tip</p> <p>If you want to get the minimum build height, you can also use <code>VerticalAnchor.bottom()</code> or <code>VerticalAnchor.BOTTOM</code> instead of <code>VerticalAnchor.aboveBottom(0)</code>.</p> Example<pre><code>{\n  \"above_bottom\": 5\n}\n</code></pre>"},{"location":"addon/worldgen/types/height-provider/#below_top","title":"<code>below_top</code>","text":"<p>Returns a y-value below the max build height of the world by <code>below_top</code> blocks.</p> KotlinJson Example<pre><code>VerticalAnchor.belowTop(5)\n</code></pre> <p>Tip</p> <p>If you want to get the maximum build height, you can also use <code>VerticalAnchor.top()</code> or <code>VerticalAnchor.TOP</code> instead of <code>VerticalAnchor.belowTop(0)</code>.</p> Example<pre><code>{\n  \"below_top\": 5\n}\n</code></pre>"},{"location":"addon/worldgen/types/height-provider/#vanilla-height-providers","title":"Vanilla Height Providers","text":""},{"location":"addon/worldgen/types/height-provider/#minecraftconstant","title":"<code>minecraft:constant</code>","text":"<p>Always returns the y-value provided by a vertical anchor.</p> <code>value</code> <p>The vertical anchor to use.</p> KotlinJson Example<pre><code>ConstantHeight.of(VerticalAnchor.absolute(10))\n</code></pre> Example<pre><code>{\n  \"type\": \"minecraft:constant\",\n  \"value\": {\n    \"absolute\": 10\n  }\n}\n</code></pre> <p>Tip</p> <p>Mojang also added a feature that allows directly specifying a vertical anchor when a height provider is expected. So this is would also be a valid height provider:</p> <pre><code>{\n  \"absolute\": 10\n}\n</code></pre> <p>Or even directly providing a constant value:</p> <pre><code>10\n</code></pre>"},{"location":"addon/worldgen/types/height-provider/#minecraftuniform","title":"<code>minecraft:uniform</code>","text":"<p>Generates a random y-value between <code>min_inclusive</code> and <code>max_inclusive</code> in a uniform distribution.</p> <code>min_inclusive</code> <p>A vertical anchor that specifies the minimum y-value.</p> <code>max_inclusive</code> <p>A vertical anchor that specifies the maximum y-value.</p> KotlinJson Example<pre><code>UniformHeight.of(VerticalAnchor.bottom(), VerticalAnchor.absolute(256))\n</code></pre> Example<pre><code>{\n  \"type\": \"minecraft:uniform\",\n  \"min_inclusive\": {\n    \"above_bottom\": 0\n  },\n  \"max_inclusive\": {\n    \"absolute\": 256\n  }\n}\n</code></pre>"},{"location":"addon/worldgen/types/height-provider/#minecraftbiased_to_bottomminecraftvery_biased_to_bottom","title":"<code>minecraft:biased_to_bottom</code>/<code>minecraft:very_biased_to_bottom</code>","text":"<p>Generates a random y-value between <code>min_inclusive</code> and <code>max_inclusive</code> with bias towards the minimum.</p> <code>min_inclusive</code> <p>A vertical anchor that specifies the minimum y-value.</p> <code>max_inclusive</code> <p>A vertical anchor that specifies the maximum y-value.</p> <code>inner</code> (Optional in Json) <p>The higher this value is, the more biased the distribution is towards the minimum. Defaults to <code>0</code>.</p> KotlinJson <pre><code>VeryBiasedToBottomHeight.of(VerticalAnchor.bottom(), VerticalAnchor.belowTop(8), 8)\n</code></pre> Example<pre><code>{\n  \"type\": \"minecraft:very_biased_to_bottom\",\n  \"min_inclusive\": {\n    \"above_bottom\": 0\n  },\n  \"max_inclusive\": {\n    \"below_top\": 8\n  },\n  \"inner\": 8\n}\n</code></pre>"},{"location":"addon/worldgen/types/height-provider/#minecrafttrapezoid","title":"<code>minecraft:trapezoid</code>","text":"<p>Generates a random y-value between <code>min_inclusive</code> and <code>max_inclusive</code> with a trapezoidal distribution.</p> <p>The Minecraft Wiki explains its usage in ore generation pretty well:</p> <p></p> <code>min_inclusive</code> <p>A vertical anchor that specifies the minimum y-value.</p> <code>max_inclusive</code> <p>A vertical anchor that specifies the maximum y-value.</p> <code>plateau</code> (optional) <p>The length of the range in the middle of the trapezoid that has a uniform distribution. Defaults to <code>0</code>.</p> KotlinJson Example<pre><code>TrapezoidHeight.of(VerticalAnchor.absolute(8), VerticalAnchor.absolute(24))\n</code></pre> Example<pre><code>{\n  \"type\": \"minecraft:trapezoid\",\n  \"min_inclusive\": {\n    \"absolute\": 8\n  },\n  \"max_inclusive\": {\n    \"absolute\": 24\n  }\n}\n</code></pre>"},{"location":"addon/worldgen/types/height-provider/#minecraftweighted_list","title":"<code>minecraft:weighted_list</code>","text":"<p>Generates a random y-value based on a weighted list of other height providers.</p> <code>distribution</code> <p>A list of height providers and their weights (Can't be empty). <code>data</code> is the actual height provider and <code>weight</code> is the weight of the provider.</p> KotlinJson Example<pre><code>WeightedListHeight(\n    SimpleWeightedRandomList.builder&lt;HeightProvider&gt;()\n        .add(UniformHeight.of(VerticalAnchor.absolute(0), VerticalAnchor.absolute(8)), 2)\n        .add(ConstantHeight.of(VerticalAnchor.absolute(0)), 1)\n        .build()\n)\n</code></pre> Example<pre><code>{\n  \"type\": \"minecraft:weighted_list\",\n  \"distribution\": [\n    {\n      \"data\": {\n        \"type\": \"minecraft:uniform\",\n        \"value\": {\n          \"min_inclusive\": 0,\n          \"max_inclusive\": 4\n        }\n      },\n      \"weight\": 2\n    },\n    {\n      \"data\": 0,\n      \"weight\": 1\n    }\n  ]\n}                \n</code></pre>"},{"location":"addon/worldgen/types/height-provider/#inline-verticalanchors","title":"Inline <code>VerticalAnchors</code>","text":"<p>If none of the vanilla <code>VerticalAnchors</code> fit your needs, you can also inline your own <code>VerticalAnchor</code> via lambdas:</p> Example<pre><code>ConstantHeight.of { ctx -&gt; ctx.genDepth % ctx.minGenY }\n</code></pre>"},{"location":"addon/worldgen/types/number-provider/","title":"NumberProviders","text":"<p>Warning</p> <p>This worldgen page is still a work in progress. Some Json formats/code examples/features might be missing and will be added in the future.</p>"},{"location":"addon/worldgen/types/number-provider/#intprovider","title":"<code>IntProvider</code>","text":"<p>TODO - Check out the Minecraft Wiki in the meantime.</p>"},{"location":"addon/worldgen/types/number-provider/#floatprovider","title":"<code>FloatProvider</code>","text":"<p>TODO - Check out the Minecraft Wiki in the meantime.</p>"},{"location":"admin/configuration/","title":"Configuring Nova","text":"<p>All config files are located in under <code>plugins/Nova/configs/</code>. Every addon has its own subdirectory with its own config files.</p> <p>Most of the options in the configs are self-explanatory or explained using comments. The following section explains the more complex configuration options.</p>"},{"location":"admin/configuration/#items-menu","title":"Items Menu","text":"<p>To customize the items menu (accessible via <code>/nova items</code>), create a file named <code>item_categories.yml</code> in <code>plugins/Nova/configs/</code>.</p> item_categories.yml<pre><code>- icon: &lt;item id&gt; # (1)!\n  name: &lt;name&gt; # (2)!\n  items: # (3)!\n    - &lt;item id 1&gt;\n    - &lt;item id 2&gt;\n    ...\n- icon: &lt;item id&gt;\n...\n</code></pre> <ol> <li>The item type to use as the icon for the category.</li> <li>The name of the category, which will be used as the hover name of the icon.    In MiniMessage format.</li> <li>A list of items in the category.</li> </ol> Example configuration item_categories.yml<pre><code>- icon: machines:quarry\n  name: \"&lt;rainbow&gt;Example Category Name&lt;/rainbow&gt;\" \n  items:\n    - machines:quarry\n    - machines:pulverizer\n    - machines:electric_furnace\n- icon: minecraft:dirt\n  name: \"Dirts\"\n  items:\n    - minecraft:grass_block\n    - minecraft:dirt\n    - minecraft:dirt_path\n    - minecraft:coarse_dirt\n    - minecraft:rooted_dirt\n</code></pre> <p></p>"},{"location":"admin/configuration/#tile-entity-limits","title":"Tile-Entity limits","text":"<p>With tile-entity limits, you can create restrictions on which tile-entities players are allowed to place. Tile-Entity limits are configured in the <code>performance</code> &gt; <code>tile_entity_limits</code> section. Players with the permission <code>nova.misc.bypassTileEntityLimits</code> will be able to bypass these restrictions.</p> <p>There are 6 different limiters. You can choose one or combine multiple:</p> Name Description type Prevent placing a specific tile-entity. world Prevent placing tile entities in specific worlds. type_world Prevent placing specific tile-entities in specific worlds. amount Set a maximum amount of tile-entities of a type for each player. amount_per_world Set a maximum amount of tile-entities of a type for each player for each world. amount_per_chunk Set a maximum amount of tile-entities of a type for each player for each chunk. <p>Example configs:</p> typeworldtype_worldamountamount_per_worldamount_per_chunk <pre><code># This example config prevents players from placing the quarry.\nperformance:\n  tile_entity_limits:\n    type:\n      - machines:quarry\n</code></pre> <pre><code># This example config prevents players from placing tile-entities in the nether and end dimension.\nperformance:\n  tile_entity_limits:\n    world:\n      - world_nether\n      - world_the_end\n</code></pre> <pre><code># This example config prevents players from placing quarries in the overworld and pulverizers in the nether.\nperformance:\n  tile_entity_limits:\n    type_world:\n      world:\n        - machines:quarry\n      world_nether:\n        - machines:pulverizer\n</code></pre> <pre><code># This example config sets a maximum amount of one quarry and 50 cables of each type for every player.\nperformance:\n  tile_entity_limits:\n    amount:\n      '*': 100 # Not mandatory, but this option would limit the total amount of tile-entities to 100 per player.\n      machines:quarry: 1\n      logistics:basic_cable: 50\n      logistics:advanced_cable: 50\n      logistics:elite_cable: 50\n      logistics:ultimate_cable: 50\n</code></pre> <pre><code># This example config sets a maximum of one quarry per player per world.\nperformance:\n  tile_entity_limits:\n    amount_per_world:\n      '*': 100 # Not mandatory, but this option would limit the total amount of tile-entities to 100 per player per world.\n      machines:quarry: 1\n</code></pre> <pre><code># This example config sets a maximum of one quarry per player per world.\nperformance:\n  tile_entity_limits:\n    amount_per_chunk:\n      '*': 5 # Not mandatory, but this option would limit the total amount of tile-entities to 5 per player per chunk.\n      machines:quarry: 1\n</code></pre>"},{"location":"admin/configuration/#upgrade-values-simple-upgrades-addon","title":"Upgrade values (Simple-Upgrades addon)","text":"<p>Every addon can register its own upgrade types. As a server administrator, you can configure these values in the <code>plugin/Nova/configs/&lt;addon name&gt;/upgrade_values.yml</code> file.</p> <p>The config of the <code>simple_upgrades</code> addon looks like this: <pre><code>speed: [ 1.0, 1.91, 2.82, 3.73, 4.64, 5.55, 6.46, 7.37, 8.28, 9.19, 10.0 ]\nefficiency: [ 1.0, 1.25, 1.75, 2.75, 3.75, 4.75, 5.75, 6.75, 7.75, 8.75, 9.75 ]\nenergy: [ 1.0, 1.9, 2.8, 3.7, 4.6, 5.5, 6.4, 7.3, 8.2, 9.1, 10.0 ]\nfluid: [ 1.0, 1.9, 2.8, 3.7, 4.6, 5.5, 6.4, 7.3, 8.2, 9.1, 10.0 ]\nrange: [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 ]\n</code></pre></p> <p>The amount of values in the arrays specifies the amount of upgrades that can be added, the numbers themselves are the modifiers. Depending on the type of upgrade, these values might be a multipliers or in the case of the range upgrade, are just added on top of the default max range.</p> <p>The upgrade values can also be changed for specific tile-entities by adding a <code>upgrade_values</code> section to the config of that tile-entity. For example, the default limit of range upgrades for the Pump from the Machines addon is changed to 30 this way: <pre><code>upgrade_values:\n  range: [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30 ]\n</code></pre></p>"},{"location":"admin/configuration/#attribute-modifiers","title":"Attribute Modifiers","text":"<p>Every item configuration file can have an <code>attribute_modifiers</code> section.</p> Structure of the attribute_modifiers section<pre><code>attribute_modifiers:\n  &lt;equipment_slot&gt;: # (1)!\n  - attribute: &lt;attribute&gt; # (2)!\n    operation: &lt;operation&gt; # (3)!\n    value: &lt;value&gt; # (4)!\n</code></pre> <ol> <li>The equipment slot group that this item needs to be in for the attribute modifier to apply.     Possible values: <code>any</code>, <code>mainhand</code>, <code>offhand</code>, <code>hand</code>, <code>feet</code>, <code>legs</code>, <code>chest</code>, <code>head</code>, <code>armor</code>, <code>body</code></li> <li>The attribute to modify.      You can find a list of all available attributes on the Minecraft Wiki</li> <li>The operation to perform.     Possible operations: <code>add_value</code>, <code>add_multiplied_base</code>, <code>add_multiplied_total</code></li> <li>The value to modify the attribute with.</li> </ol> Example configuration <pre><code># The following configuration increases the player's attack damage by 5 if the item is held in the main hand\n# and increases the movement speed by 10% for both the main hand and off hand.\n\nattribute_modifiers:\n  mainhand:\n  - attribute: attack_damage\n    operation: add_value\n    value: 5.0\n  offhand:\n  - attribute: movement_speed\n    operation: add_multiplied_base\n    value: 0.1\n  - attribute: movement_speed\n    operation: add_multiplied_base\n    value: 0.1\n</code></pre> <p></p>"},{"location":"admin/configuration/#resource-filters","title":"Resource Filters","text":"<p>Resource filters allow you to exclude certain files from the resource pack. They are configured in the main config under <code>resource_pack</code> &gt; <code>generation</code> &gt; <code>resource_filters</code>.</p> <pre><code>resource_pack:\n  generation:\n    resource_filters:\n    - stage: \"\" # (1)!\n      type: \"\" # (2)!\n      pattern_type: \"\" # (3)!\n      filter: \"\" # (4)!\n      directory: \"\" # (5)!\n</code></pre> <ol> <li>The stage at which the filter should be applied. Can be <code>asset_pack</code> or <code>resource_pack</code>.</li> <li>The type of the filter. Can be <code>whitelist</code> or <code>blacklist</code>.</li> <li>The pattern type of the <code>filter</code> field. Can be <code>regex</code> or <code>wildcard</code>.    You can test your regex pattern on RegExr or similar sites.</li> <li>The filter pattern to match against. The <code>pattern_type</code> field determines how the pattern is interpreted.</li> <li>(Optional) The directory to apply the filter to. Relative to the <code>assets</code> directory.</li> </ol> Examples <p>Excluding all langauge files except <code>en_us.json</code> and <code>de_de.json</code>:</p> config.yml: resource_pack &gt; generation &gt; resource_filters<pre><code>- stage: resource_pack\n  type: whitelist\n  pattern_type: regex\n  filter: minecraft\\/lang\\/(en_us|de_de).json\n  directory: minecraft/lang/\n</code></pre> <p>Excluding an entire directory:</p> config.yml: resource_pack &gt; generation &gt; resource_filters<pre><code>- stage: resource_pack\n  type: blacklist\n  pattern_type: regex\n  filter: .*\n  directory: path/to/directory/\n</code></pre> <p>Excluding all png files:</p> config.yml: resource_pack &gt; generation &gt; resource_filters<pre><code>- stage: resource_pack\n  type: blacklist\n  pattern_type: regex\n  filter: *.png\n</code></pre>"},{"location":"admin/configuration/#waila-positioning","title":"WAILA Positioning","text":"<p>If you want to change the vertical position of the WAILA overlay, you can do so by defining which boss bars should be above or below it. This is done by defining matchers in <code>waila</code> &gt; <code>positioning</code> &gt; <code>above</code> (defines the boss bars that should be below WAILA) and <code>waila</code> &gt; <code>positioning</code> &gt; <code>below</code> (defines the boss bars that should be above WAILA).</p> <p>There are five different types of matchers available:</p> Type Description <code>origin</code> Matches against the origin of the boss bar. (Either <code>minecraft</code> or a plugin name.) <code>text</code> Matches against the text of the boss bar using either a regex or wildcard. <code>overlay</code> Matches against the overlay id of a boss bar overlay from a different Nova addon. <code>uuid</code> Matches against the UUID of the boss bar. <code>index</code> Matches against the index of the boss bar (before Nova rearranges them), with the uppermost boss bar starting at index 0. OriginTextOverlayUUIDIndex <pre><code>waila:\n  positioning:\n    above:\n    - type: origin\n      origin: &lt;origin&gt; # (1)!\n</code></pre> <ol> <li>The origin to match against. Can be <code>minecraft</code> or a plugin name.</li> </ol> WildcardRegex <pre><code>waila:\n  positioning:\n    above:\n    - type: text\n      wildcard: &lt;pattern&gt; # (1)!\n</code></pre> <ol> <li>The wildcard pattern to match against.    Use <code>*</code> to match any number of characters and <code>?</code> to match a single character.</li> </ol> <pre><code>waila:\n  positioning:\n    above:\n    - type: text\n      regex: &lt;pattern&gt; # (1)!\n</code></pre> <ol> <li>The regex pattern to match against.    You can try out your regex pattern on RegExr.</li> </ol> <pre><code>waila:\n  positioning:\n    above:\n    - type: overlay\n      overlay: &lt;overlay id&gt; # (1)!\n</code></pre> <ol> <li>The overlay id of a boss bar overlay from a different Nova addon.    For example, WAILA's overlay id is <code>nova:waila</code>.</li> </ol> <pre><code>waila:\n  positioning:\n    above:\n    - type: uuid\n      uuid: &lt;uuid&gt; # (1)!\n</code></pre> <ol> <li>The UUID to match against.</li> </ol> <pre><code>waila:\n  positioning:\n    above:\n    - type: index\n      index: &lt;index&gt; # (1)!\n</code></pre> <ol> <li>The index of the boss bar. Starts at 0, from the top down.</li> </ol> Example configuration <p>This example configuration places WAILA above all vanilla boss bars, but below all boss bars registered by <code>PluginA</code> and <code>PluginB</code>.</p> <pre><code>waila:\n  positioning:\n    above:\n    - type: origin\n      origin: minecraft\n    below:\n    - type: origin\n      origin: PluginA\n    - type: origin\n      origin: PluginB\n</code></pre>"},{"location":"admin/faq/","title":"FAQ","text":""},{"location":"admin/faq/#nova","title":"Nova","text":"How do I get the resource pack? <p>Please follow the tutorial on the setup page.</p> Which Minecraft versions are supported by Nova? Is there multi-version support? <p>The goal for Nova is to always target the latest version of Minecraft. There is no multi-version support. If the latest version of Nova does not support the latest Minecraft version yet, please be patient while we work on updating it.</p> Can I use Nova with Bedrock bridges like Geyser? <p>No, Nova is not compatible with any Bedrock bridges.</p> Where can I report bugs? <p>Please report all bugs on GitHub.</p> Where can I find the crafting recipes? <p>All items from Nova and their crafting recipes can be viewed by using <code>/nova items</code> and are also present in the vanilla crafting book (the green book in the crafting table). Additionally, recipes can also be viewed directly by using <code>/nvrecipe</code> and <code>/nvusage</code>.</p> My items don't have textures / look like shulker shells. <p>Please follow the tutorial on the setup page and make sure that you've set up the resource pack properly.</p> Is Nova compatible with Plugin X? <p>All compatible plugins and setup requirements are listed on the compatibility page.</p>"},{"location":"admin/faq/#official-addons","title":"Official Addons","text":""},{"location":"admin/faq/#logistics","title":"Logistics","text":"How does the Item Filter work? <p>Right click in the air to set the items, then put the item filter in a cable or vacuum chest.</p>"},{"location":"admin/faq/#machines","title":"Machines","text":"How do I get Star Shards? <p>You can find them in chests (like mineshafts, dungeons, desert temples...) or as star shards ore above <code>y = 120</code>.</p>"},{"location":"admin/setup/","title":"Setting up Nova","text":"<p>Before installing Nova, please make sure that you're running a supported server software.</p>"},{"location":"admin/setup/#step-1-installing-nova-and-addons","title":"Step 1: Installing Nova and addons","text":"<ul> <li>Like any other plugin, the Nova plugin jar file downloaded from Hangar, Modrinth, GitHub or our Discord just needs to be put in the <code>plugins/</code> folder of your server.</li> <li>Since 0.18, addons are loaded as plugins. Therefore, you can also just put them into the <code>plugins/</code> folder.<ul> <li>Some addons might require other addons in order to work.     If this is the case, an error in the console will notify you of the missing addons: <code>Failed to initialize &lt;Name of the Addon&gt;: Missing addon(s): &lt;Name(s) of the required addon(s) that are missing&gt;</code></li> </ul> </li> <li>Start your server and wait until Nova is done loading. (Indicated by the message in the console <code>[Nova] Done loading</code>). This creates config files and directories which you will need to access in the following steps.</li> <li>Stop your server.</li> </ul> <p>The new resource pack containing the addon assets will be automatically generated, but it won't be sent to players yet. Please follow Step 2 to configure resource pack hosting.</p>"},{"location":"admin/setup/#step-2-configure-resource-pack-hosting","title":"Step 2: Configure resource pack hosting","text":"<p>Due to the way server resource packs work, it is required to upload them to a web server first before they can be sent to players. This can be done either automatically or manually:</p> Automatic resource pack hosting (recommended)Manual resource pack hosting <p>The auto uploader automatically uploads the  resource pack after it changes. You can configure it in the main config file <code>plugins/Nova/configs/config.yml</code> under <code>resource_pack</code> &gt; <code>auto_upload</code>.</p> <p>Available Upload Services</p> Self-hostedCustom Multipart RequestAmazon S3 <p>If you're able to open a port on your server, this option will make the most sense for you. Nova will automatically start a lightweight web server from which the resource pack can be downloaded.</p> <p>Example config:</p> plugins/Nova/configs/config.yml<pre><code>resource_pack:\n  auto_upload:\n    enabled: true\n    service: self_host\n    port: 12345 # The port on which the web server will be running, needs to be open to the Internet.\n</code></pre> <p><code>host</code> parameter</p> <p>You can also set the host of your server using the <code>host</code> parameter. If it is not set, the public ip address of your server gets used. If you are on a local server, you will need to set <code>host: 127.0.0.1</code></p> <p><code>append_port</code> parameter</p> <p>When setting a <code>host</code>, Nova assumes that the configured port does not need to be appened after the host in the download URL. If this is not the case, set <code>append_port: true</code>.</p> <p>For more advanced users, Nova can also perform a multipart request to a server of your choice and parse the response using a regex.</p> <p>Example: upload php script</p> plugins/Nova/configs/config.yml<pre><code>resource_pack:\n  auto_upload:\n    enabled: true\n    service: custom_multi_part\n    url: https://example.com/upload.php\n    filePartName: pack\n    extraParams:\n      key: \"\" # This key also needs to be set in the php script mentioned above\n</code></pre> <p>If you are using Amazon S3, you can use the S3 service to upload the resource pack. You have to expose your S3  bucket to the Internet yourself.</p> <p>Example config:</p> plugins/Nova/configs/config.yml<pre><code>resource_pack:\n  auto_upload:\n    enabled: true\n    service: amazon_s3\n    endpoint: s3.amazonaws.com # The endpoint of your S3 service\n    region: eu-central-1 # The region of your S3 endpoint\n    bucket: examplebucket # The name of your S3 bucket\n    key_id: \"\" # Your S3 key id\n    key_secret: \"\" # Your S3 key secret\n    force_path_style: false # Forces path style URLs (Defaults to false)\n</code></pre> <p>For manual resource pack hosting, upload the resource pack found under <code>plugins/Nova/resource_pack/ResourcePack.zip</code> to a file uploader of your choice. Then set the url to download the resource pack in the main config file <code>plugins/Nova/configs/config.yml</code> under <code>resource_pack</code> &gt; <code>url</code>:</p> plugins/Nova/configs/config.yml<pre><code>resource_pack:\n  url: https://example.com/resource_pack.zip\n</code></pre> <p>URL needs to be a direct download link</p> <p>Minecraft requires the server resource pack to be a direct download link, meaning it cannot have any redirects or visual elements (like buttons, text, etc.) on the page. Direct download links often include the file name and extension in the url, so for resource packs, they would end with <code>.zip</code>.</p> <p>Prefer using an auto-upload service instead</p> <p>You will need to manually re-upload the resource pack every time it is regenerated, which is when you update Nova, any of its addons or when you change config values that affect resource pack generation. This is why you should prefer using an auto-upload service instead.</p>"},{"location":"admin/setup/#optional-resource-pack-merging","title":"(optional) resource pack merging","text":"<p>This step is only required if your server is already using a custom resource pack.</p> <p>In the past, there could be only one server resource pack. While this is no longer the case, resource pack merging is still important as Nova uses it to analyze the existing resource pack and adjusts its own data accordingly to prevent conflicts. Therefore, it is NOT possible to manually merge resource packs, and it is also NOT possible to use merging services from other plugins.</p> <p>You can define \"base packs\", which are resource packs that Nova should merge, in two ways:  </p> With ConfigWith Folder <ol> <li>Make sure to turn off the resource pack prompt in the config of the plugin providing it.</li> <li> <p>Link to the resource pack directory or zip file in the Nova config under <code>resource_pack</code> &gt; <code>generation</code> &gt; <code>base_packs</code>.</p> plugins/Nova/configs/config.yml<pre><code>resource_pack:\n  generation:\n    base_packs:\n      - plugins/ItemsAdder/output/generated.zip\n</code></pre> </li> <li> <p>Make sure that the listed base pack has been properly generated. (For example, ItemsAdder requires running <code>/iazip</code> to generate its resource pack.)</p> </li> <li>Reload the config using <code>/nova reload configs</code> or restart the server.</li> <li>Regenerate the resource pack using <code>/nova resourcePack create</code>.</li> </ol> <ol> <li>Make sure to turn off the resource pack prompt in the config of the plugin providing it.</li> <li>Copy the resource pack directory or zip file to <code>plugins/Nova/resource_pack/base_packs/</code>.</li> <li>Regenerate the resource pack using <code>/nova resourcePack create</code>.</li> </ol> <p>You can add as many base packs as you want.</p>"},{"location":"admin/compatibility/","title":"Server Software & third-party Plugins","text":""},{"location":"admin/compatibility/#compatible-server-software","title":"Compatible server software","text":"<p>Nova is a paper plugin and needs to be run on a paper server or paper fork. Officially supported are:</p> <ul> <li> Paper (recommended)</li> <li> Purpur</li> <li> Pufferfish</li> </ul> <p>Any other server software may or may not work properly with Nova.  </p> <p>We're planning to add support for the following server software in the future:</p> <ul> <li>Folia</li> </ul>"},{"location":"admin/compatibility/#compatibility-with-other-plugins","title":"Compatibility with other plugins","text":""},{"location":"admin/compatibility/#custom-item-plugins","title":"Custom Item Plugins","text":"<ul> <li>ItemsAdder</li> <li>Nexo | Known Issues</li> <li>MMOItems</li> </ul> <p>Warning</p> <p>Most of these plugins require resource pack merging.</p>"},{"location":"admin/compatibility/#world-protection-plugins","title":"World Protection Plugins","text":"<p>The following protection plugins are supported out of the box by Nova, but plugin developers may also add support on their end using the API.</p> <ul> <li> WorldGuard</li> <li> GriefPrevention</li> <li> PlotSquared</li> <li> Towny</li> <li> ProtectionStones</li> <li> QuickShop</li> <li> Residence</li> </ul>"},{"location":"admin/compatibility/#incompatible-plugins","title":"Incompatible Plugins","text":"<p>The following plugins cannot be used with Nova:</p> <ul> <li>FastAsyncWorldEdit - Please consider using normal WorldEdit instead.</li> </ul>"},{"location":"admin/compatibility/itemsadder/","title":"ItemsAdder","text":""},{"location":"admin/compatibility/itemsadder/#adding-compatibility-with-itemsadder","title":"Adding compatibility with ItemsAdder","text":"<p>To make ItemsAdder and Nova work together, you need to follow these steps:</p> <ol> <li>Change the following values in ItemsAdder's <code>config.yml</code>:<ul> <li>Set <code>resource-pack</code> &gt; <code>hosting</code> &gt; <code>no-host</code> &gt; <code>enabled</code> to <code>true</code> (all other options under <code>hosting</code> must be <code>false</code>).</li> <li>Under <code>resource-pack</code> &gt; <code>zip</code> &gt; <code>protect-file-from-unzip</code> set both <code>protection_1</code> and <code>protection_2</code> to <code>false</code>.</li> </ul> </li> <li>Add the ItemsAdder resource pack zip file as a base pack in Nova's main config.</li> <li>Regenerate Nova's resource pack with <code>/nova resourcePack create</code> (make sure that you've run <code>/iazip</code> before and the resource pack zip exists)</li> </ol>"},{"location":"admin/compatibility/itemsadder/#adding-new-assets-to-itemsadder","title":"Adding new assets to ItemsAdder","text":"<p>After adding new assets to ItemsAdder and running <code>/iazip</code>, you will now also need to run <code>/nova resourcePack create</code>.</p>"},{"location":"admin/compatibility/nexo/","title":"Nexo","text":""},{"location":"admin/compatibility/nexo/#adding-compatibility-with-nexo","title":"Adding compatibility with Nexo","text":"<p>To make Nexo and Nova work together, you need to follow these steps:</p> <ol> <li>Disable Nexo's resource pack upload in its <code>settings.yml</code></li> <li>Add the Nexo resource pack zip file as a base pack in Nova's main config.</li> <li>Regenerate Nova's resource pack with <code>/nova resourcePack create</code></li> </ol>"},{"location":"admin/compatibility/nexo/#known-issues","title":"Known Issues","text":"<ul> <li>Duplicated and wrong block sounds</li> </ul>"},{"location":"admin/recipes/","title":"Customizing Recipes","text":"<p>In Nova, all recipes are customizable. You can find the recipe files under <code>plugins/Nova/recipes</code> You can change or delete existing recipes or just create completely new ones. If a recipe gets updated by us, we will only update it on your server if you haven't modified or deleted it.</p> <p>You can reload all recipes by running the command <code>/nova reload recipes</code>.</p>"},{"location":"admin/recipes/#item-formats","title":"Item Formats","text":"<p>There are multiple ways for you to specify an item in a recipe:</p>"},{"location":"admin/recipes/#custom-item-format","title":"Custom Item Format","text":"<p>This format allows you to use a custom item from Nova or any other supported plugin. For example <code>itemsadder:ruby</code> would also work here.</p> Custom Item Format<pre><code>\"machines:copper_gear\"\n</code></pre> <p>With items from Nova addons, it is also possible to use the <code>nova:</code> prefix instead of the addon's id. This will cause all items from different addons with that id to be accepted. For example, if multiple addons define a <code>copper_dust</code>, <code>machines:copper_dust</code> would only accept the copper dust from the Machines addon, but <code>nova:copper_dust</code> would allow any copper dust.</p>"},{"location":"admin/recipes/#complex-item-format","title":"Complex Item Format","text":"<p>This format lets you fully customize the required item. If you use this format, you won't be able to use custom namespaces like <code>nova:</code> As this checks the item exactly (only ignoring the item name), you might encounter some issues with enchantments and other data stored inside the item. This is the same format as in Minecraft's /give command. As it is in JSON, quotes need to be escaped.</p> Complex Item Format<pre><code>\"minecraft:potion{\\\"Potion\\\": \\\"minecraft:water\\\"}\"\n</code></pre>"},{"location":"admin/recipes/#item-recipe-fallbacks","title":"Item- &amp; Recipe Fallbacks","text":"<p>While this is more intended for developers, item- and recipe fallbacks can also be used by server administrators.</p> <p>What are item- and recipe fallbacks? Fallbacks can be used to define an item or recipe to fall back to when the item could not be found or the recipe could not be loaded. This is useful for addon developers as it allows them to use items from other addons in their crafting recipes without creating a hard dependency on that addon.</p>"},{"location":"admin/recipes/#item-fallbacks","title":"Item Fallbacks","text":"<p>Item fallbacks are defined by adding a semicolon after the item declaration, followed by a second declaration: Item Fallback<pre><code>\"nova:basic_fluid_tank; minecraft:bucket\"\n</code></pre> The recipe loader will first check if <code>nova:basic_fluid_tank</code> exists. If not, <code>minecraft:bucket</code> is used.</p>"},{"location":"admin/recipes/#recipe-fallbacks","title":"Recipe Fallbacks","text":"<p>In some cases, it makes sense to completely change the structure of a recipe if the items from another addon are missing. For that, just put multiple recipe objects into a json array:</p> Example Recipes NormalWith failSilently recipe.json<pre><code>[\n  {\n    \"result\": \"addon1:result_item\",\n    \"shape\": [\n      \"a  \",\n      \" a \",\n      \"  a\"\n    ],\n    \"ingredients\": {\n      \"a\": \"addon2:example_item\"\n    }\n  },\n  {\n    \"result\": \"addon1:result_item\",\n    \"shape\": [\n      \" a \",\n      \" a \",\n      \" a \"\n    ],\n    \"ingredients\": {\n      \"a\": \"addon1:fallback_item\"\n    }\n  }\n]\n</code></pre> <p>Info</p> <p>If required, it is also possible to use item fallbacks inside of recipe fallbacks.</p> <p>If you don't want any exceptions in the console if none of the fallbacks could be loaded, you can set the <code>failSilently</code> boolean to <code>true</code>.</p> recipe.json<pre><code>{\n  \"failSilently\": true,\n  \"recipes\": [\n    {\n      \"result\": \"addon1:result_item\",\n      \"shape\": [\n        \"a  \",\n        \" a \",\n        \"  a\"\n      ],\n      \"ingredients\": {\n        \"a\": \"addon2:example_item\"\n      }\n    },\n    {\n      \"result\": \"addon1:result_item\",\n      \"shape\": [\n        \" a \",\n        \" a \",\n        \" a \"\n      ],\n      \"ingredients\": {\n        \"a\": \"addon1:fallback_item\"\n      }\n    }\n  ]\n}\n</code></pre> <p>Info</p> <p>If required, it is also possible to use item fallbacks inside of recipe fallbacks.</p>"},{"location":"admin/recipes/machines/","title":"Recipe Types from the Machines Addon","text":""},{"location":"admin/recipes/machines/#pulverizer-recipes","title":"Pulverizer Recipes","text":"<p>This is an example recipe for pulverizing iron ore into iron dust:</p> iron_ore_to_iron_dust.json<pre><code>{\n  \"input\": [\n    \"minecraft:iron_ore\",\n    \"minecraft:deepslate_iron_ore\"\n  ],\n  \"result\": \"machines:iron_dust\",\n  \"amount\": 2,\n  \"time\": 200\n}\n</code></pre>"},{"location":"admin/recipes/machines/#mechanical-press-recipes","title":"Mechanical Press Recipes","text":"<p>Recipes for the mechanical press are grouped in the sub-folders <code>gear/</code> and <code>plate/</code> Both use the same syntax. This is an example recipe for pressing an iron plate:</p> iron_ingot_to_iron_plate.json<pre><code>{\n  \"input\": \"minecraft:iron_ingot\",\n  \"result\": \"machines:iron_plate\",\n  \"time\": 200\n}\n</code></pre> <p>Multiple Choices for Ingredients</p> <p>If you want to give players multiple item choices for a single ingredient, you can specify an array of strings instead of a single string for the input.</p>"},{"location":"admin/recipes/machines/#fluid-infuser-recipes","title":"Fluid Infuser Recipes","text":"<p>The Fluid Infuser can be used in two modes: Inserting fluids into an item or extract fluids from an item. This is an example recipe for inserting water into a bucket to create a water bucket:</p> bucket_to_water_bucket.json<pre><code>{\n  \"mode\": \"INSERT\", // (1)!\n  \"fluid_type\": \"WATER\", // (2)!\n  \"fluid_amount\": 1000,\n  \"input\": \"minecraft:bucket\",\n  \"result\": \"minecraft:water_bucket\",\n  \"time\": 100\n}\n</code></pre> <ol> <li>The mode specifies if this should be a recipe for inserting (<code>INSERT</code>) or extracting (<code>EXTRACT</code>) fluids.</li> <li>Currently, there are only <code>WATER</code> and <code>LAVA</code>. Custom fluids from other plugins are not supported.</li> </ol> <p>This is an example recipe for extract water from a water bottle to create an empty bottle:</p> potion_to_glass_bottle.json<pre><code>{\n  \"mode\": \"EXTRACT\",\n  \"fluid_type\": \"WATER\",\n  \"fluid_amount\": 300,\n  \"input\": \"minecraft:potion{\\\"Potion\\\": \\\"minecraft:water\\\"}\",\n  \"result\": \"minecraft:glass_bottle\",\n  \"time\": 30\n}\n</code></pre> <p>Custom Item Format</p> <p>As a water bottle is not its own item, a Complex Item Format is required here.</p>"},{"location":"admin/recipes/machines/#electric-brewing-stand-recipes","title":"Electric Brewing Stand Recipes","text":"<p>Using these recipes, you can configure which potion types can be created using the electric brewing stand. You're also able to configure their ingredients, as well as multipliers for duration and amplifier level and the max amount of these levels.</p> <p>This recipe would add the luck effect type to the electric brewing stand:</p> luck.json<pre><code>{\n  \"result\": \"minecraft:luck\",\n  \"default_time\": 1800, // (1)!\n  \"redstone_multiplier\": 2, // (2)!\n  \"glowstone_multiplier\": 0.5, // (3)!\n  \"max_duration_level\": 5, // (4)!\n  \"max_amplifier_level\": 5, // (5)!\n  \"inputs\": [\n    \"minecraft:nether_wart\",\n    \"minecraft:grass_block\"\n  ]\n}\n</code></pre> <ol> <li>The default time a potion with this effect would have. In ticks, 20 ticks = 1s. This potion would have a default time of 1:30</li> <li>The time multiplier when a duration level (one redstone) is added. This means a luck potion with level two duration would last 3:00, level three 4:30 and so on.</li> <li>In Minecraft, when glowstone is added to a potion in order to increase the amplifier level, the duration is reduced. This is represented by this multiplier. A potion with an amplifier of level two would have a duration of 0:45, level three 0:11 and so on.</li> <li>The maximum allowed duration level for a potion of this effect. By default, you cannot create an effect with both an increased duration level and an increased amplifier level, but you are able to change this in the config file for the electric brewing stand.</li> <li>The maximum allowed amplifier level for a potion of this effect. By default, you cannot create an effect with both an increased duration level and an increased amplifier level, but you are able to change this in the config file for the electric brewing stand.</li> <li>In this recipe type, multiple item choices for one ingredient are not allowed.</li> </ol>"},{"location":"admin/recipes/vanilla/","title":"Vanilla Recipe Types","text":""},{"location":"admin/recipes/vanilla/#shaped-recipes","title":"Shaped Recipes","text":"<p>Directory: <code>shaped</code></p> <p>Shaped recipes are recipes for the Crafting Table that have to follow a specific structure. This is an example crafting recipe for the Advanced Cable:</p> advanced_cable.json<pre><code>{\n  \"result\": \"logistics:advanced_cable\",\n  \"amount\": 3, // (2)!\n  \"shape\": [ // (1)!\n    \"ggg\",\n    \"ccc\",\n    \"ggg\"\n  ],\n  \"ingredients\": {\n    \"g\": \"minecraft:glowstone_dust\",\n    \"c\": \"logistics:basic_cable\"\n  }\n}\n</code></pre> <ol> <li>The shape is the structure of the recipe. You can see that it resembles a crafting table. The letters you use here have to  also be present in the <code>ingredients</code> section. You can use a space if that slot should be empty.</li> <li>The amount of items that will be crafted, can be omitted for 1.</li> </ol> <p>Multiple Choices for Ingredients</p> <p>If you want to give players multiple item choices for a single ingredient, you can specify an array of strings instead of a single string for each ingredient.</p>"},{"location":"admin/recipes/vanilla/#shapeless-recipes","title":"Shapeless Recipes","text":"<p>Directory: <code>shapeless</code></p> <p>Shapeless recipes are recipes for the Crafting Table that do not follow a specific structure. This is an example recipe for the Basic Item Filter:</p> basic_item_filter.json<pre><code>{\n  \"result\": \"logistics:basic_item_filter\",\n  \"ingredients\": {\n    \"minecraft:hopper\": 1, // (1)!\n    \"minecraft:paper\": 1\n  }\n}\n</code></pre> <ol> <li>This number represents the amount of items that needs to be present in the crafting table.</li> </ol> <p>Like in shaped recipes, it is also possible to give multiple choices for a specific ingredient. The following recipe would allow players to either use paper or an iron plate to craft a Basic Item Filter.</p> basic_item_filter.json<pre><code>{\n  \"result\": \"logistics:basic_item_filter\",\n  \"ingredients\": [\n    {\n      \"item\": \"minecraft:hopper\",\n      \"amount\": 1\n    },\n    {\n      \"items\": [\n        \"nova:iron_plate\",\n        \"minecraft:paper\"\n      ],\n      \"amount\": 1\n    }\n  ]\n}\n</code></pre>"},{"location":"admin/recipes/vanilla/#furnace-recipes","title":"Furnace Recipes","text":"<p>Directories: <code>furance</code>, <code>blast_furnace</code>, <code>smoker</code>, <code>campfire</code></p> <p>This is an example recipe for smelting iron dust into iron ingots:</p> iron_dust_to_iron_ingot.json<pre><code>{\n  \"result\": \"minecraft:iron_ingot\",\n  \"input\": \"machines:iron_dust\",\n  \"experience\": 1.0,\n  \"time\": 100 // (1)!\n}\n</code></pre> <ol> <li>The time is in ticks. One second is 20 ticks.</li> </ol> <p>Multiple Choices for Ingredients</p> <p>If you want to give players multiple item choices for a single ingredient, you can specify an array of strings instead of a single string for the input.</p>"},{"location":"admin/recipes/vanilla/#stonecutter-recipes","title":"Stonecutter Recipes","text":"<p>Directory: <code>stonecutter</code></p> <p>This is an example recipe for the Stonecutter that allows players to craft three stone slabs from a stone block:</p> stone_to_slab.json<pre><code>{\n  \"result\": \"minecraft:stone_slab\",\n  \"input\": \"minecraft:stone\",\n  \"amount\": 3\n}\n</code></pre> <p>Multiple Choices for Ingredients</p> <p>If you want to give players multiple item choices for a single ingredient, you can specify an array of strings instead of a single string for the input.</p>"},{"location":"admin/recipes/vanilla/#smithing-transform-recipes","title":"Smithing Transform Recipes","text":"<p>Directory: <code>smithing_transform</code></p> <p>This is an example recipe for upgrading a diamond hammer to a netherite hammer:</p> diamond_to_netherite_helmet.json<pre><code>{\n  \"template\": \"minecraft:netherite_upgrade_smithing_template\",\n  \"base\": \"vanilla_hammers:diamond_hammer\",\n  \"addition\": \"minecraft:netherite_ingot\",\n  \"result\": \"vanilla_hammers:netherite_hammer\"\n}\n</code></pre> <p>Multiple Choices for Ingredients</p> <p>If you want to give players multiple item choices for a single ingredient, you can specify an array of strings instead of a single string for the input.</p>"},{"location":"api/","title":"Getting Started","text":"<p>To use the Nova API you first have to add the xenondevs maven repository to your build configuration.</p> MavenGradle GroovyGradle Kotlin <pre><code>&lt;repository&gt;\n    &lt;id&gt;xenondevs&lt;/id&gt;\n    &lt;url&gt;https://repo.xenondevs.xyz/releases&lt;/url&gt;\n&lt;/repository&gt;\n</code></pre> <pre><code>maven {\n    url 'https://repo.xenondevs.xyz/releases'\n}\n</code></pre> <pre><code>maven(\"https://repo.xenondevs.xyz/releases\")\n</code></pre> <p>Now you can add the API dependency to your build configuration:</p> MavenGradle GroovyGradle Kotlin <pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;xyz.xenondevs.nova&lt;/groupId&gt;\n    &lt;artifactId&gt;nova-api&lt;/artifactId&gt;\n    &lt;version&gt;VERSION&lt;/version&gt;\n    &lt;scope&gt;provided&lt;/scope&gt;\n&lt;/dependency&gt;\n</code></pre> <pre><code>implementation \"xyz.xenondevs.nova:nova-api:VERSION\"\n</code></pre> <pre><code>implementation(\"xyz.xenondevs.nova:nova-api:VERSION\")\n</code></pre> <p>To get the Nova instance you can use the <code>Nova</code> class:</p> KotlinJava <pre><code>val nova = Nova // (1)!\n</code></pre> <ol> <li><code>Nova</code> is an interface but the companion object delegates to <code>Bukkit.getPluginManager().getPlugin(\"Nova\") as Nova</code>.</li> </ol> <pre><code>Nova nova = Nova.getNova();\n</code></pre> <p>You can use this instance to access everything else:</p> <ul> <li>Adding custom protection checks</li> <li>Getting <code>NovaItems</code></li> <li>Getting <code>NovaBlocks</code></li> <li>Working with <code>NovaBlocks</code> and <code>NovaBlockStates</code></li> <li>Working with <code>TileEntities</code></li> <li>Toggling the WAILA overlay</li> </ul>"},{"location":"api/blocks/blockmanager/","title":"BlockManager","text":"<p>The BlockManager allows you to interact with Nova's blocks. You can place/destroy/get drops/etc.</p> <p>You can get the <code>BlockManager</code> using the previously retrieved Nova instance.</p> KotlinJava <pre><code>val blockManager = Nova.blockManager\n</code></pre> <pre><code>BlockManager blockManager = nova.getBlockManager(); // (1)!\n</code></pre> <ol> <li>\"nova\" is the previously retrieved Nova instance, preferably saved in a field/variable.You can also call <code>Nova.getNova().getBlockManager()</code></li> </ol>"},{"location":"api/blocks/blockmanager/#getting-a-blockstate","title":"Getting a BlockState","text":"<p>The BlockManager also allows you to get a BlockState at a specific location.</p> KotlinJava <pre><code>val blockState = blockManager.getBlock(location) ?: return\n</code></pre> <pre><code>NovaBlockState blockState = blockManager.getBlock(location);\nif (blockState == null)\n    return;\n</code></pre> <p>You can also check if a block at a specific location is a Nova block via <code>BlockManager.hasBlock(Location)</code></p>"},{"location":"api/blocks/blockmanager/#block-type","title":"Block Type","text":"<p><code>NovaBlock</code> is a block type, similar to <code>Material</code> in Bukkit, except that it is only for blocks. To retrieve the block type of block at a specific location, you can do the following:</p> KotlinJava <pre><code>val blockState = blockManager.getBlock(location) ?: return\nval block = blockState.block\n</code></pre> <pre><code>NovaBlockState blockState = blockManager.getBlock(location);\nif (blockState == null)\n    return;\nNovaBlock block = blockState.getBlock();\n</code></pre>"},{"location":"api/blocks/blockmanager/#tile-entity","title":"Tile Entity","text":"<p>TileEntities use the <code>NovaTileEntityState</code> class via which you can get the TileEntity instance of the block.</p> KotlinJava <pre><code>val blockState = blockManager.getBlock(location) ?: return\nif (blockState is NovaTileEntityState) {\n    val tileEntity = blockState.tileEntity\n}\n</code></pre> <pre><code>NovaBlockState blockState = blockManager.getBlock(location);\nif (blockState == null)\n    return;\nif (blockState instanceof NovaTileEntityState tileEntityState) {\n    TileEntity tileEntity = tileEntityState.getTileEntity();\n}\n</code></pre>"},{"location":"api/blocks/blockmanager/#placing-a-block","title":"Placing a block","text":"<p>You can also place a nova block at a specific location by using a <code>NovaBlock</code>.</p> KotlinJava <pre><code>val block = blockRegistry.get(\"machines:pulverizer\")\nblockManager.placeBlock(\n    location, // (1)!\n    block, // (2)!\n    player, // (3)!\n    true // (4)!\n)\n</code></pre> <ol> <li>The location at which to place the block.</li> <li>The block type to place.</li> <li>The source of the block placement. This doesn't have to be a player, it can also be a tile-entity or similar.</li> <li>Whether to play a sound when the block is placed.</li> </ol> <pre><code>NovaBlock block = blockRegistry.get(\"machines:pulverizer\");\nblockManager.placeBlock(\n    location, // (1)!\n    block, // (2)!\n    player, // (3)!\n    true // (4)!\n);\n</code></pre> <ol> <li>The location at which to place the block.</li> <li>The block type to place.</li> <li>The source of the block placement. This doesn't have to be a player, it can also be a tile-entity or similar.</li> <li>Whether to play a sound when the block is placed.</li> </ol> <p>Note</p> <p>The <code>BlockManager.placeBlock</code> function has a few overrides requiring less arguments.</p>"},{"location":"api/blocks/blockmanager/#getting-the-drops-of-a-block","title":"Getting the drops of a block","text":"<p>If you want to get the drops of a block, you can use the <code>BlockManager.getDrops</code> function. Again, there are a few overrides requiring less arguments.</p> <p>Warning</p> <p>This function will return <code>null</code> if there is no nova block at the provided location.</p> KotlinJava <pre><code>val drops = blockManager.getDrops(\n    location, // (1)!\n    player, // (2)!\n    tool // (3)!\n)\n</code></pre> <ol> <li>The location of the block.</li> <li>The source, again, this doesn't have to be a player, it can also be a tile-entity or similar.</li> <li>The tool used to break the block.</li> </ol> <pre><code>List&lt;ItemStack&gt; drops = blockManager.getDrops(\n    location, // (1)!\n    player, // (2)!\n    tool // (3)!\n);\n</code></pre> <ol> <li>The location of the block.</li> <li>The source, again, this doesn't have to be a player, it can also be a tile-entity or similar.</li> <li>The tool used to break the block.</li> </ol>"},{"location":"api/blocks/blockmanager/#removing-a-block","title":"Removing a block","text":"<p>You can remove a block at a specific location by using the <code>BlockManager.removeBlock</code> function. The function will return a <code>boolean</code> whether there was a block at the provided location and whether it was removed successfully.</p> KotlinJava <pre><code>blockManager.removeBlock(\n    location, // (1)!\n    player, // (2)!\n    true, // (3)!\n    true // (4)!\n)\n</code></pre> <ol> <li>The location of the block.</li> <li>The source, again, this doesn't have to be a player, it can also be a tile-entity or similar.</li> <li>Whether to play a sound when the block is removed.</li> <li>Whether break particles should be displayed.</li> </ol> <pre><code>blockManager.removeBlock(\n    location, // (1)!\n    player, // (2)!\n    true, // (3)!\n    true // (4)!\n);\n</code></pre> <ol> <li>The location of the block.</li> <li>The source, again, this doesn't have to be a player, it can also be a tile-entity or similar.</li> <li>Whether to play a sound when the block is removed.</li> <li>Whether break particles should be displayed.</li> </ol>"},{"location":"api/blocks/blockregistry/","title":"Block Registry","text":"<p>The block registry contains all registered block types.</p> <p>You can get the <code>BlockRegistry</code> using the previously retrieved Nova instance.</p> KotlinJava <pre><code>val blockRegistry = Nova.blockRegistry\n</code></pre> <pre><code>BlockRegistry blockRegistry = Nova.getNova().getBlockRegistry();\n</code></pre> <p>After that, you can retrieve a block type by its id:</p> KotlinJava <pre><code>val block = blockRegistry.getBlock(\"machines:pulverizer\")\n</code></pre> <pre><code>NovaBlock block = blockRegistry.getBlock(\"machines:pulverizer\");\n</code></pre>"},{"location":"api/events/novaloaddataevent/","title":"NovaLoadDataEvent","text":"<p>The <code>NovaLoadDataEvent</code> is called when Nova finished initializing on server startup/reload.</p>"},{"location":"api/events/tileentitybreakblockevent/","title":"TileEntityBreakBlockEvent","text":"<p>The <code>TileEntityBreakBlockEvent</code> is called when a tile-entity breaks a block. It can be used to manipulate the drops of  the broken block.</p> <p>Warning</p> <p>This event can't be cancelled. Please see ProtectionIntegration.</p>"},{"location":"api/events/tileentitybreakblockevent/#properties","title":"Properties","text":""},{"location":"api/events/tileentitybreakblockevent/#tileentity","title":"tileEntity","text":"<p>The <code>TileEntity</code> that broke the block.</p>"},{"location":"api/events/tileentitybreakblockevent/#block","title":"block","text":"<p>The <code>Block</code> that was broken.</p>"},{"location":"api/events/tileentitybreakblockevent/#drops","title":"drops","text":"<p>A <code>MutableList</code> of <code>ItemStacks</code> that will be added to the tile-entities inventory (or dropped on the ground if the inventory is full). This list can be modified to change the drops.</p>"},{"location":"api/events/tileentitybreakblockevent/#examples","title":"Examples","text":""},{"location":"api/events/tileentitybreakblockevent/#flint-from-dirt","title":"Flint from dirt","text":"<p>Adding a 25% chance to get 1 flint when breaking a dirt block with a tile-entity.</p> KotlinJava <pre><code>@EventHandler\nfun handleBlockBreak(event: TileEntityBreakBlockEvent) {\n    if (event.block.type == Material.DIRT\n        &amp;&amp; Random.nextInt(0, 100) &lt;= 25  // 25% chance\n    ) {\n        event.drops.add(ItemStack(Material.FLINT, 1)) // Add a flint to the drops\n    }\n}\n</code></pre> <pre><code>@EventHandler\npublic void handleBlockBreak(TileEntityBreakBlockEvent event) {\n    if (event.getBlock().getType() == Material.DIRT\n        &amp;&amp; random.nextInt(100) &lt;= 25 // 25% chance\n    ) {\n        List&lt;ItemStack&gt; drops = event.getDrops();\n        drops.add(new ItemStack(Material.FLINT, 1)); // Add a flint to the drops\n        event.setDrops(drops);\n    }\n}\n</code></pre>"},{"location":"api/items/","title":"Items","text":"<p><code>NovaItem</code> represents an item type. It is similar to <code>Material</code> in Bukkit, except that it is only for items.</p>"},{"location":"api/items/#getting-a-novaitem-by-name","title":"Getting a <code>NovaItem</code> by name","text":"<p>To get a <code>NovaItem</code> you first have to get the <code>NovaItemRegistry</code> using the previously retrieved Nova instance.</p> KotlinJava <pre><code>val itemRegistry = Nova.itemRegistry\n</code></pre> <pre><code>NovaItemRegistry itemRegistry = nova.getItemRegistry(); // (1)!\n</code></pre> <ol> <li>\"nova\" is the previously retrieved Nova instance, preferably saved in a field/variable.You can also call <code>Nova.getNova().getItemRegistry()</code></li> </ol> <p>Using this registry, you can now get a <code>NovaItem</code> by id. It needs to be in the format <code>namespace:name</code>.</p> KotlinJava <pre><code>val item = itemRegistry.get(\"nova:wrench\") // (1)!\n</code></pre> <ol> <li>This will throw an exception if the item is not found. However, wrench always exists.If you're unsure or processing user input use <code>getOrNull</code> instead.</li> </ol> <pre><code>NovaItem item = itemRegistry.get(\"nova:wrench\"); // (1)!\n</code></pre> <ol> <li>This will throw an exception if the item is not found. However, wrench always exists.If you're unsure or processing user input use <code>getOrNull</code> instead.</li> </ol> <p>Info</p> <p>The same methods also exist for getting a <code>NovaItem</code> from an <code>ItemStack</code>.</p> <p>If you want to retrieve all items with a certain name and ignore the namespace, you can do this:</p> KotlinJava <pre><code>val items = itemRegistry.getNonNamespaced(\"wrench\")\n</code></pre> <pre><code>List&lt;NovaItem&gt; items = itemRegistry.getNonNamespaced(\"wrench\");\n</code></pre>"},{"location":"api/items/#getting-the-id-of-an-item","title":"Getting the id of an item","text":"<p>Example for <code>nova:wrench</code>:</p> KotlinJava <pre><code>val id = item.id\n\nval namespace = id.namespace // \"nova\"\nval name = id.name // \"wrench\"\nval idString = id.toString() // \"nova:wrench\"\n</code></pre> <pre><code>NamespacedId id = item.getId();\n\nString namespace = id.getNamespace(); // \"nova\"\nString name = id.getName(); // \"wrench\"\nString idString = id.toString(); // \"nova:wrench\"\n</code></pre>"},{"location":"api/items/#getting-the-translated-name-of-an-item","title":"Getting the translated name of an item","text":"<p>Nova uses the resource pack to translate items client side. However, if you still need to get the translated name of an item, you can use <code>NovaItem.getLocalizedName(locale)</code>. The locale is the language code of the language you want to get the name in. The code is the same as the language code used by Minecraft.</p> <p>Info</p> <p>If the given language code could not be found or is invalid, the english name of the item will be returned.</p> <p>Example for <code>nova:wrench</code>:</p> KotlinJava <pre><code>val name = item.getLocalizedName(\"de_de\") // \"Schraubenschl\u00fcssel\"\n</code></pre> <pre><code>String name = item.getLocalizedName(\"de_de\"); // \"Schraubenschl\u00fcssel\"\n</code></pre>"},{"location":"api/player/wailamanager/","title":"WailaManager","text":"<p>The WailaManager allows you to enable / disable the WAILA overlay for players.</p> KotlinJava <pre><code>// Get the current state\nval enabled = wailaManager.getState(player)\n\n// Enable the WAILA overlay\nwailaManager.setState(player, true)\n// Disable the WAILA overlay\nwailaManager.setState(player, false)\n</code></pre> <pre><code>// Get the current state\nboolean enabled = wailaManager.getState(player);\n\n// Enable the WAILA overlay\nwailaManager.setState(player, true);\n// Disable the WAILA overlay\nwailaManager.setState(player, false);\n</code></pre>"},{"location":"api/protection/protectionintegration/","title":"ProtectionIntegration","text":"<p>If you want to add a custom protection integration for your own plugin, you can do so by implementing the  <code>ProtectionIntegration</code> interface. This interface provides a handful of methods that will be called by the  <code>ProtectionManager</code>.</p> <p>For an example of how to implement this interface, you can check out some of our  built-in protection integrations.</p> <p>Once you have implemented the interface, you can register it with <code>Nova.registerProtectionIntegration(ProtectionIntegration)</code>.</p>"},{"location":"api/tileentity/tileentity/","title":"TileEntity","text":"<p>A TileEntity is a block that has internal logic and tick-based updates.</p>"},{"location":"api/tileentity/tileentity/#getting-the-owner-of-a-tileentity","title":"Getting the owner of a TileEntity","text":"KotlinJava <pre><code>val tileEntity = tileEntityManager.getTileEntityAt(location) ?: return\nval owner = tileEntity.owner\n</code></pre> <pre><code>TileEntity tileEntity = tileEntityManager.getTileEntityAt(location);\nif (tileEntity == null)\n    return;\nOfflinePlayer owner = tileEntity.getOwner();\n</code></pre>"},{"location":"api/tileentity/tileentity/#getting-the-localized-name-of-a-tileentity","title":"Getting the localized name of a TileEntity","text":"<p>Using the <code>NovaBlock</code> of a TileEntity, you can get the name of a TileEntity.</p> <p>For this example, we'll get the english name of a Pulverizer.</p> KotlinJava <pre><code>val tileEntity = tileEntityManager.getTileEntityAt(location) ?: return\nval name = tileEntity.block.getLocalizedName(\"en_us\")\nprintln(name) // prints \"Pulverizer\"\n</code></pre> <pre><code>TileEntity tileEntity = tileEntityManager.getTileEntityAt(location);\nif(tileEntity == null)\n    return;\nString name = tileEntity.getMaterial().getLocalizedName(\"en_us\");\nSystem.out.println(name); // prints \"Pulverizer\"\n</code></pre>"},{"location":"api/tileentity/tileentity/#getting-the-drops-of-a-tileentity","title":"Getting the drops of a TileEntity","text":"<p>These drops include all items in the TileEntity's inventory and the TileEntity itself if <code>includeSelf</code> is set to <code>true</code>.</p> KotlinJava <pre><code>val tileEntity = tileEntityManager.getTileEntityAt(location) ?: return\nval drops = tileEntity.getDrops(includeSelf = true)\n</code></pre> <pre><code>TileEntity tileEntity = tileEntityManager.getTileEntityAt(location);\nif (tileEntity == null)\n    return;\nList&lt;ItemStack&gt; drops = tileEntity.getDrops(true);\n</code></pre> <p>For more information about the TileEntityManager, see the TileEntityManager page.</p>"},{"location":"api/tileentity/tileentitymanager/","title":"TileEntityManager","text":"<p>You can get the <code>TileEntityManager</code> using the previously retrieved Nova instance.</p> KotlinJava <pre><code>val tileEntityManager = Nova.tileEntityManager\n</code></pre> <pre><code>TileEntityManager tileEntityManager = nova.getTileEntityManager(); // (1)!\n</code></pre> <ol> <li>\"nova\" is the previously retrieved Nova instance, preferably saved in a field/variable.You can also call <code>Nova.getNova().getTileEntityManager()</code></li> </ol>"},{"location":"api/tileentity/tileentitymanager/#getting-a-tileentity-at-a-specific-location","title":"Getting a TileEntity at a specific location","text":"<p>Getting a TileEntity at a specific location is done by calling the <code>getTileEntityAt</code> function of the <code>TileEntityManager</code>. The function either returns a TileEntity or <code>null</code> if there is no TileEntity at the specified location.</p> KotlinJava <pre><code>val tileEntity: TileEntity? = tileEntityManager.getTileEntityAt(location)\n</code></pre> <pre><code>TileEntity tileEntity = tileEntityManager.getTileEntityAt(location);\n</code></pre>"}]}