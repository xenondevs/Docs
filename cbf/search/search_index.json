{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Cosmic Binary Format","text":""},{"location":"#configuring-maven-gradle","title":"Configuring Maven / Gradle","text":"<p>CBF is xenondevs' lazy evaluation binary format used primarily in Nova. To use CBF, you first have to add the xenondevs maven repository to your build configuration.</p> MavenGradle GroovyGradle Kotlin <pre><code>&lt;repository&gt;\n    &lt;id&gt;xenondevs&lt;/id&gt;\n    &lt;url&gt;https://repo.xenondevs.xyz/releases&lt;/url&gt;\n&lt;/repository&gt;\n</code></pre> <pre><code>maven {\n    url 'https://repo.xenondevs.xyz/releases'\n}\n</code></pre> <pre><code>maven {\n    url = uri(\"https://repo.xenondevs.xyz/releases\")\n}\n</code></pre> <p>Now you can add CBF to your build configuration:</p> MavenGradle GroovyGradle Kotlin <pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;xyz.xenondevs.cbf&lt;/groupId&gt;\n    &lt;artifactId&gt;cosmic-binary-format&lt;/artifactId&gt;\n    &lt;version&gt;VERSION&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre> <pre><code>implementation \"xyz.xenondevs.cbf:cosmic-binary-format:VERSION\"\n</code></pre> <pre><code>implementation(\"xyz.xenondevs.cbf:cosmic-binary-format:VERSION\")\n</code></pre>"},{"location":"binaryadapter/","title":"BinaryAdapters","text":"<p>Binary adapters are used to serialize and deserialize objects into binary data.</p> Default adapters <p>The following adapters are available by default: <code>Byte</code>, <code>ByteArray</code>, <code>Short</code>, <code>ShortArray</code>, <code>Int</code>, <code>IntArray</code>, <code>Long</code>, <code>LongArray</code>, <code>Float</code>, <code>FloatArray</code>, <code>Double</code>, <code>DoubleArray</code>, <code>Boolean</code>, <code>BooleanArray</code>, <code>Char</code>, <code>CharArray</code>, <code>String</code>, <code>Array&lt;String&gt;</code>,  <code>Enum</code>, <code>UUID</code>, <code>Pair</code>, <code>Triple</code>, <code>List&lt;T&gt;</code>, <code>Set&lt;T&gt;</code>, <code>Map&lt;K, V&gt;</code>, <code>Compound</code></p>"},{"location":"binaryadapter/#creating-your-own-adapter","title":"Creating your own adapter","text":"<p>Creating your own adapter is easy. You just need to implement the <code>BinaryAdapter</code> interface and register it via the <code>CBF.registerBinaryAdapter</code> function. If you also want subclasses of a type to be serialized, you can use the <code>CBF.registerBinaryHierarchyAdapter</code> function. (For example, the <code>List</code> adapter)</p> <p>Let's create a simple adapter that serializes and deserializes a <code>java.awt.Color</code> instance.</p> ColorAdapter<pre><code>object ColorBinaryAdapter : BinaryAdapter&lt;Color&gt; {\n\n    override fun read(type: Type, buf: ByteBuffer): Color {\n        return Color(buf.readInt(), true)\n    }\n\n    override fun write(obj: Color, buf: ByteBuffer) {\n        buf.writeInt(obj.rgb)\n    }\n\n}\n</code></pre> <p>and register it:</p> <pre><code>CBF.registerBinaryAdapter(Color::class, ColorBinaryAdapter)\n</code></pre> <p>If you have generic types, you can use the type parameter.</p> PairBinaryAdapter<pre><code>object PairBinaryAdapter : BinaryAdapter&lt;Pair&lt;*, *&gt;&gt; {\n\n    override fun write(obj: Pair&lt;*, *&gt;, buf: ByteBuffer) {\n        CBF.write(obj.first, buf)\n        CBF.write(obj.second, buf)\n    }\n\n    override fun read(type: Type, buf: ByteBuffer): Pair&lt;*, *&gt; {\n        val typeArguments = (type as ParameterizedType).actualTypeArguments\n\n        return Pair&lt;Any?, Any?&gt;(\n            CBF.read(typeArguments[0], buf),\n            CBF.read(typeArguments[1], buf)\n        )\n    }\n\n}\n</code></pre> <p>The registration works the same way:</p> <pre><code>CBF.registerBinaryAdapter(Pair::class, PairBinaryAdapter)\n</code></pre> <p>Note</p> <p>Both these adapters are already registered by default. Replacing them might cause issues with already serialized data.</p>"},{"location":"compound/","title":"Compound","text":"<p>Compounds allow you store a lot of data in a single object. This makes it easier to get desired data on demand instead of continuously reading from a byte stream. You can pretty much see compounds as maps or json objects. Similar to json, data in compounds can be nested and is deserialized lazily. This means that until you specifically request a value, it will be stored as a byte array (It will of course be cached after the first time it is requested). Let's create a compound:</p> <pre><code>val compound = Compound()\ncompound[\"test1\"] = 123\ncompound[\"test2\"] = \"test\"\ncompound[\"test3\"] = true\ncompound[\"test4\"] = mapOf(\"test\" to 123, \"test2\" to 321)\ncompound[\"test5\"] = Compound().apply { this[\"list\"] = listOf(123, 321) }\n</code></pre> <p>This will create a compound with the following data:</p> <pre><code>{\n    \"test1\": 123\n    \"test2\": test\n    \"test3\": true\n    \"test4\": {test=123, test2=321}\n    \"test5\": {\n        \"list\": [123, 321]\n    }\n}\n</code></pre> <p>We can serialize it the same way we serialize any other object:</p> <pre><code>val bytes = CBF.write(compound)\n</code></pre> <p>We can then deserialize it, and get back the same data:</p> <pre><code>val compound = CBF.read&lt;Compound&gt;(bytes)!!\nprintln(compound.get&lt;Int&gt;(\"test1\")) // prints 123\nprintln(compound.get&lt;String&gt;(\"test2\")) // prints test\nprintln(compound.get&lt;Boolean&gt;(\"test3\")) // prints true\nprintln(compound.get&lt;Map&lt;String, Int&gt;&gt;(\"test4\")) // prints {test=123, test2=321}\nprintln(compound.get&lt;Compound&gt;(\"test5\")!!.get&lt;List&lt;Int&gt;&gt;(\"list\")) // prints [123, 321]\n</code></pre>"},{"location":"instancecreator/","title":"InstanceCreators","text":"<p>Some serializable classes can't be initiated via an empty constructor. This is where <code>InstanceCreators</code> come in. For example, an <code>EnumMap</code> needs the enum class as a constructor parameter. So we can use the <code>Type</code> parameter retrieved  when calling a serialization function to pass the enum class.</p> EnumMapInstanceCreator<pre><code>object EnumMapInstanceCreator : InstanceCreator&lt;EnumMap&lt;*, *&gt;&gt; {\n\n    override fun createInstance(type: KType): EnumMap&lt;*, *&gt; {\n        val clazz = type.arguments[0].type!!.classifierClass!!.java\n        return createEnumMap(clazz)\n    }\n\n    @Suppress(\"UNCHECKED_CAST\")\n    private fun &lt;E : Enum&lt;E&gt;&gt; createEnumMap(clazz: Class&lt;*&gt;): EnumMap&lt;*, *&gt; {\n        return EnumMap&lt;E, Any&gt;(clazz as Class&lt;E&gt;)\n    }\n\n}\n</code></pre> <p>You can register it similarly to <code>BinaryAdapters</code>.</p> <pre><code>registerInstanceCreator(EnumMap::class, EnumMapInstanceCreator)\n</code></pre> <p>Note</p> <p>This instance creator is registered by default.</p>"},{"location":"serialization/","title":"Serialization","text":""},{"location":"serialization/#serialization","title":"Serialization","text":"<p>To serialize objects, you can use <code>CBF.write</code>:</p> <pre><code>val out = ByteArrayOutputStream()\nval writer = ByteWriter.fromStream(out)\nval list = listOf(\"test1\", \"test2\", \"test3\")\nCBF.write(list, writer)\nval bytes = out.toByteArray()\n</code></pre> <p>or</p> <pre><code>val list = listOf(\"test1\", \"test2\", \"test3\")\nval bytes = CBF.write(list)\n</code></pre>"},{"location":"serialization/#deserialization","title":"Deserialization","text":"<p>To deserialize binary data, you can use <code>CBF.read</code>:</p> <pre><code>val inp: InputStream // ...\nval reader = ByteReader.fromStream(inp)\nval list = CBF.read&lt;List&lt;String&gt;&gt;(reader)\n</code></pre> <p>or</p> <pre><code>val list = CBF.read&lt;List&lt;String&gt;&gt;(bytes)\n</code></pre>"}]}