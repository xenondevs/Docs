{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Cosmic Binary Format","text":""},{"location":"#configuring-maven-gradle","title":"Configuring Maven / Gradle","text":"<p>CBF is xenondevs' lazy evaluation binary format used primarily in Nova. To use CBF, you first have to add the xenondevs maven repository to your build configuration.</p> MavenGradle GroovyGradle Kotlin <pre><code>&lt;repository&gt;\n    &lt;id&gt;xenondevs&lt;/id&gt;\n    &lt;url&gt;https://repo.xenondevs.xyz/releases&lt;/url&gt;\n&lt;/repository&gt;\n</code></pre> <pre><code>maven {\n    url 'https://repo.xenondevs.xyz/releases'\n}\n</code></pre> <pre><code>maven {\n    url = uri(\"https://repo.xenondevs.xyz/releases\")\n}\n</code></pre> <p>Now you can add CBF to your build configuration:</p> MavenGradle GroovyGradle Kotlin <pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;xyz.xenondevs.cbf&lt;/groupId&gt;\n    &lt;artifactId&gt;cosmic-binary-format&lt;/artifactId&gt;\n    &lt;version&gt;VERSION&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre> <pre><code>implementation \"xyz.xenondevs.cbf:cosmic-binary-format:VERSION\"\n</code></pre> <pre><code>implementation(\"xyz.xenondevs.cbf:cosmic-binary-format:VERSION\")\n</code></pre> <p>To find the latest CBF version, you can explore the Maven Repository or check out the GitHub Releases Page.</p>"},{"location":"compound/","title":"Compound","text":"<p>A <code>Compound</code> is a key-value store that serializes its data using the registered serializers.</p> <p>Data is deserialized lazily. This means that until you specifically request a value, it will be stored as binary data (It will of course be cached after the first time it is requested).</p>"},{"location":"compound/#basic-usage","title":"Basic usage","text":"<pre><code>val compound = Compound()\ncompound[\"test1\"] = 123\ncompound[\"test2\"] = \"test\"\ncompound[\"test3\"] = true\ncompound[\"test4\"] = mapOf(\"test\" to 123, \"test2\" to 321)\ncompound[\"test5\"] = Compound().apply { this[\"list\"] = listOf(123, 321) }\n</code></pre> <p>This will create a compound with the following data:</p> <pre><code>{\n    \"test1\": 123\n    \"test2\": test\n    \"test3\": true\n    \"test4\": {test=123, test2=321}\n    \"test5\": {\n        \"list\": [123, 321]\n    }\n}\n</code></pre> <p>We can serialize it the same way we serialize any other object:</p> <pre><code>val bytes = Cbf.write(compound)\n</code></pre> <p>We can then deserialize it, and get back the same data:</p> <pre><code>val compound = Cbf.read&lt;Compound&gt;(bytes)!!\nprintln(compound.get&lt;Int&gt;(\"test1\")) // prints 123\nprintln(compound.get&lt;String&gt;(\"test2\")) // prints test\nprintln(compound.get&lt;Boolean&gt;(\"test3\")) // prints true\nprintln(compound.get&lt;Map&lt;String, Int&gt;&gt;(\"test4\")) // prints {test=123, test2=321}\nprintln(compound.get&lt;Compound&gt;(\"test5\")!!.get&lt;List&lt;Int&gt;&gt;(\"list\")) // prints [123, 321]\n</code></pre>"},{"location":"compound/#entry-providers","title":"Entry providers","text":"<p>Using <code>Compound.entry&lt;T&gt;(key: String)</code>, you can obtain a  MutableProvider&lt;T?&gt; that will contain the value of type <code>T</code> under the given key.</p>"},{"location":"compound/#non-defaulting","title":"Non-defaulting","text":"<p>Non-defaulting entry providers will contain <code>null</code> if there is no value under the given key.</p> <pre><code>val compound = Compound()\nvar entry: Int? by compound.entry&lt;Int&gt;(\"a\")\n</code></pre> <p>Changing the value of the provider updates the value stored inside the compound:</p> <pre><code>println(entry) // null\nentry = 1\nprintln(entry) // 1\nprintln(compound[\"a\"]) // 1\n</code></pre> <p>And vice versa, if you update the value inside the compound, the provider will be automatically updated as well:</p> <pre><code>compound[\"a\"] = 2\nprintln(entry) // 2\n</code></pre> <p>Once you've registered an entry provider for a key, the type under this key is constrained to the type of the entry provider.</p> <pre><code>val compound = Compound()\n\n// no entry provider: type under key \"a\" can be changed\ncompound[\"a\"] = 1\ncompound[\"a\"] = \"1\"\n\n// with entry provider: type is constrained to provider's type\nvar entry: String? by compound.entry&lt;String&gt;(\"a\")\ncompound[\"a\"] = 1 // IllegalArgumentException: kotlin.Int (value type) is not a subtype of kotlin.String? (entry type)\n</code></pre>"},{"location":"compound/#defaulting","title":"Defaulting","text":"<p>Defaulting entry providers cannot be <code>null</code>. Instead, a default value is lazily generated using a predefined lambda if there initially is no value under the given key.</p> <pre><code>val compound = Compound()\nvar entry: Int by compound.entry&lt;Int&gt;(\"a\") { 1 }\n\nprintln(entry) // 1\nprintln(compound[\"a\"]) // 1\n</code></pre> <p>Note that defaulting entry providers introduce an additional type constraint of non-nullability to the type under the key, meaning entries cannot be removed (i.e. set to <code>null</code>).</p> <pre><code>val compound = Compound()\n\n// non-defaulting entry provider: value can be removed (set to null)\nvar entry: Int? by compound.entry&lt;Int&gt;(\"a\")\ncompound[\"a\"] = null\n\n// default entry provider: value cannot be removed (set to null)\nvar entry1: Int by compound.entry&lt;Int&gt;(\"b\") { 1 }\ncompound[\"b\"] = null // IllegalArgumentException: kotlin.Nothing? (value type) is not a subtype of kotlin.Int (entry type)\n</code></pre>"},{"location":"serialization/","title":"Serialization","text":""},{"location":"serialization/#serialization-basics","title":"Serialization Basics","text":"<p>In CBF, <code>BinarySerializers</code> define how objects are (de)serialized to and from binary data. These serializers are then centrally registered at the <code>Cbf</code> singleton object.</p> Default serializers <p>Serializers for the following types are registered by default: <code>Byte</code>, <code>ByteArray</code>, <code>Short</code>, <code>ShortArray</code>, <code>Int</code>, <code>IntArray</code>, <code>Long</code>, <code>LongArray</code>, <code>Float</code>, <code>FloatArray</code>, <code>Double</code>, <code>DoubleArray</code>, <code>Boolean</code>, <code>BooleanArray</code>, <code>Char</code>, <code>CharArray</code>, <code>String</code>, <code>Array&lt;String&gt;</code>,  <code>Enum</code>, <code>UUID</code>, <code>kotlin.Uuid</code>, <code>Pair</code>, <code>Triple</code>, <code>List&lt;T&gt;</code>, <code>Set&lt;T&gt;</code>, <code>Map&lt;K, V&gt;</code>, <code>Compound</code></p>"},{"location":"serialization/#serializing","title":"Serializing","text":"<p>To serialize objects, you can use <code>Cbf.write</code>:</p> <pre><code>val out: OutputStream // ...\nval writer: ByteWriter = ByteWriter.fromStream(out)\nval list: List&lt;String&gt; = listOf(\"test1\", \"test2\", \"test3\")\nCbf.write(list, writer)\n</code></pre> <p>or</p> <pre><code>val list: List&lt;String&gt; = listOf(\"test1\", \"test2\", \"test3\")\nval bytes: ByteArray = Cbf.write(list)\n</code></pre>"},{"location":"serialization/#deserializing","title":"Deserializing","text":"<p>To deserialize binary data, you can use <code>Cbf.read</code>:</p> <pre><code>val inp: InputStream // ...\nval reader: ByteReader = ByteReader.fromStream(inp)\nval list: List&lt;String&gt;? = Cbf.read&lt;List&lt;String&gt;&gt;(reader)\n</code></pre> <p>or</p> <pre><code>val list: List&lt;String&gt;? = Cbf.read&lt;List&lt;String&gt;&gt;(bytes)\n</code></pre> <p>Serializer type is chosen at compile-time</p> <p>The type of the serializer that is chosen is determined by the type parameter of the <code>Cbf.read</code> and <code>Cbf.write</code> methods, which means that it is determined statically at compile-time. This also means that you can also choose to serialize the value as a supertype, e.g. <code>Cbf.write&lt;Any&gt;(list)</code> would look for a serializer for <code>Any</code>.</p>"},{"location":"serialization/#configuring-existing-serializers","title":"Configuring existing serializers","text":"<p>Some built-in serializers allow extra configuration via the <code>Cbf</code> object. For example, you can specify which enums should be serialized via their ordinal value instead of their name using <code>Cbf.addOrdinalEnums</code> or tell CBF how to create instances of certain collection types via <code>Cbf.addCollectionCreator</code>, <code>Cbf.addMapCreator</code>.</p>"},{"location":"serialization/#custom-serializers","title":"Custom Serializers","text":"<p>You can create a custom serializer by implementing the <code>BinarySerializer&lt;T&gt;</code> interface. However, for most cases, it is easier to extend <code>UnversionedBinarySerializer&lt;T&gt;</code> or <code>VersionedBinarySerializer&lt;T&gt;</code> instead.</p>"},{"location":"serialization/#unversioned-binary-serializers","title":"Unversioned binary serializers","text":"<p><code>UnversionedBinarySerializer</code> is a serializer that has already implemented null handling by writing an unsigned byte <code>0</code> byte for <code>null</code> and <code>1</code>, followed by the serialized data, for non-null values. If you want to change the binary format at a later point, you can switch to <code>VersionedBinarySerializer</code> without introducing a breaking change, as the remaining values in the leading byte will then be used to indicate the format version.</p> <p>This is how you can implement an <code>UnversionedBinarySerializer</code> for an example <code>Person</code> class: <pre><code>data class Person(\n    val id: Int,\n    val firstName: String,\n    val lastName: String\n)\n\nobject PersonSerializer : UnversionedBinarySerializer&lt;Person&gt;() {\n\n    override fun readUnversioned(reader: ByteReader): Person {\n        return Person(\n            id = reader.readInt(),\n            firstName = reader.readString(),\n            lastName = reader.readString()\n        )\n    }\n\n    override fun writeUnversioned(obj: Person, writer: ByteWriter) {\n        writer.writeInt(obj.id)\n        writer.writeString(obj.firstName)\n        writer.writeString(obj.lastName)\n    }\n\n    override fun copyNonNull(obj: Person): Person {\n        return obj.copy()\n    }\n\n}\n</code></pre></p> <pre><code>Cbf.registerSerializer(PersonSerializer)\n</code></pre>"},{"location":"serialization/#versioned-binary-serializers","title":"Versioned binary serializers","text":"<p><code>VersionedBinarySerializer</code> allows reading older formats of the data and writing to a new format.</p> <p>In the following example, an <code>address</code> field has been added to the <code>Person</code> class used above. We can now swap out our <code>UnversionedBinarySerializer</code> for a <code>VersionedBinarySerializer</code>. The format is now at version <code>2</code>, as the previous version was <code>1</code>. (<code>0</code> is reserved for null values) <pre><code>data class Person(\n    val id: Int,\n    val firstName: String,\n    val lastName: String,\n    val address: String // new\n)\n\nobject PersonSerializer : VersionedBinarySerializer&lt;Person&gt;(2.toUByte()) {\n\n    override fun readVersioned(version: UByte, reader: ByteReader): Person {\n        when (version) {\n            // legacy format\n            1.toUByte() -&gt; Person(\n                id = reader.readInt(),\n                firstName = reader.readString(),\n                lastName = reader.readString(),\n                address = \"\"\n            )\n\n            // new format\n            2.toUByte() -&gt; Person(\n                id = reader.readInt(),\n                firstName = reader.readString(),\n                lastName = reader.readString(),\n                address = reader.readString() // new\n            )\n\n            else -&gt; throw UnsupportedOperationException()\n        }\n    }\n\n    override fun writeVersioned(obj: Person, writer: ByteWriter) {\n        writer.writeInt(obj.id)\n        writer.writeString(obj.firstName)\n        writer.writeString(obj.lastName)\n        writer.writeString(obj.address)\n    }\n\n    override fun copyNonNull(obj: Person): Person {\n        return obj.copy()\n    }\n\n}\n</code></pre></p> <pre><code>Cbf.registerSerializer(PersonSerializer)\n</code></pre>"},{"location":"serialization/#serializer-factory","title":"Serializer factory","text":"<p>For some types, especially container types like <code>List&lt;T&gt;</code> or <code>Pair&lt;A, B&gt;</code>, it is necessary to create a custom serializer per generic type parameter. This can be achieved using a <code>BinarySerializerFactory</code>:</p> <p>The following example shows how to create a serializer for <code>Pair&lt;A, B&gt;</code>, where <code>A</code> and <code>B</code> are in turn also serialized via a dynamically chosen <code>BinarySerializer&lt;A&gt;</code> and <code>BinarySerializer&lt;B&gt;</code>. <pre><code>internal class PairBinarySerializer&lt;A : Any, B : Any&gt;(\n    private val aSerializer: BinarySerializer&lt;A&gt;,\n    private val bSerializer: BinarySerializer&lt;B&gt;\n) : UnversionedBinarySerializer&lt;Pair&lt;A?, B?&gt;&gt;() {\n\n    override fun writeUnversioned(obj: Pair&lt;A?, B?&gt;, writer: ByteWriter) {\n        aSerializer.write(obj.first, writer)\n        bSerializer.write(obj.second, writer)\n    }\n\n    override fun readUnversioned(reader: ByteReader): Pair&lt;A?, B?&gt; {\n        return Pair(\n            aSerializer.read(reader),\n            bSerializer.read(reader)\n        )\n    }\n\n    override fun copyNonNull(obj: Pair&lt;A?, B?&gt;): Pair&lt;A?, B?&gt; {\n        return Pair(\n            aSerializer.copy(obj.first),\n            bSerializer.copy(obj.second)\n        )\n    }\n\n    companion object : BinarySerializerFactory {\n\n        @OptIn(UncheckedApi::class)\n        override fun create(type: KType): BinarySerializer&lt;*&gt;? {\n            if (!type.isSubtypeOf(typeOf&lt;Pair&lt;*, *&gt;?&gt;())) // (1)!\n                return null\n\n            val typeA = type.arguments.getOrNull(0)?.type\n                ?: return null\n            val typeB = type.arguments.getOrNull(1)?.type\n                ?: return null\n\n            return PairBinarySerializer(\n                Cbf.getSerializer(typeA),\n                Cbf.getSerializer(typeB)\n            )\n        }\n\n    }\n\n}\n</code></pre></p> <ol> <li>Note that the <code>create</code> function is invoked for all types, not just subtypes of <code>Pair</code>, which is why it is necessary     to check if the type is a subtype of <code>Pair&lt;*, *&gt;?</code> before proceeding.</li> </ol> <pre><code>Cbf.registerSerializerFactory(PairBinarySerializer)\n</code></pre>"}]}