{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"InvUI","text":""},{"location":"#configuring-maven-gradle","title":"Configuring Maven / Gradle","text":"<p>Minimum required Java version: <code>11</code></p> <p>To use InvUI, you first have to add the xenondevs maven repository to your build configuration.</p> MavenGradle GroovyGradle Kotlin <pre><code>&lt;repository&gt;\n    &lt;id&gt;xenondevs&lt;/id&gt;\n    &lt;url&gt;https://repo.xenondevs.xyz/releases&lt;/url&gt;\n&lt;/repository&gt;\n</code></pre> <pre><code>maven {\n    url 'https://repo.xenondevs.xyz/releases'\n}\n</code></pre> <pre><code>maven(\"https://repo.xenondevs.xyz/releases\")\n</code></pre> <p>Now you can add InvUI as a dependency:</p> MavenGradle GroovyGradle Kotlin <pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;xyz.xenondevs.invui&lt;/groupId&gt;\n    &lt;artifactId&gt;invui&lt;/artifactId&gt;\n    &lt;version&gt;VERSION&lt;/version&gt;\n    &lt;type&gt;pom&lt;/type&gt;\n&lt;/dependency&gt;\n</code></pre> <pre><code>implementation \"xyz.xenondevs.invui:invui:VERSION\"\n</code></pre> <pre><code>implementation(\"xyz.xenondevs.invui:invui:VERSION\")\n</code></pre> (optional) Manually choosing inventory-access revisions <p>InvUI uses <code>inventory-access</code> for multi-version support. If you depend on the <code>invui</code> module, you'll automatically get all available <code>inventory-access</code> revisions. If your plugin does not have multi-version support or you only need certain versions, you can either exclude the related <code>inventory-access</code> revisions or instead depend on the <code>invui-core</code> module which does not have transitive dependencies on any <code>inventory-access</code> revisions.</p> <pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;xyz.xenondevs.invui&lt;/groupId&gt;\n    &lt;artifactId&gt;invui-core&lt;/artifactId&gt;\n    &lt;version&gt;VERSION&lt;/version&gt;\n&lt;/dependency&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;xyz.xenondevs.invui&lt;/groupId&gt;\n    &lt;artifactId&gt;inventory-access-r13&lt;/artifactId&gt; &lt;!--(1)!--&gt;\n    &lt;classifier&gt;remapped-mojang&lt;/classifier&gt; &lt;!--(2)!--&gt;\n    &lt;version&gt;VERSION&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre> <ol> <li>You can find a list of inventory-access revisions and which Minecraft version they map to here.</li> <li>You can also add the <code>remapped-mojang</code> classifier to get InvUI working on mojang-mapped servers.</li> </ol> <p>If you're using Kotlin, you should also add the <code>invui-kotlin</code> module:</p> MavenGradle GroovyGradle Kotlin <pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;xyz.xenondevs.invui&lt;/groupId&gt;\n    &lt;artifactId&gt;invui-kotlin&lt;/artifactId&gt;\n    &lt;version&gt;VERSION&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre> <pre><code>implementation \"xyz.xenondevs.invui:invui-kotlin:VERSION\"\n</code></pre> <pre><code>implementation(\"xyz.xenondevs.invui:invui-kotlin:VERSION\")\n</code></pre> <p>To find the latest InvUI version, you can explore the Maven Repository or check out the GitHub Releases Page.</p>"},{"location":"#paper-plugin","title":"Paper Plugin","text":"<p>Starting with 1.20.5, Paper now ships with a Mojang-mapped runtime by default. If you're creating a paper plugin, i.e. you have a <code>paper-plugin.yml</code>, you'll need to make sure that InvUI's <code>inventory-access</code> modules are remapped by Paper. (If you don't have a <code>paper-plugin.yml</code>, you can ignore this section.) This can be achieved by loading InvUI through Paper's library loader:</p> <p>org.example.MyPluginLoader<pre><code>public class MyPluginLoader implements PluginLoader {\n\n    @Override\n    public void classloader(@NotNull PluginClasspathBuilder pluginClasspathBuilder) {\n        MavenLibraryResolver resolver = new MavenLibraryResolver();\n        resolver.addRepository(new RemoteRepository.Builder(\"xenondevs\", \"default\", \"https://repo.xenondevs.xyz/releases/\").build());\n        resolver.addDependency(new Dependency(new DefaultArtifact(\"xyz.xenondevs.invui:invui:pom:VERSION\"), null));\n        pluginClasspathBuilder.addLibrary(resolver);\n    }\n\n}\n</code></pre> paper-plugin.yml<pre><code>loader: org.example.MyPluginLoader\n</code></pre></p> <p>When InvUI is loaded through the plugin loader, it will not be able to read your plugin instance from the class loader, so you'll need to set it manually in your plugin's <code>onEnable</code> like this:</p> <pre><code>public class MyPlugin extends JavaPlugin {\n\n    @Override\n    public void onEnable() {\n        InvUI.getInstance().setPlugin(this);\n    }\n\n}\n</code></pre> <p>Make sure to not also include InvUI classes in your plugin jar</p> <p>If you're loading InvUI using the PluginLoader approach above, make sure to not also include InvUI classes in your plugin jar. (i.e. mark the dependency as <code>&lt;scope&gt;provided&lt;/scope&gt;</code> in Maven or use the <code>compileOnly</code> dependency configuration in Gradle)</p> <p>Alternatively, if you want to create a fat jar, you'll need to set the <code>paperweight-mappings-namespace</code> manifest attribute to <code>spigot</code> and make sure that your own classes are remapped accordingly. For more information, refer to the Paper Documentation.</p> <p>Mojang-mapped artifacts on the repository</p> <p>While there are Mojang-mapped artifacts for the <code>inventory-access</code> revisions on the repository, they are not compatible with Paper's Mojang-mapped runtime, as they still use versioned CraftBukkit package names, which are also no longer present in the Paper runtime. They can however be used on Mojang-mapped Spigot servers.</p>"},{"location":"#javadoc","title":"Javadoc","text":"<p>You may also want to check out the InvUI javadoc.</p>"},{"location":"basics/","title":"InvUI Basics","text":"<p>Displaying an inventory to a player requires two things: a GUI and a Window The GUI contains all UI Elements Items, while a Window actually displays it to a user and is directly tied to a Bukkit inventory. Not tying the GUI to a specific inventory type (like Chest, Dropper, Hopper or Anvil) allows for a much more flexible usage as well as nested GUIs, which can be very helpful when you're trying to create a more complex menu.</p>"},{"location":"basics/#creating-a-gui-with-the-guibuilder","title":"Creating a GUI with the GuiBuilder","text":"<p>Every <code>...Gui</code> interface has static methods to create the specific <code>Gui.Builder</code>. If the GUI can have multiple types, such as paged GUIs being able to display a list of items or a list of GUIs, the methods are named <code>.items()</code> or <code>.guis()</code> respectively. If there is only one type, the method is named <code>.normal()</code>. This is the case for the default and tab GUI.</p> <p>This is an example of how you would go about creating a default Gui using the GuiBuilder:</p> KotlinJava <pre><code>val gui = Gui.normal() // Creates the GuiBuilder for a normal GUI\n    .setStructure(\n        \"# # # # # # # # #\",\n        \"# . . . . . . . #\",\n        \"# . . . . . . . #\",\n        \"# # # # # # # # #\")\n    .addIngredient('#', SimpleItem(ItemBuilder(Material.BLACK_STAINED_GLASS_PANE)))\n    .build()\n</code></pre> <pre><code>Gui gui = Gui.normal() // Creates the GuiBuilder for a normal GUI\n    .setStructure(\n        \"# # # # # # # # #\",\n        \"# . . . . . . . #\",\n        \"# . . . . . . . #\",\n        \"# # # # # # # # #\")\n    .addIngredient('#', new SimpleItem(new ItemBuilder(Material.BLACK_STAINED_GLASS_PANE)))\n    .build();\n</code></pre> <p>Then, create a Window and show it to a player:</p> KotlinJava <pre><code>val window = Window.single()\n    .setViewer(player)\n    .setTitle(\"InvUI\")\n    .setGui(gui)\n    .build()\n\nwindow.open()\n</code></pre> <pre><code>Window window = Window.single()\n    .setViewer(player)\n    .setTitle(\"InvUI\")\n    .setGui(gui)\n    .build();\n\nwindow.open();\n</code></pre> <p></p>"},{"location":"basics/#creating-a-gui-without-the-guibuilder","title":"Creating a GUI without the GuiBuilder","text":"<p>If you don't want to use the GuiBuilder, you can also call the static factory methods in the <code>Gui</code> interfaces.</p> KotlinJava <pre><code>// create the GUI\nval gui = Gui.empty(9, 4)\n\n// set items using x and y coordinates\ngui.setItem(0, 0, item)\n\n// set an item using the slot index\ngui.setItem(10, item)\n\n// use a Structure to add items (like in the GuiBuilder)\nval structure: Structure = Structure(\n    \"# # # # # # # # #\",\n    \"# . . . . . . . #\",\n    \"# . . . . . . . #\",\n    \"# # # # # # # # #\")\n    .addIngredient('#', item)\n\ngui.applyStructure(structure)\n</code></pre> <pre><code>// create the GUI\nGui gui = Gui.empty(9, 4);\n\n// set items using x and y coordinates\ngui.setItem(0, 0, item);\n\n// set an item using the slot index\ngui.setItem(10, item);\n\n// use a Structure to add items (like in the GuiBuilder)\nStructure structure = new Structure(\n    \"# # # # # # # # #\",\n    \"# . . . . . . . #\",\n    \"# . . . . . . . #\",\n    \"# # # # # # # # #\")\n    .addIngredient('#', item);\n\ngui.applyStructure(structure);\n</code></pre>"},{"location":"basics/#items-in-guis","title":"Items in GUIs","text":"<p>So now that you know how to create GUIs, you'll need to add UI Elements (<code>Items</code>) to them. I have already shown one type of <code>Item</code>, the <code>SimpleItem</code>. The <code>SimpleItem</code> is a static <code>Item</code>. It cannot change its appearance and doesn't do anything when clicked. This makes it perfect for placeholders like glass panes, which don't do anything. To create your own Item type, you'll need to inherit from either <code>AbstractItem</code> (if you want to be able to change its appearance) or <code>SimpleItem</code> (if you don't need to change its appearance). In this example, I inherited from <code>AbstractItem</code>. Every time a player clicks on the <code>Item</code>, a counter will be incremented and the number on the Item will change.</p> KotlinJava <pre><code>class CountItem : AbstractItem() {\n\n    private var count = 0\n\n    override fun getItemProvider(): ItemProvider {\n        return ItemBuilder(Material.DIAMOND).setDisplayName(\"Count: $count\")\n    }\n\n    override fun handleClick(clickType: ClickType, player: Player, event: InventoryClickEvent) {\n        if (clickType.isLeftClick) {\n            count++ // increment if left click\n        } else {\n            count-- // else decrement\n        }\n        notifyWindows() // this will update the ItemStack that is displayed to the player\n    }\n\n}\n</code></pre> <pre><code>public class CountItem extends AbstractItem {\n\n    private int count;\n\n    @Override\n    public ItemProvider getItemProvider() {\n        return new ItemBuilder(Material.DIAMOND).setDisplayName(\"Count: \" + count);\n    }\n\n    @Override\n    public void handleClick(@NotNull ClickType clickType, @NotNull Player player, @NotNull InventoryClickEvent event) {\n        if (clickType.isLeftClick()) {\n            count++; // increment if left click\n        } else {\n            count--; // else decrement\n        }\n\n        notifyWindows(); // this will update the ItemStack that is displayed to the player\n    }\n\n}\n</code></pre> <p>The <code>notifyWindows</code> call is very important. It will tell all Windows that are currently displaying that Item to redraw it. They will call the <code>getItemProvider</code> method and display the new ItemStack to the Player.</p> <p>After adding the Item to the GUI as described above, it will look like this:</p> <p></p> <p>For more information about UI Items in InvUI, visit the Items page.</p>"},{"location":"inventory/","title":"Inventory","text":"<p>The <code>xyz.xenondevs.invui.inventory.Inventory</code> is a type of inventory that can be embedded in GUIs. It provides several utility methods to easily add and remove items from the inventory, as well as an advanced event system allowing to listen for and affect changes in the inventory.</p> <p>The general contracts of <code>Inventory</code> and all implementations are:</p> <ul> <li>There are no <code>ItemStacks</code> of type <code>Material.AIR</code> or <code>ItemStack.getAmount() == 0</code>.   Empty <code>ItemStacks</code> are represented by <code>null</code>.</li> <li>Unless otherwise specified, all methods will return a clone of the actual backing <code>ItemStack</code>.   Changes to returned <code>ItemStacks</code> will never affect the <code>Inventory</code>.</li> <li>Unless otherwise specified, all methods accepting <code>ItemStacks</code> will always clone them before   putting them in the backing array / inventory.   Changes to the passed <code>ItemStacks</code> after calling a method will never affect the <code>Inventory</code>.</li> </ul>"},{"location":"inventory/#types-of-inventories","title":"Types of Inventories","text":""},{"location":"inventory/#virtual-inventory","title":"Virtual Inventory","text":"<p>Like normal inventories, virtual inventories can store a predefined amount of <code>ItemStacks</code>, but unlike Minecraft's inventories, they do not have a defined width or height, just a size.</p> <p>To create a <code>VirtualInventory</code>, you can do one of three things:</p> <ul> <li>Call the <code>VirtualInventory</code> constructor directly</li> <li>Deserialize a <code>VirtualInventory</code> from an <code>InputStream</code> or <code>byte[]</code> using <code>VirtualInventory#deserialize</code></li> <li>Use the <code>VirtualInventoryManager</code> to get a previously serialized <code>VirtualInventory</code> from a file.   This <code>VirtualInventory</code> will then get written into the file again when the plugin gets disabled.</li> </ul>"},{"location":"inventory/#custom-stack-sizes","title":"Custom Stack Sizes","text":"<p>Virtual inventories also allow customizing the stack sizes of every slot. You can change them by providing a <code>maxStackSizes</code> array in the constructor, or set them later using <code>VirtualInventory#setMaxStackSizes</code> or <code>VirtualInventory#setMaxStackSize</code>.</p> <p>If you're creating a plugin that modifies maximum stack sizes of items, change the <code>StackSizeProvider</code> in <code>InventoryUtils#stackSizeProvider</code> to a custom one you've created. This will make InvUI respect your maximum stack sizes.</p> <p>Stack sizes higher than what is normally allowed in vanilla Minecraft are not possible!</p>"},{"location":"inventory/#serialization","title":"Serialization","text":"<p>You can either directly (de)serialize a <code>VirtualInventory</code> to/from a stream or byte[] using <code>VirtualInventory#serialize</code> and <code>VirtualInventory#deserialize</code>, or use the <code>VirtualInventoryManager</code> to automatically do that for you.</p> <p>Only the <code>UUID</code> and <code>ItemStack[]</code> are serialized!</p> <p>Using the <code>VirtualInventoryManager</code>, inventories obtained with <code>createNew</code>, <code>getByUUID</code> and <code>getOrCreate</code> will be automatically serialized when the plugin gets disabled. These inventories are stored under <code>plugins/InvUI/VirtualInventory/&lt;Name of your plugin&gt;/</code>.</p> <p>Info</p> <p>The <code>uuid</code> parameter is only required for serialization with the <code>VirtualInventoryManager</code>. You can set it to null, if you're not planning to serialize your inventory this way.</p>"},{"location":"inventory/#referencinginventory","title":"ReferencingInventory","text":"<p>The <code>ReferencingInventory</code> is an <code>Inventory</code> that is backed by a Bukkit inventory. Changes in this inventory are applied in the referenced inventory and changes in the bukkit inventory are visible in this inventory.</p> <p>Window Updating</p> <p>Changes done using the methods provided by InvUI inventory will cause displaying <code>Windows</code> to be notified, but changes done directly in the bukkit inventory will not. Therefore, if embedded in a GUI, it is necessary to call <code>Inventory#notifyWindows</code> manually in order for changes to be displayed.</p>"},{"location":"inventory/#compositeinventory","title":"CompositeInventory","text":"<p>The <code>CompositeInventory</code> is a composite of multiple inventories. Those can be <code>VirtualInventories</code>, <code>ReferencingInventories</code>, or any other custom implementation of <code>Inventory</code>.</p>"},{"location":"inventory/#inventory-events","title":"Inventory Events","text":"<p>You can also register update handlers to your <code>Inventory</code>. There are two different types of events:</p> Event type Registered with Description Use-case <code>ItemPreUpdateEvent</code> <code>Inventory.setPreUpdateHandler</code> Called before changes were fully processed. Cancelling this event or changing the amount of items that were added/removed will affect the source of the change (which is the player most of the time). Restricting which or how many items can be put into an inventory or a specific slot.Example 1: A player tries to put a full stack of 64 items into the inventory, but the amount gets changed to 32 in the event, so the remaining 32 items stay on the player's cursor.Example 2: A player shift-clicks a dirt block into the inventory, but the event is cancelled in such a way that only diamonds can be placed on slot 1, and everything else can be placed on slot 2, so the dirt is put on slot 2. <code>ItemPostUpdateEvent</code> <code>Inventory.setPostUpdateHandler</code> After changes were fully processed. This event cannot be cancelled and changes done to the inventory during this event will not affect the source of the change. Removing or editing items after they've been added to the inventory.Example: A trash can inventory that immediately removes all items that have been put into it."},{"location":"inventory/#inventories-in-guis","title":"Inventories in GUIs","text":"<p>Adding an <code>Inventory</code> to a GUI can be done the same way as adding Items. You can either:</p> <ul> <li>Define an ingredient for the <code>Inventory</code> in <code>Structure</code> or the delegating <code>Gui.Builder</code> method.</li> <li>Use the filling methods in <code>Gui</code>.</li> <li>Create a <code>SlotElement.InventorySlotElement</code> which links to the specific slot.</li> </ul>"},{"location":"inventory/#gui-priority","title":"GUI priority","text":"<p>If you have multiple virtual inventories in one GUI, you might want to change the order of which items are added to them with shift-clicks or collected using double clicks. This can be done by setting the <code>guiPriority</code> in <code>Inventory</code>. The inventory with the highest priority will be used first.</p>"},{"location":"inventory/#background","title":"Background","text":"<p>If you want your inventory slots to have a background <code>ItemProvider</code> (which is an item that is technically in the slot, but will be ignored by all click actions) you can set the <code>background</code> parameter in <code>Structure.addIngredient(char key, Inventory inventory, ItemProvider background)</code> or in the delegating <code>Gui.Builder</code> method for it. Alternatively, you can also create the <code>SlotElement.InventorySlotElement</code> yourself.</p>"},{"location":"items/","title":"Items","text":"<p>In InvUI, the UI elements are just called <code>Item</code>s.  </p> <p>Every <code>Item</code> has an <code>ItemProvider</code> which returns <code>ItemStacks</code> based on a locale. This behavior allows for easy localization of UI elements, as you can show the same <code>Item</code> and <code>Gui</code> instances to multiple players while still having everything translated into their respective languages.</p> <p>Unlike other inventory libraries, InvUI does not redraw items every tick. To trigger an update, call <code>item.notifyWindows();</code>. This will notify all <code>Windows</code> that are currently displaying that <code>Item</code> to call <code>Item#getItemProvider</code> and <code>ItemProvider#get</code> and display the updated item to their viewer.</p>"},{"location":"items/#default-itemproviders","title":"Default ItemProviders","text":"<p>InvUI comes with two default implementations of <code>ItemProvider</code>: <code>ItemWrapper</code> and <code>ItemBuilder</code>. <code>ItemWrapper</code> just wraps an existing <code>ItemStack</code> and returns it when asked, <code>ItemBuilder</code> allows you to create <code>ItemStacks</code> using a builder pattern with localization support through translatable components.</p>"},{"location":"items/#default-ui-items-in-invui","title":"Default UI Items in InvUI","text":"<p>InvUI provides a few basic items, but you will probably have to create your own ones for more complicated behavior.</p> Item Description AsyncItem Creates it's ItemProvider asynchronously and displays a placeholder ItemProvider until the task is done. AutoCycleItem Automatically cycles between an array of ItemProviders. AutoUpdateItem Automatically updates its ItemProvider on a timer. CommandItem Makes the player execute a command or write a message in chat when clicked. CycleItem Cycles through an array of ItemProviders when clicked. SimpleItem Just displays an ItemProvider. SuppliedItem Displays an ItemProvider from a Supplier. <p>If you don't need any behavior at all and just want to make your <code>GUI</code> look pretty, you can use the <code>SimpleItem</code>. It cannot update it's <code>ItemProvider</code> later on and does not have any on-click functionality.</p>"},{"location":"items/#creating-your-own-item","title":"Creating your own Item","text":"<p>To create your own Item, you'll need to inherit from either <code>AbstractItem</code> (if you want to be able to change its appearance) or <code>SimpleItem</code> (if you don't need to change its appearance). In this example, I inherited from <code>AbstractItem</code>. Every time a player clicks on the Item, a counter will be incremented and the number on the Item will change.</p> KotlinJava <pre><code>class CountItem : AbstractItem() {\n\n    private var count = 0\n\n    override fun getItemProvider(): ItemProvider {\n        return ItemBuilder(Material.DIAMOND).setDisplayName(\"Count: $count\")\n    }\n\n    override fun handleClick(clickType: ClickType, player: Player, event: InventoryClickEvent) {\n        if (clickType.isLeftClick) {\n            count++ // increment if left click\n        } else {\n            count-- // else decrement\n        }\n        notifyWindows() // this will update the ItemStack that is displayed to the player\n    }\n\n}\n</code></pre> <pre><code>public class CountItem extends AbstractItem {\n\n    private int count;\n\n    @Override\n    public ItemProvider getItemProvider() {\n        return new ItemBuilder(Material.DIAMOND).setDisplayName(\"Count: \" + count);\n    }\n\n    @Override\n    public void handleClick(@NotNull ClickType clickType, @NotNull Player player, @NotNull InventoryClickEvent event) {\n        if (clickType.isLeftClick()) {\n            count++; // increment if left click\n        } else {\n            count--; // else decrement\n        }\n\n        notifyWindows(); // this will update the ItemStack that is displayed to the player\n    }\n\n}\n</code></pre> <p>After adding the Item to the GUI, it will look like this: </p>"},{"location":"items/#controlitems","title":"ControlItems","text":"<p>A <code>ControlItem</code> is a special sort of <code>Item</code>: When it is added to a <code>GUI</code>, the <code>GUI</code> will be saved inside the <code>ControlItem</code>. You can also manually assign a GUI to a <code>ControlItem</code> by calling <code>ControlItem#setGUI</code>. So, what are <code>ControlItems</code> used for? You guessed it, controlling <code>GUIs</code>. Page switching buttons are one example, as they need to call <code>PagedGUI#goForward</code> and <code>PagedGUI#goBack</code> which would not be possible without having the instance of the <code>GUI</code> to control saved somewhere.</p> <p>This would be a simple implementation of <code>ControlItem</code> for a paged GUI:</p> KotlinJava <pre><code>class ChangePageItem : ControlItem&lt;PagedGui&lt;*&gt;&gt;() {\n\n    override fun handleClick(clickType: ClickType, player: Player, event: InventoryClickEvent) {\n        if (clickType == ClickType.LEFT) {\n            gui.goForward() // go one page forward on left-click\n        } else if (clickType == ClickType.RIGHT) {\n            gui.goBack() // go one page back on right-click\n        }\n    }\n\n    override fun getItemProvider(gui: PagedGui&lt;*&gt;): ItemProvider {\n        return ItemBuilder(Material.BLACK_STAINED_GLASS_PANE)\n            .setDisplayName(\"Current page: \" + (gui.currentPage + 1)) // + 1 because we don't want to have \"Current page: 0\"\n            .addLoreLines(\"Left-click to go forward\", \"Right-click to go back\")\n    }\n\n}\n</code></pre> <pre><code>public class ChangePageItem extends ControlItem&lt;PagedGui&lt;?&gt;&gt; {\n\n    @Override\n    public void handleClick(@NotNull ClickType clickType, @NotNull Player player, @NotNull InventoryClickEvent event) {\n        if (clickType == ClickType.LEFT) {\n            getGui().goForward(); // go one page forward on left-click\n        } else if (clickType == ClickType.RIGHT) {\n            getGui().goBack(); // go one page back on right-click\n        }\n    }\n\n    @Override\n    public ItemProvider getItemProvider(PagedGui&lt;?&gt; gui) {\n        return new ItemBuilder(Material.BLACK_STAINED_GLASS_PANE)\n            .setDisplayName(\"Current page: \" + (gui.getCurrentPage() + 1)) // + 1 because we don't want to have \"Current page: 0\"\n            .addLoreLines(\"Left-click to go forward\", \"Right-click to go back\");\n    }\n\n}\n</code></pre> <p>The <code>getItemProvider</code> method will get called when the page changes, as <code>PagedGui</code> internally calls <code>AbstractGui#updateControlItems</code>, so the displayed page number in this example item will always be correct.</p>"},{"location":"localization/","title":"Localization","text":"<p>InvUI makes it easy for you to translate your GUIs into different languages.</p>"},{"location":"localization/#adding-translations","title":"Adding translations","text":"<p>To add translations for a new language, you can call <code>Languages.getInstance().addLanguage(String lang, Map&lt;String, String&gt; translations)</code>. The <code>lang</code> parameter is the language code of the language you want to add. The <code>translations</code> parameter should be a map containing the translation keys and their translations.</p> <p>If your translations are stored in a json structure like this:</p> en_us.json<pre><code>{\n  \"translation.key\": \"Hello World\",\n  \"other.translation.key\": \"Hello World 2\"\n}\n</code></pre> <p>You can also load them using <code>Languages#loadLanguage</code>:</p> KotlinJava <pre><code>Languages.getInstance().loadLanguage(\"en_us\", File(\"en_us.json\"), Charsets.UTF_8)\n</code></pre> <pre><code>Languages.getInstance().loadLanguage(\"en_us\", new File(\"en_us.json\"), StandardCharsets.UTF_8);\n</code></pre>"},{"location":"localization/#specifying-player-language","title":"Specifying Player language","text":"<p>By default, the player's locale is retrieved using <code>Player.getLocale();</code>. If you want to change this behavior, you can do so by calling <code>Languages#setLanguageProvider</code>:</p> KotlinJava <pre><code>Languages.getInstance().setLanguageProvider(Player::getLocale)\n</code></pre> <pre><code>Languages.getInstance().setLanguageProvider(Player::getLocale);\n</code></pre>"},{"location":"localization/#using-translations","title":"Using translations","text":"<p>To use translations in your GUIs, simply use translatable components using either md_5's bungee component api or kyori's adventure text api. If you're not using Kotlin and the <code>invui-kotlin</code> module, you'll need to wrap adventure components using the <code>AdventureComponentWrapper</code> class before you can pass them to the <code>ItemBuilder</code> or <code>Window.Builder</code>.</p> <p>When are translations applied?</p> <p>Translations are applied server-side. This is done during <code>ItemBuilder.get();</code> or, for the inventory title, <code>Window.open();</code>. If you need to use server-side translations in other places, you'll need to manually call <code>ComponentWrapper.localized(String locale);</code>.</p>"},{"location":"localization/#disabling-server-side-translations","title":"Disabling server-side translations","text":"<p>If you do not want your items and GUIs to be translated server-side and instead want to actually send translatable components to your players, you can disable server-side translations by calling <code>Languages.getInstance().enableServerSideTranslations(false);</code>.</p>"},{"location":"structure/","title":"Structure","text":""},{"location":"structure/#creating-and-using-structures","title":"Creating and using Structures","text":"<p>Inspired by Bukkit's ShapedRecipe, a Structure will let you design the layout of the GUI in a similar way. Each ingredient is associated with a character and you \"draw\" the GUI in your code.</p> <p>This is an example I stole from the Paged GUI section:</p> KotlinJava <pre><code>// create a structure\nval structure = Structure(\n    \"# # # # # # # # #\",\n    \"# x x x x x x x #\",\n    \"# x x x x x x x #\",\n    \"# # # &lt; # &gt; # # #\")\n    .addIngredient('x', Markers.CONTENT_LIST_SLOT_HORIZONTAL) // where paged items should be put\n    .addIngredient('#', ItemBuilder(Material.BLACK_STAINED_GLASS_PANE).setDisplayName(\"\")) // this will just create a SimpleItem with the given ItemBuilder\n    .addIngredient('&lt;', BackItem())\n    .addIngredient('&gt;', ForwardItem())\n\n// use it in a GUI Builder\nPagedGui.items().setStructure(structure)\n\n// or use it on an existing GUI\ngui.applyStructure(structure)\n</code></pre> <pre><code>// create a structure\nStructure structure = new Structure(\n    \"# # # # # # # # #\",\n    \"# x x x x x x x #\",\n    \"# x x x x x x x #\",\n    \"# # # &lt; # &gt; # # #\")\n    .addIngredient('x', Markers.CONTENT_LIST_SLOT_HORIZONTAL) // where paged items should be put\n    .addIngredient('#', new ItemBuilder(Material.BLACK_STAINED_GLASS_PANE).setDisplayName(\"\")) // this will just create a SimpleItem with the given ItemBuilder\n    .addIngredient('&lt;', new BackItem())\n    .addIngredient('&gt;', new ForwardItem());\n\n// use it in a GUI Builder\nPagedGui.items().setStructure(structure);\n\n// or use it on an existing GUI\ngui.applyStructure(structure);\n</code></pre> <p>As you can see, there are many types of ingredients that can be added: <code>Items</code>, <code>Item Supplier</code>, <code>SlotElement</code>, <code>SlotElement Supplier</code>, <code>VirtualInventory</code>, <code>Marker</code>. When using an <code>Item</code> or `SlotElement as ingredient, the same instance will be used on every slot. If you don't want this, use an Item Supplier. This will create a new instance for every slot.</p>"},{"location":"structure/#global-ingredients","title":"Global Ingredients","text":"<p>If you're reusing the same ingredients over and over again, consider registering them as global ingredients. Make sure to use suppliers for every item where you want a new instance per slot.</p> KotlinJava <pre><code>// Supplier is not needed here as the Item does not do anything\nStructure.addGlobalIngredient('#', ItemBuilder(Material.BLACK_STAINED_GLASS_PANE).setDisplayName(\"\"))\n\n// These items need a supplier\nStructure.addGlobalIngredient('&lt;', ::BackItem)\nStructure.addGlobalIngredient('&gt;', ::ForwardItem)\n\n// Adding the Markers.CONTENT_LIST_SLOT_HORIZONTAL as a global ingredient is also a good idea\nStructure.addGlobalIngredient('x', Markers.CONTENT_LIST_SLOT_HORIZONTAL)\n</code></pre> <pre><code>// Supplier is not needed here as the Item does not do anything\nStructure.addGlobalIngredient('#', new ItemBuilder(Material.BLACK_STAINED_GLASS_PANE).setDisplayName(\"\"));\n\n// These items need a supplier because ControlItems can only control one GUI\nStructure.addGlobalIngredient('&lt;', BackItem::new);\nStructure.addGlobalIngredient('&gt;', ForwardItem::new);\n\n// Adding the Markers.CONTENT_LIST_SLOT_HORIZONTAL as a global ingredient is also a good idea\nStructure.addGlobalIngredient('x', Markers.CONTENT_LIST_SLOT_HORIZONTAL);\n</code></pre>"},{"location":"windows/","title":"Windows","text":""},{"location":"windows/#what-is-a-window-in-invui","title":"What is a Window in InvUI?","text":"<p>In InvUI, windows represent the actual Minecraft inventories that are displayed to the player. Depending on the type of window, they display one or two GUI(s).</p> <p>A window can only have one viewer. This is because InvUI's GUIs are designed to be easy to translate. Up until this point, we've only dealt with <code>ItemProviders</code>, which unlike <code>ItemStacks</code> have a method to retrieve the represented <code>ItemStack</code> with a language code for translation purposes. Now, the window is the first part in the chain that uses <code>ItemStacks</code> - and as these are already translated to a specific language, allowing multiple people to view the same window might cause one of them to see the wrong language.</p>"},{"location":"windows/#list-of-window-types","title":"List of Window types","text":"Name Builder Factory Function Description Normal Single Window <code>Window.single()</code> The default chest / dropper / hopper inventory, chosen depending on the dimensions of the GUI. The player's inventory stays untouched. Normal Merged Window <code>Window.merged()</code> The default chest inventory and the player's inventory are filled by the same GUI. Normal Split Window <code>Window.split()</code> The default chest / dropper / hopper inventory, chosen depending on the dimensions of the first GUI. The player's inventory is filled by the second GUI. Anvil Single Window <code>AnvilWindow.single()</code> An anvil inventory. The player's inventory stays untouched. Anvil Split Window <code>AnvilWindow.split()</code> The anvil inventory is filled by the first GUI. The player's inventory is filled by the second GUI. Cartography Single Window <code>CartographyWindow.single()</code> The inventory of the cartography table. The player's inventory stays untouched. Cartography Split Window <code>CartographyWindow.split()</code> The inventory of the cartography table is filled by the first GUI. The player's inventory is filled by the second GUI. <p>Generally, there are three different categories of windows: single, split and merged. Single windows do not use the player's own inventory. Split windows use one GUI for the upper inventory and another GUI for the player's inventory (9x4). Merged windows use the same GUI for the upper and lower inventory.</p> <p>When using merged or split windows:</p> <ul> <li>The contents of the player's inventory are saved and restored after the inventory has been closed</li> <li>The player is not able to pick up any items</li> <li>The player will not be able to trigger advancements</li> </ul>"},{"location":"windows/#anvilwindow","title":"AnvilWindow","text":"<p>The rename-text can be retrieved by calling <code>AnvilInventory#getRenameText()</code>. It is also possible to set one or multiple <code>Consumer&lt;String&gt; renameHandler</code> in the <code>WindowBuilder</code>, which will then be called every time the rename-text is changed.</p>"},{"location":"windows/#cartographywindow","title":"CartographyWindow","text":"<p>To update the map preview, you can use the methods <code>updateMap(MapPatch)</code>, <code>updateMap(List&lt;MapIcon&gt;)</code> and <code>resetMap()</code>.</p> <p>Please note that the first slot of the cartography inventory is not accessible to you, as it is required to contain a map item for the map preview to work. Therefore, your GUI's size has to be 2x1 instead of 3x1.</p>"},{"location":"windows/#creating-a-new-window","title":"Creating a new Window","text":"<p>To create a new <code>Window</code>, you'll need to use the <code>Window.Builder</code> for your desired window type which can be obtained by calling the static builder factory function in the related <code>Window</code> interface. (See table above)</p> KotlinJava <pre><code>val normalWindow = Window.single()\n    .setViewer(player)\n    .setGui(gui)\n    .setTitle(\"InvUI\")\n    .build()\n\nval anvilWindow = AnvilWindow.split()\n    .setViewer(player)\n    .setUpperGui(anvilGui)\n    .setLowerGui(playerGui)\n    .setTitle(\"InvUI\")\n    .addRenameHandler { println(it) }\n    .build()\n</code></pre> <pre><code>Window window = Window.single()\n    .setViewer(player)\n    .setGui(gui)\n    .setTitle(\"InvUI\")\n    .build();\n\nAnvilWindow window = AnvilWindow.split()\n    .setViewer(player)\n    .setUpperGui(anvilGui)\n    .setLowerGui(playerGui)\n    .setTitle(\"InvUI\")\n    .addRenameHandler(s -&gt; System.out.println(s))\n    .build();\n</code></pre>"},{"location":"windows/#opening-a-window","title":"Opening a Window","text":"<p>To show a <code>Window</code> to a player, you'll need to call <code>Window.open();</code>.</p> KotlinJava <pre><code>window.open()\n</code></pre> <pre><code>window.open();\n</code></pre> <p>As a shortcut, you can also directly call <code>.open(player)</code> on the <code>Window.Builder</code>. This will create a new <code>Window</code> and then directly show it to the specified player.</p> KotlinJava <pre><code>Window.single()\n    .setGui(gui)\n    .setTitle(\"InvUI\")\n    .open(player)\n</code></pre> <pre><code>Window.single()\n    .setGui(gui)\n    .setTitle(\"InvUI\")\n    .open(player);\n</code></pre> <p>Alternatively, you can also call <code>.build(player)</code> on the <code>Window.Builder</code> to build a new <code>Window</code> for a specified player.</p> KotlinJava <pre><code>val window = Window.single()\n    .setGui(gui)\n    .setTitle(\"InvUI\")\n    .build(player)\n\nwindow.open()\n</code></pre> <pre><code>Window window = Window.single()\n    .setGui(gui)\n    .setTitle(\"InvUI\")\n    .build(player);\n\nwindow.open();\n</code></pre>"},{"location":"guis/","title":"Overview","text":""},{"location":"guis/#what-is-a-gui-in-invui","title":"What is a GUI in InvUI?","text":"<p>A GUI is basically a container for width * height SlotElements. Each SlotElement can either be an Item, a reference to another GUI or a reference to a VirtualInventory.</p> <p>Items and other SlotElements can be added using <code>gui.setItem(x, y, item);</code>, <code>gui.setItem(index, item);</code> or by using a Structure and applying that to the GUI <code>gui.applyStructure(structure);</code>.</p> <p>GUIs cannot display anything to a player, a Window is used for that.</p>"},{"location":"guis/#different-types-of-guis","title":"Different types of GUIs","text":"<p>There are four different GUI types available:</p> Gui Type Builder Factory Function(s) Description Normal GUI <code>Gui.normal()</code> A normal GUI without any special functionality. Paged GUI <code>PagedGui.items()</code>, <code>PagedGui.guis()</code> A GUI with paging functionality. You can either provide a list of <code>Items</code> that should be shown on the pages or directly provide the pages (as <code>Guis</code>) themselves. Scroll GUI <code>ScrollGui.items()</code>, <code>ScrollGui.guis()</code>, <code>ScrollGui.inventories()</code> A GUI with scrolling functionality. You can scroll through <code>Items</code>, <code>Guis</code> or <code>Inventories</code> Tab GUI <code>TabGui.normal()</code> A GUI with tabs. Each tab is associated to a <code>Gui</code>, you can switch between tabs using tab items."},{"location":"guis/#animations","title":"Animations","text":"<p>GUIs can also play animations with <code>gui.playAnimation(animation);</code>. While an animation is running, the player can't interact with any Item in the GUI.</p> <p>Available Animations:</p> <ul> <li>SequentialAnimation</li> <li>SplitSequentialAnimation</li> <li>HorizontalSnakeAnimation</li> <li>VerticalSnakeAnimation</li> <li>RowAnimation</li> <li>ColumnAnimation</li> <li>RandomAnimation</li> </ul> <p>To cancel a running animation, use <code>gui.cancelAnimation();</code></p>"},{"location":"guis/#filling-methods","title":"Filling methods","text":"<p>There are also some utility methods for filling available:</p> KotlinJava <pre><code>gui.fill(item, replace) // fills everything\ngui.fill(start, end, item, replace) // fills from the start index to the end index\ngui.fillColumn(column, item, replace) // fills a column\ngui.fillRow(row, item, replace) // fills a row\ngui.fillBorders(item, replace) // fill the borders\ngui.fillRectangle(x, y, width, height, item, replace) // fills a rectangle with an Item\n\ngui.fillRectangle(x, y, gui, replace) // fills a rectangle with another GUI\ngui.fillRectangle(x, y, width, virtualInventory, replace) // fills a rectangle with a VirtualInventory\n</code></pre> <pre><code>gui.fill(item, replace); // fills everything\ngui.fill(start, end, item, replace); // fills from the start index to the end index\ngui.fillColumn(column, item, replace); // fills a column\ngui.fillRow(row, item, replace); // fills a row\ngui.fillBorders(item, replace); // fill the borders\ngui.fillRectangle(x, y, width, height, item, replace); // fills a rectangle with an Item\n\ngui.fillRectangle(x, y, gui, replace); // fills a rectangle with another GUI\ngui.fillRectangle(x, y, width, virtualInventory, replace); // fills a rectangle with a VirtualInventory\n</code></pre>"},{"location":"guis/#background-item","title":"Background Item","text":"<p>Every GUI can also have an <code>ItemProvider</code> as the background. This background Item will be shown when there is nothing occupying that slot. It can be useful for dealing with paged GUIs if you don't want any blank spots in your inventory. You can set the background via:</p> KotlinJava <pre><code>gui.setBackground(itemProvider)\n</code></pre> <pre><code>gui.setBackground(itemProvider);\n</code></pre>"},{"location":"guis/normal/","title":"Normal GUI","text":"<p>Just a normal GUI without any special functionality. This example shows how to create one using the GuiBuilder:</p> KotlinJava <pre><code>val border = SimpleItem(ItemBuilder(Material.BLACK_STAINED_GLASS_PANE))\nval gui = Gui.normal()\n    .setStructure(\n        \"# # # # # # # # #\",\n        \"# . . . . . . . #\",\n        \"# . . . . . . . #\",\n        \"# # # # # # # # #\")\n    .addIngredient('#', border)\n    .build()\n</code></pre> <pre><code>Item border = new SimpleItem(new ItemBuilder(Material.BLACK_STAINED_GLASS_PANE));\nGui gui = Gui.normal()\n    .setStructure(\n        \"# # # # # # # # #\",\n        \"# . . . . . . . #\",\n        \"# . . . . . . . #\",\n        \"# # # # # # # # #\")\n    .addIngredient('#', border)\n    .build();\n</code></pre> <p></p>"},{"location":"guis/paged/","title":"Paged GUI","text":"<p>A paged GUI is a gui that can display pages of either <code>Items</code> or <code>Guis</code>.  </p>"},{"location":"guis/paged/#control-items","title":"Control Items","text":"<p>First, we'll need to create the page switching buttons. This is an example for a \"Page Back\" Item:</p> KotlinJava <pre><code>class BackItem : PageItem(false) {\n\n    override fun getItemProvider(gui: PagedGui&lt;*&gt;): ItemProvider {\n        val builder = ItemBuilder(Material.RED_STAINED_GLASS_PANE)\n        builder.setDisplayName(\"Previous page\")\n            .addLoreLines(\n                if (gui.hasPreviousPage())\n                    \"Go to page \" + gui.currentPage + \"/\" + gui.pageAmount \n                else \"You can't go further back\"\n            )\n        return builder\n    }\n\n}\n</code></pre> <pre><code>public class BackItem extends PageItem {\n\n    public BackItem() {\n        super(false);\n    }\n\n    @Override\n    public ItemProvider getItemProvider(PagedGui&lt;?&gt; gui) {\n        ItemBuilder builder = new ItemBuilder(Material.RED_STAINED_GLASS_PANE);\n        builder.setDisplayName(\"Previous page\")\n            .addLoreLines(gui.hasPreviousPage()\n                ? \"Go to page \" + gui.getCurrentPage() + \"/\" + gui.getPageAmount()\n                : \"You can't go further back\");\n\n        return builder;\n    }\n\n}\n</code></pre> <p>This is an example for a \"Page Forward\" Item:</p> KotlinJava <pre><code>class ForwardItem : PageItem(true) {\n\n    override fun getItemProvider(gui: PagedGui&lt;*&gt;): ItemProvider {\n        val builder = ItemBuilder(Material.GREEN_STAINED_GLASS_PANE)\n        builder.setDisplayName(\"Next page\")\n            .addLoreLines(\n                if (gui.hasNextPage())\n                    \"Go to page \" + (gui.currentPage + 2) + \"/\" + gui.pageAmount \n                else \"There are no more pages\"\n            )\n        return builder\n    }\n\n}\n</code></pre> <pre><code>public class ForwardItem extends PageItem {\n\n    public ForwardItem() {\n        super(true);\n    }\n\n    @Override\n    public ItemProvider getItemProvider(PagedGui&lt;?&gt; gui) {\n        ItemBuilder builder = new ItemBuilder(Material.GREEN_STAINED_GLASS_PANE);\n        builder.setDisplayName(\"Next page\")\n            .addLoreLines(gui.hasNextPage()\n                ? \"Go to page \" + (gui.getCurrentPage() + 2) + \"/\" + gui.getPageAmount()\n                : \"There are no more pages\");\n\n        return builder;\n    }\n\n}\n</code></pre> <p>More information about ControlItems in the Items section.</p> <p>Info</p> <p>You also might want to register these Items as global ingredients.</p>"},{"location":"guis/paged/#creating-the-gui","title":"Creating the GUI","text":""},{"location":"guis/paged/#paged-items","title":"Paged Items","text":"<p>Now that we've created the ControlItems, let's make the actual GUI:</p> KotlinJava <pre><code>val border = SimpleItem(ItemBuilder(Material.BLACK_STAINED_GLASS_PANE).setDisplayName(\"\"))\n\n// an example list of items to display\nval items = Material.values()\n    .filter { !it.isAir &amp;&amp; it.isItem }\n    .map { SimpleItem(ItemBuilder(it)) }\n\n// create the gui\nval gui = PagedGui.items()\n    .setStructure(\n        \"# # # # # # # # #\",\n        \"# x x x x x x x #\",\n        \"# x x x x x x x #\",\n        \"# # # &lt; # &gt; # # #\")\n    .addIngredient('x', Markers.CONTENT_LIST_SLOT_HORIZONTAL) // where paged items should be put\n    .addIngredient('#', border)\n    .addIngredient('&lt;', BackItem())\n    .addIngredient('&gt;', ForwardItem())\n    .setContent(items)\n    .build()\n</code></pre> <pre><code>Item border = new SimpleItem(new ItemBuilder(Material.BLACK_STAINED_GLASS_PANE).setDisplayName(\"\"));\n\n// an example list of items to display\nList&lt;Item&gt; items = Arrays.stream(Material.values())\n    .filter(material -&gt; !material.isAir() &amp;&amp; material.isItem())\n    .map(material -&gt; new SimpleItem(new ItemBuilder(material)))\n    .collect(Collectors.toList());\n\n// create the gui\nGui gui = PagedGui.items()\n    .setStructure(\n        \"# # # # # # # # #\",\n        \"# x x x x x x x #\",\n        \"# x x x x x x x #\",\n        \"# # # &lt; # &gt; # # #\")\n    .addIngredient('x', Markers.CONTENT_LIST_SLOT_HORIZONTAL) // where paged items should be put\n    .addIngredient('#', border)\n    .addIngredient('&lt;', new BackItem())\n    .addIngredient('&gt;', new ForwardItem())\n    .setContent(items)\n    .build();\n</code></pre> <p>In-game, it will look like this: </p>"},{"location":"guis/paged/#paged-guis","title":"Paged GUIs","text":"<p>Instead of using Items, you can also use whole GUIs as pages. In the following example I used two slightly different versions of the GUI created above and added them as pages. Now I can switch between two paged GUIs.</p> KotlinJava <pre><code>val gui = PagedGui.guis()\n    .setStructure(\n        \"x x x x x x x x x\",\n        \"x x x x x x x x x\",\n        \"x x x x x x x x x\",\n        \"x x x x x x x x x\",\n        \". . &lt; . . . &gt; . .\")\n    .addIngredient('x', Markers.CONTENT_LIST_SLOT_HORIZONTAL) // where paged items should be put (in this case: the parts of the nested GUI)\n    .addIngredient('&lt;', BackItem())\n    .addIngredient('&gt;', ForwardItem())\n    .setContent(listOf(page1GUI, page2GUI))\n    .build()\n</code></pre> <pre><code>Gui gui = PagedGui.guis()\n    .setStructure(\n        \"x x x x x x x x x\",\n        \"x x x x x x x x x\",\n        \"x x x x x x x x x\",\n        \"x x x x x x x x x\",\n        \". . &lt; . . . &gt; . .\")\n    .addIngredient('x', Markers.CONTENT_LIST_SLOT_HORIZONTAL) // where paged items should be put (in this case: the parts of the nested GUI)\n    .addIngredient('&lt;', new BackItem())\n    .addIngredient('&gt;', new ForwardItem())\n    .setContent(Arrays.asList(page1GUI, page2GUI))\n    .build();\n</code></pre> <p>In-game it looks like this: </p>"},{"location":"guis/scroll/","title":"Scroll GUI","text":"<p>A Scroll GUI allows you to scroll through a list of items line by line. This can be done both vertically and horizontally.</p>"},{"location":"guis/scroll/#control-items","title":"Control Items","text":"<p>Before creating the Scroll GUI itself, you first need to create the Items for navigating it.</p> <p>This would be an example for an Item that scrolls down:</p> KotlinJava <pre><code>class ScrollDownItem : ScrollItem(1) {\n\n    override fun getItemProvider(gui: ScrollGui&lt;*&gt;): ItemProvider {\n        val builder = ItemBuilder(Material.GREEN_STAINED_GLASS_PANE)\n        builder.setDisplayName(\"Scroll down\")\n        if (!gui.canScroll(1))\n            builder.addLoreLines(\"You can't scroll further down\")\n        return builder\n    }\n\n}\n</code></pre> <pre><code>public class ScrollDownItem extends ScrollItem {\n\n    public ScrollDownItem() {\n        super(1);\n    }\n\n    @Override\n    public ItemProvider getItemProvider(ScrollGui&lt;?&gt; gui) {\n        ItemBuilder builder = new ItemBuilder(Material.GREEN_STAINED_GLASS_PANE);\n        builder.setDisplayName(\"Scroll down\");\n        if (!gui.canScroll(1))\n            builder.addLoreLines(\"You can't scroll further down\");\n\n        return builder;\n    }\n\n}\n</code></pre> <p>And this Item scrolls up:</p> KotlinJava <pre><code>class ScrollUpItem : ScrollItem(-1) {\n\n    override fun getItemProvider(gui: ScrollGui&lt;*&gt;): ItemProvider {\n        val builder = ItemBuilder(Material.RED_STAINED_GLASS_PANE)\n        builder.setDisplayName(\"Scroll up\")\n        if (!gui.canScroll(-1))\n            builder.addLoreLines(\"You've reached the top\")\n        return builder\n    }\n\n}\n</code></pre> <pre><code>    public class ScrollUpItem extends ScrollItem {\n\n    public ScrollUpItem() {\n        super(-1);\n    }\n\n    @Override\n    public ItemProvider getItemProvider(ScrollGui&lt;?&gt; gui) {\n        ItemBuilder builder = new ItemBuilder(Material.RED_STAINED_GLASS_PANE);\n        builder.setDisplayName(\"Scroll up\");\n        if (!gui.canScroll(-1))\n            builder.addLoreLines(\"You've reached the top\");\n\n        return builder;\n    }\n\n}\n</code></pre> <p>Info</p> <p>You also might want to register these Items as global ingredients.</p>"},{"location":"guis/scroll/#creating-the-gui","title":"Creating the GUI","text":""},{"location":"guis/scroll/#scroll-items","title":"Scroll Items","text":"<p>Now that we've created the ControlItems, let's make the actual GUI:</p> KotlinJava <pre><code>val border = SimpleItem(ItemBuilder(Material.BLACK_STAINED_GLASS_PANE).setDisplayName(\"\"))\n\n// an example list of items to display\nval items = Material.values()\n    .filter { !it.isAir &amp;&amp; it.isItem }\n    .map { SimpleItem(ItemBuilder(it)) }\n\nval gui = ScrollGui.items()\n    .setStructure(\n        \"x x x x x x x x u\",\n        \"x x x x x x x x #\",\n        \"x x x x x x x x #\",\n        \"x x x x x x x x #\",\n        \"x x x x x x x x d\")\n    .addIngredient('x', Markers.CONTENT_LIST_SLOT_HORIZONTAL)\n    .addIngredient('#', border)\n    .addIngredient('u', ScrollUpItem())\n    .addIngredient('d', ScrollDownItem())\n    .setContent(items)\n    .build()\n</code></pre> <pre><code>Item border = new SimpleItem(new ItemBuilder(Material.BLACK_STAINED_GLASS_PANE).setDisplayName(\"\"));\n\n// an example list of items to display\nList&lt;Item&gt; items = Arrays.stream(Material.values())\n    .filter(material -&gt; !material.isAir() &amp;&amp; material.isItem())\n    .map(material -&gt; new SimpleItem(new ItemBuilder(material)))\n    .collect(Collectors.toList());\n\nGui gui = ScrollGui.items()\n    .setStructure(\n        \"x x x x x x x x u\",\n        \"x x x x x x x x #\",\n        \"x x x x x x x x #\",\n        \"x x x x x x x x #\",\n        \"x x x x x x x x d\")\n    .addIngredient('x', Markers.CONTENT_LIST_SLOT_HORIZONTAL)\n    .addIngredient('#', border)\n    .addIngredient('u', new ScrollUpItem())\n    .addIngredient('d', new ScrollDownItem())\n    .setContent(items)\n    .build();\n</code></pre> <p>And this is how it looks in-game: </p> <p>You can also change the scroll direction by using <code>Markers.CONTENT_LIST_SLOT_VERTICAL</code> instead of <code>Markers.CONTENT_LIST_SLOT_HORIZONTAL</code>. This would result in the gui scrolling from left to right: </p> <p>Info</p> <p>If you need even more control over the scroll direction, you'll need to set the <code>itemListSlots</code> yourself by calling the ScrollGui.of method.</p>"},{"location":"guis/scroll/#scrollguigui-scrollguivirtualinventory","title":"<code>ScrollGui&lt;Gui&gt;</code> &amp; <code>ScrollGui&lt;VirtualInventory&gt;</code>","text":"<p>There are two additional Scroll GUI types available: <code>ScrollGui.guis()</code> and <code>ScrollGui.inventories()</code>. They behave in a very similar way to <code>ScrollGui.items()</code>, but instead of Items, they accept GUIs or Inventories. For the case of <code>ScrollGui&lt;Gui&gt;</code>, you'll want to make sure that the width of the GUIs matches the line size of your Scroll GUI.</p>"},{"location":"guis/tab/","title":"Tab GUI","text":"<p>A Tab GUI lets you switch between different GUIs (tabs) by clicking the Tab Items associated with them.</p>"},{"location":"guis/tab/#control-items","title":"Control Items","text":"<p>First, we'll need to create our Tab Items:</p> KotlinJava <pre><code>class MyTabItem(private val tab: Int) : TabItem(tab) {\n\n    override fun getItemProvider(gui: TabGui): ItemProvider {\n        return if (gui.currentTab == tab) {\n            ItemBuilder(Material.GLOWSTONE_DUST)\n                .setDisplayName(\"Tab $tab (selected)\")\n        } else {\n            ItemBuilder(Material.GUNPOWDER)\n                .setDisplayName(\"Tab $tab (not selected)\")\n        }\n    }\n\n}\n</code></pre> <pre><code>public class MyTabItem extends TabItem {\n\n    private final int tab;\n\n    public MyTabItem(int tab) {\n        super(tab);\n        this.tab = tab;\n    }\n\n    @Override\n    public ItemProvider getItemProvider(TabGui gui) {\n        if (gui.getCurrentTab() == tab) {\n            return new ItemBuilder(Material.GLOWSTONE_DUST)\n                .setDisplayName(\"Tab \" + tab + \" (selected)\");\n        } else {\n            return new ItemBuilder(Material.GUNPOWDER)\n                .setDisplayName(\"Tab \" + tab + \" (not selected)\");\n        }\n    }\n\n}\n</code></pre>"},{"location":"guis/tab/#creating-the-gui","title":"Creating the GUI","text":"<p>Now, lets create the actual TabGui. In this example, I've only created two tabs, but you can have as many tabs as you want.</p> KotlinJava <pre><code>val border = SimpleItem(ItemBuilder(Material.BLACK_STAINED_GLASS_PANE).setDisplayName(\"\"))\n\nval gui1 = Guis.empty(9, 3)\ngui1.fill(SimpleItem(ItemBuilder(Material.DIRT)), true)\n\nval gui2 = Guis.empty(9, 3)\ngui2.fill(SimpleItem(ItemBuilder(Material.DIAMOND)), true)\n\nval gui = TabGui.normal()\n    .setStructure(\n        \"# # # 0 # 1 # # #\",\n        \"x x x x x x x x x\",\n        \"x x x x x x x x x\",\n        \"x x x x x x x x x\")\n    .addIngredient('x', Markers.CONTENT_LIST_SLOT_HORIZONTAL)\n    .addIngredient('#', border)\n    .addIngredient('0', MyTabItem(0))\n    .addIngredient('1', MyTabItem(1))\n    .setTabs(listOf(gui1, gui2))\n    .build()\n</code></pre> <pre><code>Item border = new SimpleItem(new ItemBuilder(Material.BLACK_STAINED_GLASS_PANE).setDisplayName(\"\"));\n\nGui gui1 = Guis.empty(9, 3);\ngui1.fill(new SimpleItem(new ItemBuilder(Material.DIRT)), true);\n\nGui gui2 = Guis.empty(9, 3);\ngui2.fill(new SimpleItem(new ItemBuilder(Material.DIAMOND)), true);\n\nGui gui = TabGui.normal()\n    .setStructure(\n        \"# # # 0 # 1 # # #\",\n        \"x x x x x x x x x\",\n        \"x x x x x x x x x\",\n        \"x x x x x x x x x\")\n    .addIngredient('x', Markers.CONTENT_LIST_SLOT_HORIZONTAL)\n    .addIngredient('#', border)\n    .addIngredient('0', new MyTabItem(0))\n    .addIngredient('1', new MyTabItem(1))\n    .setTabs(Arrays.asList(gui1, gui2))\n    .build();\n</code></pre> <p>And this is how it looks like: </p> <p>Info</p> <p>It is also possible to, for example, put the Tab Items in a separate paged or scroll gui if you need more space. For that to work, you'd need to set the TabGUI that the Tab items are supposed to control manually using <code>ControlItem#setGui</code>.</p>"}]}