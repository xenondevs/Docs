{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"InvUI","text":"<p>Minimum required Java version: <code>21</code></p> <p>Dropped multi-version and Spigot support in v2</p> <p>Starting with v2, InvUI no longer supports multiple Minecraft versions. Instead, InvUI only targets the latest Minecraft version. Additionally, InvUI no longer supports Spigot, but only Paper and its forks.</p> <p>Documentation is work in progress</p> <p>This documentation is still WIP. All code examples are currently Kotlin, the Java translations will be added in the future.</p>"},{"location":"#configuring-maven-gradle","title":"Configuring Maven / Gradle","text":"<p>To use InvUI, you first have to add the xenondevs maven repository to your build configuration.</p> Gradle KotlinGradle GroovyMaven <pre><code>maven(\"https://repo.xenondevs.xyz/releases\")\n</code></pre> <pre><code>maven {\n    url 'https://repo.xenondevs.xyz/releases'\n}\n</code></pre> <pre><code>&lt;repository&gt;\n    &lt;id&gt;xenondevs&lt;/id&gt;\n    &lt;url&gt;https://repo.xenondevs.xyz/releases&lt;/url&gt;\n&lt;/repository&gt;\n</code></pre> <p>Now you can add InvUI as a dependency:</p> Gradle KotlinGradle GroovyMaven <pre><code>implementation(\"xyz.xenondevs.invui:invui:VERSION\")\n</code></pre> <pre><code>implementation \"xyz.xenondevs.invui:invui:VERSION\"\n</code></pre> <pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;xyz.xenondevs.invui&lt;/groupId&gt;\n    &lt;artifactId&gt;invui&lt;/artifactId&gt;\n    &lt;version&gt;VERSION&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre> <p>To find the latest InvUI version, check out the GitHub Releases Page or explore the Maven Repository.</p>"},{"location":"#javadoc","title":"Javadoc","text":"<p>Not all functionality of InvUI is covered here. For a detailed overview of all classes and methods, take a look at the InvUI javadoc.</p>"},{"location":"declarative-menu-design/","title":"Declarative Menu Design","text":"<p>This functionality is experimental</p> <p>This functionality is exclusive to invui-kotlin</p> <p>Windows, Guis, and Items can be designed in a declarative-ish / reactive fashion.</p> <p>For that, InvUI uses <code>Provider&lt;T&gt;</code> and <code>MutableProvider&lt;T&gt;</code> from commons-provider.</p> <p>In a nutshell, with providers you can define a reactive data transformation flow:</p> <pre><code>val p = mutableProvider(\"Hello\")\nval p1 = p.map { \"$it, World!\" }\n\nprintln(p1.get()) // prints \"Hello, World!\"\n\np.set(\"Goodbye\")\n\nprintln(p1.get()) // prints \"Goodbye, World!\"\n</code></pre> <p>This is very useful for creating menus, as it removes the need for manual updates like <code>notifyWindows()</code> or <code>setContent()</code>.</p> <p>For example, the following menu automatically updates its search preview as the user types.</p> <pre><code>val search = mutableProvider(\"\")\nAnvilWindow.builder()\n    .addRenameHandler(search) // automatically writes text into search provider\n    .setLowerGui(PagedGui.itemsBuilder()\n        .setStructure(\n            \"x x x x x x x x x\",\n            \"x x x x x x x x x\",\n            \"x x x x x x x x x\",\n            \"x x x x x x x x x\"\n        )\n        .addIngredient('x', Markers.CONTENT_LIST_SLOT_HORIZONTAL)\n        .setContent(search) { search -&gt; // content updates based on search provider (1)\n            Material.entries\n                .filter { !it.isLegacy &amp;&amp; it.isItem }\n                .filter { it.name.contains(search, true) }\n                .map { Item.simple(ItemBuilder(it)) }\n        }\n    )\n    .open(player)\n</code></pre> <ol> <li>This is equivalent to:     <pre><code>setContent(search.map { search -&gt;\n    Material.entries\n        .filter { !it.isLegacy &amp;&amp; it.isItem }\n        .filter { it.name.contains(search, true) }\n        .map { Item.simple(ItemBuilder(it)) }\n})\n</code></pre></li> </ol> <p></p>"},{"location":"faq/","title":"FAQ","text":"<p>Nothing here yet</p>"},{"location":"gui/","title":"Gui","text":""},{"location":"gui/#what-is-a-gui","title":"What is a Gui?","text":"<p>In InvUI, a <code>Gui</code> is simply a rectangle of slots. Each slot can either be empty or contain something like an Item, a link to another Gui, or a link to an Inventory.</p>"},{"location":"gui/#gui-types","title":"Gui Types","text":""},{"location":"gui/#normal-gui","title":"Normal Gui","text":"<p>Using <code>Gui.builder()</code>, you can create a very simple Gui without any special functionality. With the gui builder, you can define a structure where each character corresponds to an ingredient, in this case the glass pane item.</p> <pre><code>val gui: Gui = Gui.builder()\n    .setStructure(\n        \"# # # # # # # # #\",\n        \"# x x x x x x x #\",\n        \"# x x x x x x x #\",\n        \"# x x x x x x x #\",\n        \"# # # # # # # # #\",\n    )\n    .addIngredient('#', Item.simple(ItemBuilder(Material.BLACK_STAINED_GLASS_PANE)))\n    .build()\n</code></pre> <p></p>"},{"location":"gui/#paged-gui","title":"Paged Gui","text":"<p>A <code>PagedGui</code> is a specialized gui type that has pages of content. This content can be either items, entire guis, or inventories. The following example will use items as content.</p> <p>Before creating a <code>PagedGui</code>, you must first create the page buttons with which the player is supposed to navigate it. For that, bound items are a useful tool. Using <code>BoundItem.pagedBuilder()</code>, you can create a builder for a bound item that targets paged guis. This item's <code>ItemProvider</code> will also automatically be updated when the current page or total page count changes:</p> <pre><code>val back: BoundItem = BoundItem.pagedBuilder()\n    .setItemProvider(ItemBuilder(Material.ARROW))\n    .addClickHandler { _, gui, _ -&gt; gui.page-- }\n    .build()\n\nval forward: BoundItem = BoundItem.pagedBuilder()\n    .setItemProvider(ItemBuilder(Material.ARROW))\n    .addClickHandler { _, gui, _ -&gt; gui.page++ }\n    .build()\n</code></pre> <p>When creating the <code>PagedGui</code>, you will need to tell InvUI where to put the page content. This is what <code>Markers.CONTENT_LIST_SLOT_HORIZONTAL</code> does. In the following example, the ingredient <code>x</code> is marked as a content list slot, i.e. a slot for page content. There is also <code>Markers.CONTENT_LIST_SLOT_VERTICAL</code>. The difference between the two is that with the <code>HORIZONTAL</code> marker, the slots are filled left-to-right row-by-row, whereas the <code>VERTICAL</code> marker orders the items top-down column-by-column.</p> <pre><code>val allTheItemTypes: List&lt;Item&gt; = Material.entries\n    .filter { !it.isLegacy &amp;&amp; it.isItem }\n    .map { Item.simple(ItemBuilder(it)) }\n\nval gui: PagedGui&lt;Item&gt; = PagedGui.itemsBuilder()\n    .setStructure(\n        \"# # # # # # # # #\",\n        \"# x x x x x x x #\",\n        \"# x x x x x x x #\",\n        \"# x x x x x x x #\",\n        \"# # # &lt; # &gt; # # #\",\n    )\n    .addIngredient('#', Item.simple(ItemBuilder(Material.BLACK_STAINED_GLASS_PANE)))\n    .addIngredient('x', Markers.CONTENT_LIST_SLOT_HORIZONTAL)\n    .addIngredient('&lt;', back)\n    .addIngredient('&gt;', forward)\n    .setContent(allTheItemTypes)\n    .build()\n</code></pre> <p></p> <p><code>Markers.CONTENT_LIST_SLOT_HORIZONTAL</code> vs. <code>Markers.CONTENT_LIST_SLOT_VERTICAL</code></p> <p>The above example uses <code>Markers.CONTENT_LIST_SLOT_HORIZONTAL</code>, but there is also <code>Markers.CONTENT_LIST_SLOT_VERTICAL</code>. The difference between the two is that with the <code>HORIZONTAL</code> marker, the slots are filled left-to-right row-by-row, whereas the <code>VERTICAL</code> marker orders the items top-down column-by-column.</p> Example: Page buttons with proper item names <p>The above example omits names from the navigation buttons for simplicity. In real-world cases, you will likely want to do something like this:</p> <pre><code>val back: BoundItem = BoundItem.pagedBuilder()\n    .setItemProvider { _, gui -&gt;\n        if (gui.page &gt; 0) {\n            ItemBuilder(Material.ARROW)\n                .setName(\"&lt;gray&gt;Move to page &lt;aqua&gt;${gui.page}&lt;gray&gt;/&lt;aqua&gt;${gui.pageCount}\") // (1)!\n        } else {\n            // no arrow if we can't go further back\n            ItemBuilder(Material.BLACK_STAINED_GLASS_PANE).hideTooltip(true)\n        }\n    }\n    .addClickHandler { _, gui, _ -&gt; gui.page-- }\n    .build()\n\nval forward: BoundItem = BoundItem.pagedBuilder()\n    .setItemProvider { _, gui -&gt;\n        if (gui.page &lt; gui.pageCount - 1) {\n            ItemBuilder(Material.ARROW)\n                .setName(\"&lt;gray&gt;Move to page &lt;aqua&gt;${gui.page + 2}&lt;gray&gt;/&lt;aqua&gt;${gui.pageCount}\")\n        } else {\n            // no arrow if we can't go further\n            ItemBuilder(Material.BLACK_STAINED_GLASS_PANE).hideTooltip(true)\n        }\n    }\n    .addClickHandler { _, gui, _ -&gt; gui.page++ }\n    .build()\n</code></pre> <ol> <li>Names in <code>ItemBuilder</code> are in MiniMessage format.</li> </ol> <p></p>"},{"location":"gui/#scroll-gui","title":"Scroll Gui","text":"<p>Like paged guis, a <code>ScrollGui</code> is also a specialized gui type that can contain items, guis, or inventories. However, instead of pages, content is displayed in lines that can be scrolled through.</p> <p>Firstly, you will need to create the scroll buttons:</p> <pre><code>val up: BoundItem = BoundItem.scrollBuilder()\n    .setItemProvider(ItemBuilder(Material.ARROW))\n    .addClickHandler { _, gui, _ -&gt; gui.line-- }\n    .build()\n\nval down: BoundItem = BoundItem.scrollBuilder()\n    .setItemProvider(ItemBuilder(Material.ARROW))\n    .addClickHandler { _, gui, _ -&gt; gui.line++ }\n    .build()\n</code></pre> <p>Like for paged guis, the content slots can be defined by adding a content list slot marker ingredient:</p> <pre><code>val allTheItemTypes: List&lt;Item&gt; = Material.entries\n    .filter { !it.isLegacy &amp;&amp; it.isItem }\n    .map { Item.simple(ItemBuilder(it)) }\n\nval gui: ScrollGui&lt;Item&gt; = ScrollGui.itemsBuilder()\n    .setStructure(\n        \"# # x x x x x x #\",\n        \"u # x x x x x x #\",\n        \"# # x x x x x x #\",\n        \"d # x x x x x x #\",\n        \"# # x x x x x x #\",\n    )\n    .addIngredient('#', Item.simple(ItemBuilder(Material.BLACK_STAINED_GLASS_PANE)))\n    .addIngredient('x', Markers.CONTENT_LIST_SLOT_HORIZONTAL)\n    .addIngredient('u', up)\n    .addIngredient('d', down)\n    .setContent(allTheItemTypes)\n    .build()\n</code></pre> <p></p>"},{"location":"gui/#tab-gui","title":"Tab Gui","text":"<p>A <code>TabGui</code> allows you to define a list of tabs, which themselves are also guis. You can then create tab buttons to switch between them.</p> <p>First, let's create the tab buttons:</p> <pre><code>val tab0Btn: BoundItem = BoundItem.tabBuilder()\n    .setItemProvider(ItemBuilder(Material.PAPER))\n    .addClickHandler { _, gui, _ -&gt; gui.tab = 0 }\n    .build()\n\nval tab1Btn: BoundItem = BoundItem.tabBuilder()\n    .setItemProvider(ItemBuilder(Material.CHAIN))\n    .addClickHandler { _, gui, _ -&gt; gui.tab = 1 }\n    .build()\n</code></pre> <p>Like before, you can define the content list slots for the tab area using a content list slot marker ingredient. In the following example, I have re-used the example paged- and scroll guis from above as tabs (after adjusting them a bit to fit into the dimensions of a tab):</p> <pre><code>val gui: TabGui = TabGui.builder()\n    .setStructure(\n        \"# # # 0 # 1 # # #\",\n        \"x x x x x x x x x\",\n        \"x x x x x x x x x\",\n        \"x x x x x x x x x\",\n        \"x x x x x x x x x\",\n    )\n    .addIngredient('#', Item.simple(ItemBuilder(Material.BLACK_STAINED_GLASS_PANE)))\n    .addIngredient('x', Markers.CONTENT_LIST_SLOT_HORIZONTAL)\n    .addIngredient('0', tab0Btn)\n    .addIngredient('1', tab1Btn)\n    .setTabs(listOf(tab0, tab1))\n    .build()\n</code></pre> <p></p> Full code <pre><code>val back: BoundItem = BoundItem.pagedBuilder()\n    .setItemProvider(ItemBuilder(Material.ARROW))\n    .addClickHandler { _, gui, _ -&gt; gui.page-- }\n    .build()\n\nval forward: BoundItem = BoundItem.pagedBuilder()\n    .setItemProvider(ItemBuilder(Material.ARROW))\n    .addClickHandler { _, gui, _ -&gt; gui.page++ }\n    .build()\n\nval up: BoundItem = BoundItem.scrollBuilder()\n    .setItemProvider(ItemBuilder(Material.ARROW))\n    .addClickHandler { _, gui, _ -&gt; gui.line-- }\n    .build()\n\nval down: BoundItem = BoundItem.scrollBuilder()\n    .setItemProvider(ItemBuilder(Material.ARROW))\n    .addClickHandler { _, gui, _ -&gt; gui.line++ }\n    .build()\n\nval tab0Btn: BoundItem = BoundItem.tabBuilder()\n    .setItemProvider(ItemBuilder(Material.PAPER))\n    .addClickHandler { _, gui, _ -&gt; gui.tab = 0 }\n    .build()\n\nval tab1Btn: BoundItem = BoundItem.tabBuilder()\n    .setItemProvider(ItemBuilder(Material.CHAIN))\n    .addClickHandler { _, gui, _ -&gt; gui.tab = 1 }\n    .build()\n\nval allTheItemTypes: List&lt;Item&gt; = Material.entries\n    .filter { !it.isLegacy &amp;&amp; it.isItem }\n    .map { Item.simple(ItemBuilder(it)) }\n\nval tab0: PagedGui&lt;Item&gt; = PagedGui.itemsBuilder()\n    .setStructure(\n        \"x x x x x x x x x\",\n        \"x x x x x x x x x\",\n        \"x x x x x x x x x\",\n        \"# # # &lt; # &gt; # # #\",\n    )\n    .addIngredient('#', Item.simple(ItemBuilder(Material.BLACK_STAINED_GLASS_PANE)))\n    .addIngredient('x', Markers.CONTENT_LIST_SLOT_HORIZONTAL)\n    .addIngredient('&lt;', back)\n    .addIngredient('&gt;', forward)\n    .setContent(allTheItemTypes)\n    .build()\n\nval tab1: ScrollGui&lt;Item&gt; = ScrollGui.itemsBuilder()\n    .setStructure(\n        \"u # x x x x x x #\",\n        \"# # x x x x x x #\",\n        \"# # x x x x x x #\",\n        \"d # x x x x x x #\",\n    )\n    .addIngredient('#', Item.simple(ItemBuilder(Material.BLACK_STAINED_GLASS_PANE)))\n    .addIngredient('x', Markers.CONTENT_LIST_SLOT_HORIZONTAL)\n    .addIngredient('u', up)\n    .addIngredient('d', down)\n    .setContent(allTheItemTypes)\n    .build()\n\nval gui: TabGui = TabGui.builder()\n    .setStructure(\n        \"# # # 0 # 1 # # #\",\n        \"x x x x x x x x x\",\n        \"x x x x x x x x x\",\n        \"x x x x x x x x x\",\n        \"x x x x x x x x x\",\n    )\n    .addIngredient('#', Item.simple(ItemBuilder(Material.BLACK_STAINED_GLASS_PANE)))\n    .addIngredient('x', Markers.CONTENT_LIST_SLOT_HORIZONTAL)\n    .addIngredient('0', tab0Btn)\n    .addIngredient('1', tab1Btn)\n    .setTabs(listOf(tab0, tab1))\n    .build()\n</code></pre>"},{"location":"gui/#global-ingredients","title":"Global Ingredients","text":"<p>Some ingredients, like content list slot markers or navigation buttons, are expected to stay the same across guis. For such cases, it may make sense to register the ingredients globally. Once you have defined a global ingredient, it will be automatically used by all gui builders, without having to manually call <code>addIngredient</code> every time.</p> <pre><code>Structure.addGlobalIngredient('x', Markers.CONTENT_LIST_SLOT_HORIZONTAL)\n\nStructure.addGlobalIngredient(\n    '&gt;',\n    BoundItem.pagedBuilder()\n        .setItemProvider(ItemBuilder(Material.ARROW))\n        .addClickHandler { _, gui, _ -&gt; gui.page++ }\n)\n\nStructure.addGlobalIngredient(\n    '&lt;',\n    BoundItem.pagedBuilder()\n        .setItemProvider(ItemBuilder(Material.ARROW))\n        .addClickHandler { _, gui, _ -&gt; gui.page-- }\n)\n</code></pre>"},{"location":"gui/#ingredient-preset","title":"Ingredient Preset","text":"<p>Instead of defining global ingredients, you can also create ingredient presets which you can then apply whenever needed:</p> <pre><code>val preset: IngredientPreset = IngredientPreset.builder()\n    .addIngredient(\n        '&gt;',\n        BoundItem.pagedBuilder()\n            .setItemProvider(ItemBuilder(Material.ARROW))\n            .addClickHandler { _, gui, _ -&gt; gui.page++ }\n    )\n    .addIngredient(\n        '&lt;',\n        BoundItem.pagedBuilder()\n            .setItemProvider(ItemBuilder(Material.ARROW))\n            .addClickHandler { _, gui, _ -&gt; gui.page-- }\n    )\n    .build()\n\nval gui: Gui = Gui.builder()\n    .setStructure(/* ... */)\n    .applyPreset(preset)\n    .build()\n</code></pre>"},{"location":"gui/#animations","title":"Animations","text":"<p>An animation lets slots of a gui pop in following a specific order with a specific delay.</p> <p>Animations consist of the following five components:</p> <ol> <li>Slot filter: Defines which slots are part of the animation.</li> <li>Slot selector: Selects the slots that are shown in each frame.</li> <li>Intermediary generator: Creates intermediary items that are displayed before the slots pop in. (air by default)</li> <li>Show handler: Called when slot(s) are shown, for example to play a sound effect.</li> <li>Finish handler: Called when the animation is finished.</li> </ol> <p>There are various built-in slot selectors available. In the following example, I chose <code>horizontalSnake</code> and added a filter that looks for slots of ingredient <code>#</code>. This means that only those slots will pop in, whereas all other slots will already be visible when the animation starts.</p> <pre><code>val animation = Animation.builder()\n    .setSlotSelector(Animation::horizontalSnakeSlotSelector)\n    .filterTaggedSlots('x') // specialized filter that looks for slots of ingredient 'x'\n    .build()\n</code></pre> <p>To start an animation, call <code>Gui.playAnimation(animation)</code>.</p> <p></p> Example: Playing animations on window open <p>There is no direct way to play animations on gui-open, because guis do not have awareness of \"being opened\". Instead, it is the window which is opened, and the gui is just embedded in the window. Additionally, it also doesn't make sense to share such guis between players, because only one of them will be the one opening the window. With a shared gui however, both would see the animation. This is why a separate gui instance per window is needed.</p> <p>If you configure your window and gui builders in a certain way, you can ensure separate gui instances per player and trigger a call to <code>playAnimation</code> automatically:</p> <pre><code>val windowBuilder: Window.Builder&lt;*, *&gt; = Window.builder()\n    .setUpperGui(PagedGui.itemsBuilder()\n        .setStructure(\n            \"# # # # # # # # #\",\n            \"# x x x x x x x #\",\n            \"# x x x x x x x #\",\n            \"# x x x x x x x #\",\n            \"# # # &lt; # &gt; # # #\",\n        )\n        .addIngredient('#', Item.simple(ItemBuilder(Material.BLACK_STAINED_GLASS_PANE).hideTooltip(true)))\n        .addIngredient('x', Markers.CONTENT_LIST_SLOT_HORIZONTAL)\n        .addIngredient('&lt;', back)\n        .addIngredient('&gt;', forward)\n        .setContent(allTheItemTypes)\n        .addModifier { it.playAnimation(animation) } // (1)!\n        // no .build()\n    )\n\nwindowBuilder.open(player) // builds gui and window for player, then opens window\n\n// ... later:\nwindowBuilder.open(otherPlayer) // builds gui and window for otherPlayer, then opens window\n</code></pre> <ol> <li>A modifier is a lambda that is run when the gui is built. Note that this code omits the <code>.build()</code> at the end of the gui builder chain. This causes the window builder to build a new gui for each window. Since we only use <code>windowBuilder.open</code>, building a window also means opening it. This means our modifier with <code>playAnimation</code> is called every time the window is opened.</li> </ol> Example: Playing animations for page switching <p>The following example uses the page buttons to start playing the animation, but you can just as well start the animation in the page change handler of the <code>PagedGui</code>.</p> <pre><code>val animation = Animation.builder()\n    .setSlotSelector(Animation::horizontalSnakeSlotSelector)\n    .filterTaggedSlots('x')\n    .setFreezing(false) // (1)!\n    .build()\n\nval back: BoundItem = BoundItem.pagedBuilder()\n    .setItemProvider(ItemBuilder(Material.ARROW))\n    .addClickHandler { _, gui, _ -&gt;\n        gui.cancelAnimation()\n        gui.page--\n        gui.playAnimation(animation)\n    }\n    .build()\n\nval forward: BoundItem = BoundItem.pagedBuilder()\n    .setItemProvider(ItemBuilder(Material.ARROW))\n    .addClickHandler { _, gui, _ -&gt;\n        gui.cancelAnimation()\n        gui.page++\n        gui.playAnimation(animation)\n    }\n    .build()\n\nval allTheItemTypes: List&lt;Item&gt; = Material.entries\n    .filter { !it.isLegacy &amp;&amp; it.isItem }\n    .map { Item.simple(ItemBuilder(it)) }\n\nval gui: PagedGui&lt;Item&gt; = PagedGui.itemsBuilder()\n    .setStructure(\n        \"# # # # # # # # #\",\n        \"# x x x x x x x #\",\n        \"# x x x x x x x #\",\n        \"# x x x x x x x #\",\n        \"# # # &lt; # &gt; # # #\",\n    )\n    .addIngredient('#', Item.simple(ItemBuilder(Material.BLACK_STAINED_GLASS_PANE)))\n    .addIngredient('x', Markers.CONTENT_LIST_SLOT_HORIZONTAL)\n    .addIngredient('&lt;', back)\n    .addIngredient('&gt;', forward)\n    .setContent(allTheItemTypes)\n    .build()\n</code></pre> <ol> <li>By default, animations freeze the gui while they are running. This means that the player cannot interact with the gui until the animation is finished. Disabling freezing allows the user to switch to the next page before the animation finishes playing.</li> </ol> <p></p>"},{"location":"inventory/","title":"Inventory","text":""},{"location":"inventory/#what-is-an-inventory","title":"What is an Inventory?","text":"<p>InvUI has its own inventories, not to be confused with <code>org.bukkit.inventory.Inventory</code>. InvUI's inventories can be embedded in guis, which will allow players to interact with these slots.</p>"},{"location":"inventory/#virtual-inventory","title":"Virtual Inventory","text":"<p>For most use cases, you will want to use a <code>VirtualInventory</code>. This is just a container for item stacks that you can add to your guis like so:</p> <pre><code>val inv = VirtualInventory(7 * 4)\nval gui = Gui.builder()\n    .setStructure(\n        \"# # # # # # # # #\",\n        \"# x x x x x x x #\",\n        \"# x x x x x x x #\",\n        \"# x x x x x x x #\",\n        \"# # # # # # # # #\",\n    )\n    .addIngredient('x', inv)\n    .build()\n</code></pre> <p></p>"},{"location":"inventory/#inventory-events","title":"Inventory Events","text":"<p>InvUI's inventories have a powerful event system. There are multiple events that you can listen to, each of which is fired at a different stage of the interaction and can be used for different purposes. <code>ItemPreUpdateEvent</code> and <code>ItemPostUpdateEvent</code> are fired with an <code>UpdateReason</code>. If a player interaction caused the event, this will be a <code>PlayerUpdateReason</code> from which you can retrieve the player and additional information about the click.</p>"},{"location":"inventory/#itempreupdateevent","title":"ItemPreUpdateEvent","text":"<p>This event is called before changes were fully processed. Cancelling this event or changing the amount of items that were added or removed will affect the source of the change (i.e. the player's cursor most of the time) appropriately, if possible. This allows restricting which or how many items can be put into an inventory or even a specific slot of an inventory.</p> <p>In the following example, the <code>ItemPreUpdateEvent</code> is cancelled or handled in such a way that only red and orange wool can be put into the inventory. Additionally, orange wool can no longer be stacked:</p> <pre><code>inv.addPreUpdateHandler { event -&gt;\n    if (event.isAdd || event.isSwap) {\n        when (event.newItem?.type) {\n            Material.RED_WOOL -&gt; Unit // red wool can be added normally\n            Material.ORANGE_WOOL -&gt; event.newItem?.amount = 1 // orange wool stack size is limited to 1\n            else -&gt; event.isCancelled = true // cancel event for all other item types\n        }\n    }\n}\n</code></pre> <p></p>"},{"location":"inventory/#itempostupdateevent","title":"ItemPostUpdateEvent","text":"<p>This event is called after changes were performed on a slot. It is not cancellable and changes done to the inventory during this event will not affect the source of the change.</p> <p>In the following example, the <code>ItemPostUpdateEvent</code> is used to implement a trash can menu:</p> <pre><code>inv.addPostUpdateHandler { event -&gt; \n    event.inventory.setItem(UpdateReason.SUPPRESSED, 0, null) // (1)!\n}\n</code></pre> <ol> <li><code>UpdateReason.SUPPRESSED</code> prevents events from firing. Otherwise, this would cause an infinite loop.</li> </ol> <p></p>"},{"location":"inventory/#inventoryclickevent","title":"InventoryClickEvent","text":"<p>InvUI also has its own inventory click event, not to be confused with <code>org.bukkit.event.inventory.InventoryClickEvent</code>. This event is fired when a player clicks on a slot in a gui-embedded inventory. For most cases, <code>ItemPreUpdateEvent</code> and <code>ItemPostUpdateEvent</code> are sufficient. However, in very specialized cases, you might want to intercept certain click actions and use them for something else.</p> <p>In the following example, the <code>InventoryClickEvent</code> is used to change the number key presses from moving the item to the hotbar slots to changing their amount instead:</p> <pre><code>inv.addClickHandler { event -&gt;\n    if (event.clickType == ClickType.NUMBER_KEY) {\n        event.isCancelled = true\n        val newItem = event.inventory.getItem(event.slot)?.apply { amount = event.hotbarButton + 1 }\n        event.inventory.setItem(null, event.slot, newItem)\n    }\n}\n</code></pre> <p></p>"},{"location":"inventory/#serialization","title":"Serialization","text":"<p>You can also serialize and deserialize <code>VirtualInventory</code> (i.e. saving and loading it):</p> Serializing a VirtualInventory<pre><code>// serialize a VirtualInventory to a ByteArray\nval bin: ByteArray = virtualInventory.serialize()\n\n// write a VirtualInventory directly to an output stream\nfile.outputStream().use { virtualInventory.serialize(it) }\n</code></pre> Deserializing a VirtualInventory<pre><code>// deserialize a VirtualInventory from a ByteArray\nval inv: VirtualInventory = VirtualInventory.deserialize(bin)\n\n// read a VirtualInventory directly from an input stream\nval inv2: VirtualInventory = file.inputStream().use { VirtualInventory.deserialize(it) }\n</code></pre> <p>There is also <code>VirtualInventoryManager</code>, which automatically writes virtual inventories registered with it to disk on shutdown and reads them back on startup. This allows you to very easily create persistent inventories, but note that using <code>VirtualInventoryManager</code> with a large amount of inventories will cause a slowdown on startup as all inventories are loaded on startup at once.</p> <pre><code>val inv: VirtualInventory = VirtualInventoryManager.getInstance().getOrCreate(uuid, size)\n</code></pre>"},{"location":"inventory/#referencing-inventory","title":"Referencing Inventory","text":"<p>The <code>ReferencingInventory</code> can be used to reference a Bukkit inventory, such as the player's inventory. For example, you can easily implement a gui to look at another player's inventory using it:</p> <p><pre><code>val inv = ReferencingInventory.fromPlayerStorageContents(otherPlayer.inventory)\nWindow.builder()\n    .setUpperGui(Gui.of(9, 4, inv))\n    .open(player)\n</code></pre> </p>"},{"location":"inventory/#other-configuration-options","title":"Other configuration options","text":""},{"location":"inventory/#gui-priority","title":"Gui priority","text":"<p>The gui priority defines the order in which inventories of a gui are iterated over for actions like shift-clicking items or collecting them to the cursor with a double click. Gui priority is categorized, so you can define different priorities per category.</p> <p>In the following example, the gui priorities are configured in such a way that items are shift-clicked into the right inventory first, but collecting to the cursor prioritizes the left inventory:</p> <pre><code>val left = VirtualInventory(9)\nleft.setGuiPriority(OperationCategory.ADD, -1)\nleft.setGuiPriority(OperationCategory.COLLECT, 1)\n\nval right = VirtualInventory(9)\n\nval gui = Gui.builder()\n    .setStructure(\n        \"# # # # # # # # #\",\n        \"# x x x # y y y #\",\n        \"# x x x # y y y #\",\n        \"# x x x # y y y #\",\n        \"# # # # # # # # #\",\n    )\n    .addIngredient('x', left)\n    .addIngredient('y', right)\n    .build()\n</code></pre> <p></p>"},{"location":"inventory/#iteration-order","title":"Iteration order","text":"<p>The iteration order defines in which order the slots of multi-slot operations like adding or collecting are chosen. By default, the iteration order is from first to the last slot (i.e. items are added into the first available slot and collected from the first matching slot). Like the gui priority, the iteration order is categorized, so you can define different orders per category.</p> <p>You can change the iteration to a completely custom sequence of slots, but there are also utilities to just reverse it. The following example reverses the iteration order for adding items, but keeps the iteration order for collection items:</p> <pre><code>val inv = VirtualInventory(7 * 4)\ninv.reverseIterationOrder(OperationCategory.ADD)\n\nval gui = Gui.builder()\n    .setStructure(\n        \"# # # # # # # # #\",\n        \"# x x x x x x x #\",\n        \"# x x x x x x x #\",\n        \"# x x x x x x x #\",\n        \"# # # # # # # # #\",\n    )\n    .addIngredient('#', Item.simple(ItemBuilder(Material.BLACK_STAINED_GLASS_PANE).hideTooltip(true)))\n    .addIngredient('x', inv)\n    .build()\n</code></pre> <p></p>"},{"location":"inventory/#background","title":"Background","text":"<p>The slots in your inventory may be empty, but this does not mean that they have to be visually empty as well. You can set a background <code>ItemProvider</code> for your inventory, which will be used to display empty slots. Inventory interactions will keep working as if the slots were empty.</p> <pre><code>val inv = VirtualInventory(7 * 4)\nval gui = Gui.builder()\n    .setStructure(\n        \"# # # # # # # # #\",\n        \"# x x x x x x x #\",\n        \"# x x x x x x x #\",\n        \"# x x x x x x x #\",\n        \"# # # # # # # # #\",\n    )\n    .addIngredient('x', inv, ItemBuilder(Material.WHITE_STAINED_GLASS_PANE).hideTooltip(true))\n    .build()\n</code></pre> <p></p> <p>Item dragging does not work on slots with a background item.</p>"},{"location":"inventory/#obscured-slots","title":"Obscured slots","text":"<p>By default, multi-slot operations like shift-clicking into or collecting from inventories that are embedded in guis will ignore all slots that are not visible, even if the inventory has more slots. You can change this behavior by setting <code>Gui.setIgnoreObscuredInventorySlots(false)</code>:</p> <p>The following example uses a scroll gui to display a large inventory that does not fit on one screen. By default, shift-clicking does nothing if there are no empty visible slots, but with <code>setIgnoreObscuredInventorySlots(false)</code>, this is not the case:</p> <pre><code>val inv = VirtualInventory(7 * 6)\nrepeat(7 * 3) { inv.addItem(null, ItemStack.of(Material.DIAMOND, 64)) }\n\nval gui = ScrollGui.inventoriesBuilder()\n    .setStructure(\n        \"# # # # # # # # #\",\n        \"# x x x x x x x u\",\n        \"# x x x x x x x #\",\n        \"# x x x x x x x d\",\n        \"# # # # # # # # #\",\n    )\n    .setContent(listOf(inv))\n    .setIgnoreObscuredInventorySlots(false)\n    .build()\n</code></pre> <p></p>"},{"location":"item/","title":"Item","text":""},{"location":"item/#what-is-an-item","title":"What is an Item?","text":"<p>InvUI's UI elements are called <code>Item</code>. You can think of an <code>Item</code> as a button, though not every <code>Item</code> needs to do something when clicked. An <code>Item</code> consists of the following components:</p> <ul> <li><code>ItemProvider</code>: This is the visual representation of the <code>Item</code>, i.e. an <code>ItemStack</code>. <code>ItemProvider</code> also allows for easy localization. InvUI's built-in <code>ItemBuilder</code> is an <code>ItemProvider</code>, but you can also just wrap any <code>ItemStack</code> using <code>ItemWrapper</code>.</li> <li>Click handler(s): Click handlers are code that runs when a player clicks on the item. An item can also have no click handlers, i.e. nothing happens and the item remains where it was. (and will not be picked up!)</li> </ul> <p>You can create a very simple item like this:</p> <pre><code>val item = Item.builder()\n    .setItemProvider(ItemBuilder(Material.DIAMOND)) // the item is represented by a diamond\n    .addClickHandler { item, click -&gt; println(\"Hello World!\") } // \"Hello World\" is printed to the console on click\n    .build()\n</code></pre> <p>For purely decorative items, you can use <code>Item.simple</code>:</p> <pre><code>val item = Item.simple(ItemBuilder(Material.DIAMOND))\n</code></pre>"},{"location":"item/#updating-items","title":"Updating Items","text":"<p>Of course, in a real-world scenario, you'll want to update the visual representation of the item dynamically. To do that, first define an item provider lambda instead of a constant item provider. However, that alone will not automatically update your item. To trigger an update, which calls your item provider lambda and refreshes the displayed <code>ItemStack</code>, you will need to call <code>Item.notifyWindows()</code>:</p> <pre><code>var count = 0\nval item: Item = Item.builder()\n    .setItemProvider { ItemBuilder(Material.DIAMOND).setName(\"Click count: $count\") }\n    .addClickHandler { item, click -&gt;\n        count++\n        item.notifyWindows()\n    }.build()\n</code></pre> <p>This can be simplified using <code>updateOnClick</code>:</p> <pre><code>var count = 0\nval item: Item = Item.builder()\n    .setItemProvider { ItemBuilder(Material.DIAMOND).setName(\"Click count: $count\") }\n    .addClickHandler { _, click -&gt; count++ }\n    .updateOnClick()\n    .build()\n</code></pre> <p></p> <p>In certain scenarios, it may make sense to update your item based on a timer:</p> <pre><code>val item: Item = Item.builder()\n    .setItemProvider { ItemBuilder(Material.DIAMOND).setName(\"Current time: ${System.currentTimeMillis()}\") }\n    .updatePeriodically(1) // Updates the item provider every tick\n    .build()\n</code></pre> <p></p> <p>There are also various methods available on gui-level that allow mass-updating multiple items at the same time. </p> <p>If you're using <code>invui-kotlin</code>, the best way is to handle item updating is to use the declarative gui design approach.</p>"},{"location":"item/#bundle-selection","title":"Bundle selection","text":"<p>Minecraft's bundle item adds unique inventory interactions to the game. You can also use bundles in InvUI. Simply register a bundle selection handler via <code>addBundleSelectHandler</code>:</p> <pre><code>val bundleItem: Item = Item.builder()\n    .setItemProvider(\n        ItemBuilder(Material.BUNDLE).set(\n            DataComponentTypes.BUNDLE_CONTENTS,\n            BundleContents.bundleContents().addAll(/* ... */).build()\n        )\n    )\n    .addBundleSelectHandler { _, _, selectedSlot -&gt; println(\"Slot selected: $selectedSlot\") }\n    .build()\n</code></pre> Example: Menu with bundle select handler <pre><code>val wools: List&lt;ItemStack&gt; = Tag.WOOL.values.map(ItemStack::of)\n\nvar selectedWool: Int = -1\nval display: Item = Item.builder()\n    .setItemProvider { wools.getOrNull(selectedWool)?.let(::ItemBuilder) ?: ItemProvider.EMPTY }\n    .build()\n\nval bundleItem: Item = Item.builder()\n    .setItemProvider(\n        ItemBuilder(Material.BUNDLE).set(\n            DataComponentTypes.BUNDLE_CONTENTS,\n            BundleContents.bundleContents().addAll(wools).build()\n        )\n    )\n    .addBundleSelectHandler { _, _, selectedSlot -&gt;\n        selectedWool = selectedSlot\n        display.notifyWindows()\n    }\n\nWindow.builder()\n    .setUpperGui(Gui.builder()\n        .setStructure(\"b # # # # # # # #\")\n        .addIngredient('b', bundleItem)\n        .addIngredient('#', display)\n    )\n    .setLowerGui(Gui.of(9, 4, display))\n    .open(player)\n</code></pre> <p></p>"},{"location":"item/#bound-item","title":"Bound Item","text":"<p>Normal items have no awareness of which <code>Gui</code> they are a part of. However, sometimes the item is supposed to display the state of a gui or interact with it in some other way. A concrete example for this would be page buttons in a <code>PagedGui</code>. They need to call methods on <code>PagedGui</code> in order to switch to the next page. This is where bound items come in: This special item type remembers the first <code>Gui</code> it is added to (it is \"bound\" to that gui) and passes this information on to the click handler.</p> <pre><code>val boundItem: BoundItem = BoundItem.builder()\n    // The bind handlers are run when the item is bound to a gui, i.e. when it is added to a gui.\n    // They can be used to register handlers on the gui, which then in turn refresh the item on certain actions (like page a change)\n    // You will likely not need to register bind handlers yourself, as pre-made bound items exist for all gui types and already handle this for you.\n    .addBindHandler { item, gui -&gt; /* ... */ }\n    // Like a normal item's click handler, except that it also retrieves the gui instance\n    .addClickHandler { item, gui, click -&gt; /* ... */ }\n    .build()    \n</code></pre> <p>The topic of bound items will be covered again in the gui section where needed. </p> <p>Re-using bound item instances</p> <p>Note that bound items are bound to the first gui they are added to. This means that you cannot re-use the same <code>BoundItem</code> instance across multiple guis. If you're registering bound items as global ingredients or in ingredient presets, make sure to pass the <code>BoundItem.Builder</code> and not a concrete <code>BoundItem</code> instance:</p> <pre><code>val boundItemBuilder = BoundItem.builder()\n    /* ... */\n\n// DO NOT DO THIS\n// 'x' will always be the same BoundItem instance\nStructure.addGlobalIngredient('x', boundItemBuilder.build())\n\n// DO THIS INSTEAD\n// 'x' will be a new BoundItem instance, built from boundItemBuilder, every time\nStructure.addGlobalIngredient('x', boundItemBuilder)\n</code></pre>"},{"location":"localization/","title":"Localization","text":""},{"location":"localization/#adding-translations","title":"Adding translations","text":"<p>To add translations for a new language, you can call <code>Languages.getInstance().addLanguage(Locale locale, Map&lt;String, String&gt; translations)</code>.  The <code>lang</code> parameter is the language code of the language you want to add. The <code>translations</code> parameter should be a map containing the translation keys and their translations.</p> <p>If your translations are stored in a json structure like this:</p> en_us.json<pre><code>{\n  \"translation.key\": \"Hello World\",\n  \"other.translation.key\": \"Hello World 2\"\n}\n</code></pre> <p>These translations are interpreted as MiniMessage strings. Argument placeholders in translations are defined using <code>&lt;arg:index&gt;</code> or with custom names like <code>&lt;name&gt;</code>, as explained on the MiniMessage Translator page.</p> <p>You can also load them using <code>Languages#loadLanguage</code>:</p> KotlinJava <pre><code>Languages.getInstance().loadLanguage(\"en_us\", File(\"en_us.json\"), Charsets.UTF_8)\n</code></pre> <pre><code>Languages.getInstance().loadLanguage(\"en_us\", new File(\"en_us.json\"), StandardCharsets.UTF_8);\n</code></pre>"},{"location":"localization/#specifying-player-language","title":"Specifying player language","text":"<p>By default, the player's locale is retrieved using <code>Player.locale()</code>. If you want to change this behavior, you can do so by calling <code>Languages#setLocaleProvider</code>:</p> KotlinJava <pre><code>Languages.getInstance().setLocaleProvider(Player::locale)\n</code></pre> <pre><code>Languages.getInstance().setLocaleProvider(Player::locale);\n</code></pre>"},{"location":"localization/#using-translations","title":"Using translations","text":"<p>To use translations in your menus, simply use <code>TranslatableComponent</code>:</p> <pre><code>Languages.getInstance().addLanguage(Locale.US, mapOf(\n    \"invui.example_window.title\" to \"&lt;aqua&gt;Example Window\",\n    \"invui.example_window.btn.name\" to \"&lt;red&gt;Example translation! &lt;arg:0&gt; &lt;placeholder&gt;\"\n))\n\nval itemBuilder = ItemBuilder(Material.DIAMOND)\n    .setName(Component.translatable(\"invui.example_window.btn.name\", Component.text(\"A\"))) // (1)!\n    .setPlaceholder(\"placeholder\", Component.text(\"B\")) // (2)!\n\nWindow.builder()\n    .setUpperGui(Gui.of(9, 1, Item.simple(itemBuilder)))\n    .setTitle(Component.translatable(\"invui.example_window.title\"))\n    .open(player)\n</code></pre> <ol> <li>You can pass the arguments directly using the translatable component, as explained here.</li> <li>Alternatively, you can also use the ItemBuilder's placeholder system. This fills in placeholders across all components, i.e. the name and lore of the item.</li> </ol> <p></p> <p>When are translations applied?</p> <p>Translations are applied server-side. This is done during <code>ItemBuilder.build()</code> or, for the inventory title, <code>Window.open()</code>. If you need to use server-side translations in other places, you'll need to manually call <code>Languages.localized(Locale locale, Component component)</code>.</p>"},{"location":"localization/#disabling-server-side-translations","title":"Disabling server-side translations","text":"<p>If you do not want your items and window titles to be translated server-side and instead want to send translatable components to your players, you can disable server-side translations by calling <code>Languages.getInstance().enableServerSideTranslations(false)</code>.</p>"},{"location":"overview/","title":"Quick Overview","text":"<p>In InvUI, there are four main concepts that you need to understand in order to create your own menus:</p> <ul> <li>Window: A window is what you may think of as an \"inventory\", \"menu\", or \"screen\". It is the opened menu that a player sees. Windows always encompass both the upper and lower (player) inventory. The actual slots of the window are defined by Guis.</li> <li>Gui: A Gui is a rectangular arrangement of slots that can contain Items.</li> <li>Item: An item is a single UI element that is visually represented by an <code>ItemProvider</code>. Items handle the click actions and can change their appearance (the <code>ItemProvider</code> by which they are presented) dynamically.</li> <li><code>ItemProvider</code>: An item provider is basically just an <code>ItemStack</code>, except that they support localization into the viewing player's language. You can use InvUI's built-in <code>ItemBuilder</code> as an item provider, or just wrap any <code>ItemStack</code> using <code>ItemWrapper</code>.</li> </ul> <p>To create a menu, you need to combine all of these concepts:</p> KotlinJava <pre><code>// item: a (clickable) ui element\nval helloWorldItem: Item = Item.builder()\n    .setItemProvider(ItemBuilder(Material.DIAMOND)) // the item is represented by a diamond (ItemBuilder acts as ItemProvider)\n    .addClickHandler { _, _ -&gt; println(\"Hello World!\") } // \"Hello World\" is printed to the console on click\n    .build()\n\n// gui: a rectangular arrangement of ui elements\nval gui: Gui = Gui.builder()\n    .setStructure(\"x x x x x x x x x\") // the gui is of dimensions 9x1 and uses the item 'x' everywhere\n    .addIngredient('x', helloWorldItem) // by item 'x', we mean helloWorldItem\n    .build()\n\n// window: the menu that is shown to the player, containing the gui(s), which contain the item(s)\nval window: Window = Window.builder()\n    .setTitle(\"Hello World!\")\n    .setUpperGui(gui)\n    .setViewer(player)\n    .build()\n\nwindow.open(player)\n</code></pre> <pre><code>\n</code></pre> <p></p> <p>The following pages will take a deeper look at items, guis, windows, and also additional concepts like inventories and localization.</p>"},{"location":"window/","title":"Window","text":""},{"location":"window/#what-is-a-window","title":"What is a Window?","text":"<p>In InvUI, windows represent the actual Minecraft inventories that are displayed to the player. Windows are made up of guis, whose number varies based on the window type. For example, a normal chest window has two guis: one for the upper and one for the lower inventory. Some window types also have special functionality, like the rename bar in anvil windows or the trade buttons in merchant windows.</p> <p>A window can only have one viewer. This makes localization easy, as up until this point we have dealt with <code>ItemProviders</code>, which can return an <code>ItemStack</code> based on a locale. Now, the window is the first part in the chain that actually resolves the <code>ItemStacks</code> - and as these are translated into a specific language, allowing multiple people to view the same window might cause one of them to see the wrong language.</p> <p>Every window encompasses both the upper- and the lower inventory (i.e. the player's inventory), even if you don't set a lower gui. However, by default, the lower gui is just a referencing inventory to the player's actual inventory. This allows the player to still interact with their inventory contents. When a window is open, InvUI controls the entire view at all times and no interactions are handled by Bukkit.</p>"},{"location":"window/#window-types","title":"Window Types","text":""},{"location":"window/#normal-window","title":"Normal Window","text":"<p>The normal window, which can be built using <code>Window.builder()</code>, is very flexible in the dimensions of the upper gui. Possible dimensions are: <code>9x6</code>, <code>9x5</code>, <code>9x4</code>, <code>9x3</code>, <code>9x2</code>, <code>9x1</code>, <code>5x1</code> and <code>3x3</code>. The lower gui is always <code>9x4</code>. For upper guis of width <code>9</code>, the generic chest inventory is used. <code>5x1</code> is a hopper inventory and <code>3x3</code> is a dropper inventory.</p> <p> </p> <p>The following example creates a window with an upper gui of dimensions <code>9x6</code>:</p> <pre><code>Window.builder()\n    .setTitle(\"Example Window\")\n    .setUpperGui(Gui.builder()\n        .setStructure(\n            \"# # # # # # # # #\",\n            \"# x x x x x x x #\",\n            \"# x x x x x x x #\",\n            \"# x x x x x x x #\",\n            \"# x x x x x x x #\",\n            \"# # # # # # # # #\"\n        )\n        .addIngredient('#', Item.simple(ItemBuilder(Material.BLACK_STAINED_GLASS_PANE).hideTooltip(true)))\n    )\n    .open(player)\n</code></pre> <p></p> <p>Every window type also allows you to set a <code>lowerGui</code>, which is the player's inventory. For the normal window, you can also create a <code>mergedBuilder()</code>, which accepts a singular gui that is then used for both of what were previously known as the upper and lower guis:</p> <pre><code>Window.mergedBuilder()\n    .setTitle(\"Example Window\")\n    .setGui(Gui.builder()\n        .setStructure(\n            \"# # # # # # # # #\",\n            \"# x x x x x x x #\",\n            \"# x x x x x x x #\",\n            \"# x x x x x x x #\",\n            \"# x x x x x x x #\",\n            \"# x x x x x x x #\",\n            \"# x x x x x x x #\",\n            \"# x x x x x x x #\",\n            \"# x x x x x x x #\",\n            \"# # # # # # # # #\"\n        )\n        .addIngredient('#', Item.simple(ItemBuilder(Material.BLACK_STAINED_GLASS_PANE).hideTooltip(true)))\n    )\n    .open(player)\n</code></pre> <p></p>"},{"location":"window/#anvil-window","title":"Anvil Window","text":"<p>The anvil window can be created using <code>AnvilWindow.builder()</code>. It consists of two guis: the <code>3x1</code> upper gui and the <code>9x4</code> lower gui. Additionally, the anvil window has a text input field, for which you can register handlers via <code>addRenameHandler</code>.</p> <p></p> Example: Anvil-based search window <pre><code>fun getItems(search: String): List&lt;Item&gt; =  Material.entries\n    .filter { !it.isLegacy &amp;&amp; it.isItem }\n    .filter { it.name.contains(search, true) }\n    .map { Item.simple(ItemBuilder(it)) }\n\nval gui: PagedGui&lt;Item&gt; = PagedGui.itemsBuilder()\n    .setStructure(\n        \"x x x x x x x x x\",\n        \"x x x x x x x x x\",\n        \"x x x x x x x x x\",\n        \"x x x x x x x x x\"\n    )\n    .addIngredient('x', Markers.CONTENT_LIST_SLOT_HORIZONTAL)\n    .setContent(getItems(\"\"))\n    .build()\n\nAnvilWindow.builder()\n    .addRenameHandler { search -&gt; gui.setContent(getItems(search)) }\n    .setLowerGui(gui)\n    .open(player)\n</code></pre> <p></p>"},{"location":"window/#brewing-window","title":"Brewing Window","text":"<p>The brewing window can be created using <code>BrewingWindow.builder()</code>. It consists of a <code>1x1</code> input gui, a <code>1x1</code> fuel gui, a <code>3x1</code> result gui and a <code>9x4</code> lower gui. Additionally, you can control the brew- and fuel progress bars.</p> <p></p>"},{"location":"window/#cartography-window","title":"Cartography Window","text":"<p>The cartography window can be created using <code>CartographyWindow.builder()</code>. It consists of a <code>1x2</code> input gui, a <code>1x1</code> result gui and a <code>9x4</code> lower gui. The cartography window allows you to render arbitrary <code>128x128px</code> images onto the map, as well as place marker icons and switch between the different map view types (duplicate, expand, lock).</p> <p></p> Example: Drawing in the cartography window <p>The following example takes advantage of the fact that bundles select slot <code>-1</code> when the mouse cursor leaves them.</p> <pre><code>lateinit var window: CartographyWindow\n\nval img = BufferedImage(128, 128, BufferedImage.TYPE_INT_RGB)\nval lowerGui = Gui.empty(9, 4)\nfor (x in 0..&lt;9) {\n    for (y in 0..&lt;4) {\n        lowerGui[x, y] = Item.builder()\n            .setItemProvider {\n                ItemBuilder(Material.BUNDLE)\n                    .set(DataComponentTypes.ITEM_MODEL, Key.key(\"minecraft\", \"black_stained_glass_pane\"))\n                    .hideTooltip(true)\n            }\n            .addBundleSelectHandler { _, _, _ -&gt;\n                val graphics = img.createGraphics()\n                graphics.color = Color.WHITE\n                graphics.fillRect(\n                    (x / 9.0 * 128).toInt(),\n                    (y / 4.0 * 128).toInt(),\n                    ceil(1.0 / 9.0 * 128).toInt(),\n                    ceil(1.0 / 4.0 * 128).toInt()\n                )\n                graphics.dispose()\n                window.applyPatch(0, 0, img)\n            }\n            .build()\n    }\n}\n\nval resetItem = Item.builder()\n    .setItemProvider(ItemBuilder(Material.BARRIER).setName(\"&lt;red&gt;Clear\"))\n    .addClickHandler { _, _ -&gt;\n        val graphics = img.createGraphics()\n        graphics.color = Color.BLACK\n        graphics.fillRect(0, 0, img.width, img.height)\n        graphics.dispose()\n        window.applyPatch(0, 0, img)\n    }.build()\n\nwindow = CartographyWindow.builder()\n    .setViewer(player)\n    .setResultGui(Gui.single(resetItem))\n    .setLowerGui(lowerGui)\n    .build()\n\nwindow.open()\n</code></pre> <p></p>"},{"location":"window/#crafter-window","title":"Crafter Window","text":"<p>The crafter window can be created using <code>CrafterWindow.builder()</code>. It consists of a <code>3x3</code> crafting gui, a <code>1x1</code> result gui and a <code>9x4</code> lower gui. The disabled state of the crafting slots can be both server-controlled and used as player input by registering a slot toggle handler via <code>addSlotToggleHandler</code>.</p> <p></p>"},{"location":"window/#crafting-window","title":"Crafting Window","text":"<p>The crafting window can be created using <code>CraftingWindow.builder()</code>. It consists of a <code>3x3</code> crafting gui, a <code>1x1</code> result gui and a <code>9x4</code> lower gui. Clicks in the recipe book can be handled via <code>addRecipeClickHandler</code> and ghost recipes can be shown via <code>sendGhostRecipe</code>.</p> <p></p> Example: Crafting window that always suggests a diamond hoe <p>The following example registers a recipe click handler that ignores the clicked recipe and always suggests a diamond hoe instead.</p> <pre><code>lateinit var w: CraftingWindow \nw = CraftingWindow.builder()\n    .setCraftingGui(Gui.of(3, 3, VirtualInventory(9)))\n    .addRecipeClickHandler { _ -&gt; w.sendGhostRecipe(Key.key(\"minecraft:diamond_hoe\")) }\n    .setViewer(player)\n    .build()\nw.open()\n</code></pre> <p></p>"},{"location":"window/#furnace-window","title":"Furnace Window","text":"<p>The furnace window can be created using <code>FurnaceWindow.builder()</code>. It consists of a <code>1x2</code> input gui, a <code>1x1</code> result gui and a <code>9x4</code> lower gui. Like the crafting window, you can handle recipe clicks via <code>addRecipeClickHandler</code> and ghost recipes can be shown via <code>sendGhostRecipe</code>. Additionally, you can control the cook and burn progress.</p> <p></p>"},{"location":"window/#grindstone-window","title":"Grindstone Window","text":"<p>The grindstone window can be created using <code>GrindstoneWindow.builder()</code>. It consists of a <code>1x2</code> input gui, a <code>1x1</code> result gui and a <code>9x4</code> lower gui.</p> <p></p>"},{"location":"window/#merchant-window","title":"Merchant Window","text":"<p>The merchant window can be created using <code>MerchantWindow.builder()</code>. It consists of a <code>3x1</code> upper gui and a <code>9x4</code> lower gui. Additionally, you can set a list of trades that will show up as a scrollable list of buttons on the left side. A trade consists of three items and some additional metadata. When a trade is clicked, the click handlers of all three items are fired.</p> <p></p> Example: Using trades as tab buttons <p>In the following example, the trade buttons are used to switch the tabs of a TabGui:</p> <pre><code>val woolItems: List&lt;ItemStack&gt; = Tag.WOOL.values.map(ItemStack::of)\n\nval tabGui: TabGui = TabGui.builder()\n    .setStructure(\n        \"x x x x x x x x x\",\n        \"x x x x x x x x x\",\n        \"x x x x x x x x x\",\n        \"x x x x x x x x x\"\n    )\n    .addIngredient('x', Markers.CONTENT_LIST_SLOT_HORIZONTAL)\n    .setTabs(woolItems.map { Gui.of(9, 4, Item.simple(it)) })\n    .build()\n\nval trades: List&lt;MerchantWindow.Trade&gt; = woolItems.mapIndexed { i, woolItem -&gt;\n    val tabItem = Item.builder()\n        .setItemProvider(woolItem)\n        .addClickHandler { _, _ -&gt; tabGui.tab = i }\n        .build()\n\n    MerchantWindow.Trade.builder()\n        .setFirstInput(tabItem)\n        .build()\n}\n\nMerchantWindow.builder()\n    .setLowerGui(tabGui)\n    .setTrades(trades)\n    .open(player)\n</code></pre> <p></p>"},{"location":"window/#smithing-window","title":"Smithing Window","text":"<p>The smithing window can be created using <code>SmithingWindow.builder()</code>. It consists of a <code>4x1</code> upper gui and a <code>9x4</code> lower gui. The item in the rightmost slot is rendered onto the armor stand (either it's equipment or hand item).</p> <p></p>"},{"location":"window/#stonecutter-window","title":"Stonecutter Window","text":"<p>The stonecutter window can be created using <code>StonecutterWindow.builder()</code>. It consists of a <code>2x1</code> upper gui, a <code>4xN</code> buttons gui, where <code>N</code> can be any number, and a <code>9x4</code> lower gui. You can use the scroll bar to scroll through the buttons. A button can be selected and deselected by both the server and the player. You can register a selection handler via <code>addSelectedSlotChangeHandler</code>.</p> <p></p> Example: Using the buttons as an inventory <p>The following example embeds a <code>VirtualInventory</code> into the buttons gui. Note that updating the buttons resets the scroll bar to the top, so this is not a practical use case.</p> <pre><code>StonecutterWindow.builder()\n    .setButtonsGui(Gui.of(4, 100, VirtualInventory(400)))\n    .addModifier { w -&gt; w.addSelectedSlotChangeHandler { _, to -&gt; if (to != -1) w.selectedSlot = -1 } } // (1)!\n    .open(player)\n</code></pre> <ol> <li>This immediately unselects selected buttons.</li> </ol> <p></p>"},{"location":"window/#using-the-player-inventory","title":"Using the player inventory","text":"<p>As mentioned before, the player inventory is always part of the window and thereby always handled by InvUI, even if you don't set a lower gui. InvUI's windows are also packet-based, which has the following benefits:</p> <ul> <li>Window items inside the player inventory cannot be accidentally saved to the world and end up in the actual player's inventory.</li> <li>UI items in the player inventory cannot trigger advancements.</li> <li>The player can still pick up or be given items while a window is open, without them showing up in the lower gui. They will then just be there when the window is closed. (Unless the lower gui just references the player's inventory, in which case they will show up immediately.)</li> </ul> <p>By default, the lower gui is populated by a referencing inventory that is configured like this:</p> <pre><code>Inventory inv = ReferencingInventory.fromPlayerStorageContents(viewer.getInventory());\ninv.reverseIterationOrder(OperationCategory.ADD); // shift-clicking moves to bottom right instead of top left\ninv.setGuiPriority(OperationCategory.ADD, Integer.MAX_VALUE); // shift-click always moves between upper and lower inv\ninv.setGuiPriority(OperationCategory.COLLECT, Integer.MIN_VALUE); // double-click collects from lower inv last\n</code></pre> <p>However, you can put any <code>9x4</code> gui as the lower gui, which will then be used instead of the default one. For example, this can be used to implement a search preview when using an anvil window as text input.</p> Example: Using another player's inventory as the lower gui <p>The following example embeds another player's inventory into the lower gui instead of the player's own inventory:</p> <pre><code>val inv = ReferencingInventory.fromPlayerStorageContents(otherPlayer.inventory)\ninv.reverseIterationOrder(OperationCategory.ADD) // shift-clicking moves to bottom right instead of top left\ninv.setGuiPriority(OperationCategory.ADD, Int.MAX_VALUE) // shift-click always moves between upper and lower inv\ninv.setGuiPriority(OperationCategory.COLLECT, Int.MIN_VALUE) // double-click collects from lower inv last\n\nWindow.builder()\n    .setUpperGui(Gui.empty(5, 1))\n    .setLowerGui(Gui.of(9, 4, inv))\n    .open(player)\n</code></pre> <p></p>"},{"location":"window/#fallback-window","title":"Fallback Window","text":"<p>When designing menus that span multiple windows, it may often make sense to have some way of going back to a previous window. Apart from just adding an item that opens said window, you can also set a window that should be opened when the player closes the window by pressing <code>E</code> or <code>ESC</code>. This is called the fallback window.</p> <pre><code>val fallback = CartographyWindow.builder()\n    .setViewer(player)\n    // no fallback, pressing ESC in cartography window closes it\n    .build()\nAnvilWindow.builder()\n    .setFallbackWindow(fallback) // pressing ESC in anvil window opens cartography window\n    .open(player)\n</code></pre> <p></p>"}]}